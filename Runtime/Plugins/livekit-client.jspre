var livekit;
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/***/ (function(module) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/***/ (function(module) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/***/ (function(module) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/***/ (function(module) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/***/ (function(module) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ (function(module) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/livekit-client/dist/api/SignalClient.js":
/*!**************************************************************!*\
  !*** ./node_modules/livekit-client/dist/api/SignalClient.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toProtoSessionDescription = exports.SignalClient = void 0;
__webpack_require__(/*! webrtc-adapter */ "./node_modules/webrtc-adapter/src/js/adapter_core.js");
const logger_1 = __importDefault(__webpack_require__(/*! ../logger */ "./node_modules/livekit-client/dist/logger.js"));
const livekit_rtc_1 = __webpack_require__(/*! ../proto/livekit_rtc */ "./node_modules/livekit-client/dist/proto/livekit_rtc.js");
const errors_1 = __webpack_require__(/*! ../room/errors */ "./node_modules/livekit-client/dist/room/errors.js");
const utils_1 = __webpack_require__(/*! ../room/utils */ "./node_modules/livekit-client/dist/room/utils.js");
/** @internal */
class SignalClient {
    constructor(useJSON = false) {
        this.isConnected = false;
        this.useJSON = useJSON;
    }
    join(url, token, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            // during a full reconnect, we'd want to start the sequence even if currently
            // connected
            this.isConnected = false;
            const res = yield this.connect(url, token, {
                autoSubscribe: opts === null || opts === void 0 ? void 0 : opts.autoSubscribe,
            });
            return res;
        });
    }
    reconnect(url, token) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.connect(url, token, {
                reconnect: true,
            });
        });
    }
    connect(url, token, opts) {
        if (url.startsWith('http')) {
            url = url.replace('http', 'ws');
        }
        // strip trailing slash
        url = url.replace(/\/$/, '');
        url += '/rtc';
        const clientInfo = utils_1.getClientInfo();
        const params = createConnectionParams(token, clientInfo, opts);
        return new Promise((resolve, reject) => {
            logger_1.default.debug('connecting to', url + params);
            this.ws = undefined;
            const ws = new WebSocket(url + params);
            ws.binaryType = 'arraybuffer';
            ws.onerror = (ev) => __awaiter(this, void 0, void 0, function* () {
                if (!this.ws) {
                    try {
                        const resp = yield fetch(`http${url.substring(2)}/validate${params}`);
                        if (!resp.ok) {
                            const msg = yield resp.text();
                            reject(new errors_1.ConnectionError(msg));
                        }
                        else {
                            reject(new errors_1.ConnectionError('Internal error'));
                        }
                    }
                    catch (e) {
                        reject(new errors_1.ConnectionError('server was not reachable'));
                    }
                    return;
                }
                // other errors, handle
                this.handleWSError(ev);
            });
            ws.onopen = () => {
                this.ws = ws;
                if (opts.reconnect) {
                    // upon reconnection, there will not be additional handshake
                    this.isConnected = true;
                    resolve();
                }
            };
            ws.onmessage = (ev) => __awaiter(this, void 0, void 0, function* () {
                // not considered connected until JoinResponse is received
                let msg;
                if (typeof ev.data === 'string') {
                    const json = JSON.parse(ev.data);
                    msg = livekit_rtc_1.SignalResponse.fromJSON(json);
                }
                else if (ev.data instanceof ArrayBuffer) {
                    msg = livekit_rtc_1.SignalResponse.decode(new Uint8Array(ev.data));
                }
                else {
                    logger_1.default.error('could not decode websocket message', typeof ev.data);
                    return;
                }
                if (!this.isConnected) {
                    // handle join message only
                    if (msg.join) {
                        this.isConnected = true;
                        resolve(msg.join);
                    }
                    else {
                        reject(new errors_1.ConnectionError('did not receive join response'));
                    }
                    return;
                }
                if (this.signalLatency) {
                    yield utils_1.sleep(this.signalLatency);
                }
                this.handleSignalResponse(msg);
            });
            ws.onclose = (ev) => {
                if (!this.isConnected || this.ws !== ws)
                    return;
                logger_1.default.debug('websocket connection closed', ev.reason);
                this.isConnected = false;
                if (this.onClose)
                    this.onClose(ev.reason);
                if (this.ws === ws) {
                    this.ws = undefined;
                }
            };
        });
    }
    close() {
        var _a;
        this.isConnected = false;
        if (this.ws)
            this.ws.onclose = null;
        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();
        this.ws = undefined;
    }
    // initial offer after joining
    sendOffer(offer) {
        logger_1.default.debug('sending offer', offer);
        this.sendRequest({
            offer: toProtoSessionDescription(offer),
        });
    }
    // answer a server-initiated offer
    sendAnswer(answer) {
        logger_1.default.debug('sending answer');
        this.sendRequest({
            answer: toProtoSessionDescription(answer),
        });
    }
    sendIceCandidate(candidate, target) {
        logger_1.default.trace('sending ice candidate', candidate);
        this.sendRequest({
            trickle: {
                candidateInit: JSON.stringify(candidate),
                target,
            },
        });
    }
    sendMuteTrack(trackSid, muted) {
        this.sendRequest({
            mute: {
                sid: trackSid,
                muted,
            },
        });
    }
    sendAddTrack(req) {
        this.sendRequest({
            addTrack: livekit_rtc_1.AddTrackRequest.fromPartial(req),
        });
    }
    sendUpdateTrackSettings(settings) {
        this.sendRequest({ trackSetting: settings });
    }
    sendUpdateSubscription(sub) {
        this.sendRequest({ subscription: sub });
    }
    sendSyncState(sync) {
        this.sendRequest({ syncState: sync });
    }
    sendUpdateVideoLayers(trackSid, layers) {
        this.sendRequest({
            updateLayers: {
                trackSid,
                layers,
            },
        });
    }
    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {
        this.sendRequest({
            subscriptionPermission: {
                allParticipants,
                trackPermissions,
            },
        });
    }
    sendSimulateScenario(scenario) {
        this.sendRequest({
            simulate: scenario,
        });
    }
    sendLeave() {
        this.sendRequest(livekit_rtc_1.SignalRequest.fromPartial({ leave: {} }));
    }
    sendRequest(req) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.signalLatency) {
                yield utils_1.sleep(this.signalLatency);
            }
            if (!this.ws) {
                logger_1.default.error('cannot send signal request before connected');
                return;
            }
            try {
                if (this.useJSON) {
                    this.ws.send(JSON.stringify(livekit_rtc_1.SignalRequest.toJSON(req)));
                }
                else {
                    this.ws.send(livekit_rtc_1.SignalRequest.encode(req).finish());
                }
            }
            catch (e) {
                logger_1.default.error('error sending signal message', e);
            }
        });
    }
    handleSignalResponse(msg) {
        if (msg.answer) {
            const sd = fromProtoSessionDescription(msg.answer);
            if (this.onAnswer) {
                this.onAnswer(sd);
            }
        }
        else if (msg.offer) {
            const sd = fromProtoSessionDescription(msg.offer);
            if (this.onOffer) {
                this.onOffer(sd);
            }
        }
        else if (msg.trickle) {
            const candidate = JSON.parse(msg.trickle.candidateInit);
            if (this.onTrickle) {
                this.onTrickle(candidate, msg.trickle.target);
            }
        }
        else if (msg.update) {
            if (this.onParticipantUpdate) {
                this.onParticipantUpdate(msg.update.participants);
            }
        }
        else if (msg.trackPublished) {
            if (this.onLocalTrackPublished) {
                this.onLocalTrackPublished(msg.trackPublished);
            }
        }
        else if (msg.speakersChanged) {
            if (this.onSpeakersChanged) {
                this.onSpeakersChanged(msg.speakersChanged.speakers);
            }
        }
        else if (msg.leave) {
            if (this.onLeave) {
                this.onLeave(msg.leave);
            }
        }
        else if (msg.mute) {
            if (this.onRemoteMuteChanged) {
                this.onRemoteMuteChanged(msg.mute.sid, msg.mute.muted);
            }
        }
        else if (msg.roomUpdate) {
            if (this.onRoomUpdate) {
                this.onRoomUpdate(msg.roomUpdate.room);
            }
        }
        else if (msg.connectionQuality) {
            if (this.onConnectionQuality) {
                this.onConnectionQuality(msg.connectionQuality);
            }
        }
        else if (msg.streamStateUpdate) {
            if (this.onStreamStateUpdate) {
                this.onStreamStateUpdate(msg.streamStateUpdate);
            }
        }
        else if (msg.subscribedQualityUpdate) {
            if (this.onSubscribedQualityUpdate) {
                this.onSubscribedQualityUpdate(msg.subscribedQualityUpdate);
            }
        }
        else if (msg.subscriptionPermissionUpdate) {
            if (this.onSubscriptionPermissionUpdate) {
                this.onSubscriptionPermissionUpdate(msg.subscriptionPermissionUpdate);
            }
        }
        else if (msg.refreshToken) {
            if (this.onTokenRefresh) {
                this.onTokenRefresh(msg.refreshToken);
            }
        }
        else {
            logger_1.default.debug('unsupported message', msg);
        }
    }
    handleWSError(ev) {
        logger_1.default.error('websocket error', ev);
    }
}
exports.SignalClient = SignalClient;
function fromProtoSessionDescription(sd) {
    const rsd = {
        type: 'offer',
        sdp: sd.sdp,
    };
    switch (sd.type) {
        case 'answer':
        case 'offer':
        case 'pranswer':
        case 'rollback':
            rsd.type = sd.type;
            break;
        default:
            break;
    }
    return rsd;
}
function toProtoSessionDescription(rsd) {
    const sd = {
        sdp: rsd.sdp,
        type: rsd.type,
    };
    return sd;
}
exports.toProtoSessionDescription = toProtoSessionDescription;
function createConnectionParams(token, info, opts) {
    const params = new URLSearchParams();
    params.set('access_token', token);
    // opts
    if (opts === null || opts === void 0 ? void 0 : opts.reconnect) {
        params.set('reconnect', '1');
    }
    if ((opts === null || opts === void 0 ? void 0 : opts.autoSubscribe) !== undefined) {
        params.set('auto_subscribe', opts.autoSubscribe ? '1' : '0');
    }
    // ClientInfo
    params.set('sdk', 'js');
    params.set('version', info.version);
    params.set('protocol', info.protocol.toString());
    if (info.deviceModel) {
        params.set('device_model', info.deviceModel);
    }
    if (info.os) {
        params.set('os', info.os);
    }
    if (info.osVersion) {
        params.set('os_version', info.osVersion);
    }
    if (info.browser) {
        params.set('browser', info.browser);
    }
    if (info.browserVersion) {
        params.set('browser_version', info.browserVersion);
    }
    return `?${params.toString()}`;
}
//# sourceMappingURL=SignalClient.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/connect.js":
/*!*****************************************************!*\
  !*** ./node_modules/livekit-client/dist/connect.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.connect = exports.version = void 0;
const logger_1 = __importStar(__webpack_require__(/*! ./logger */ "./node_modules/livekit-client/dist/logger.js"));
const errors_1 = __webpack_require__(/*! ./room/errors */ "./node_modules/livekit-client/dist/room/errors.js");
const events_1 = __webpack_require__(/*! ./room/events */ "./node_modules/livekit-client/dist/room/events.js");
const Room_1 = __importDefault(__webpack_require__(/*! ./room/Room */ "./node_modules/livekit-client/dist/room/Room.js"));
var version_1 = __webpack_require__(/*! ./version */ "./node_modules/livekit-client/dist/version.js");
Object.defineProperty(exports, "version", ({ enumerable: true, get: function () { return version_1.version; } }));
/**
 * Connects to a LiveKit room, shorthand for `new Room()` and [[Room.connect]]
 *
 * ```typescript
 * connect('wss://myhost.livekit.io', token, {
 *   // publish audio and video tracks on joining
 *   audio: true,
 *   video: true,
 *   captureDefaults: {
 *    facingMode: 'user',
 *   },
 * })
 * ```
 * @param url URL to LiveKit server
 * @param token AccessToken, a JWT token that includes authentication and room details
 * @param options
 */
function connect(url, token, options) {
    var _a, _b, _c, _d;
    return __awaiter(this, void 0, void 0, function* () {
        options !== null && options !== void 0 ? options : (options = {});
        if (options.adaptiveStream === undefined) {
            options.adaptiveStream = options.autoManageVideo;
        }
        logger_1.setLogLevel((_a = options.logLevel) !== null && _a !== void 0 ? _a : logger_1.LogLevel.warn);
        const config = (_b = options.rtcConfig) !== null && _b !== void 0 ? _b : {};
        if (options.iceServers) {
            config.iceServers = options.iceServers;
        }
        const room = new Room_1.default(options);
        // connect to room
        yield room.connect(url, token, options);
        const publishAudio = (_c = options.audio) !== null && _c !== void 0 ? _c : false;
        const publishVideo = (_d = options.video) !== null && _d !== void 0 ? _d : false;
        if (publishAudio || publishVideo) {
            setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                // if publishing both
                let err;
                if (publishAudio && publishVideo) {
                    try {
                        yield room.localParticipant.enableCameraAndMicrophone();
                    }
                    catch (e) {
                        const errKind = errors_1.MediaDeviceFailure.getFailure(e);
                        logger_1.default.warn('received error while creating media', errKind);
                        if (e instanceof Error) {
                            logger_1.default.warn(e.message);
                        }
                        // when it's a device issue, try to publish the other kind
                        if (errKind === errors_1.MediaDeviceFailure.NotFound
                            || errKind === errors_1.MediaDeviceFailure.DeviceInUse) {
                            try {
                                yield room.localParticipant.setMicrophoneEnabled(true);
                            }
                            catch (audioErr) {
                                err = audioErr;
                            }
                        }
                        else {
                            err = e;
                        }
                    }
                }
                else if (publishAudio) {
                    try {
                        yield room.localParticipant.setMicrophoneEnabled(true);
                    }
                    catch (e) {
                        err = e;
                    }
                }
                else if (publishVideo) {
                    try {
                        yield room.localParticipant.setCameraEnabled(true);
                    }
                    catch (e) {
                        err = e;
                    }
                }
                if (err) {
                    room.emit(events_1.RoomEvent.MediaDevicesError, err);
                    logger_1.default.error('could not create media', err);
                }
            }));
        }
        return room;
    });
}
exports.connect = connect;
//# sourceMappingURL=connect.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/livekit-client/dist/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VideoQuality = exports.TrackPublication = exports.RemoteTrackPublication = exports.RemoteVideoTrack = exports.RemoteAudioTrack = exports.RemoteTrack = exports.LocalTrackPublication = exports.LocalTrack = exports.LocalVideoTrack = exports.LocalAudioTrack = exports.LocalParticipant = exports.RemoteParticipant = exports.Participant = exports.ConnectionQuality = exports.DataPacket_Kind = exports.RoomState = exports.Room = exports.setLogLevel = void 0;
const logger_1 = __webpack_require__(/*! ./logger */ "./node_modules/livekit-client/dist/logger.js");
Object.defineProperty(exports, "setLogLevel", ({ enumerable: true, get: function () { return logger_1.setLogLevel; } }));
const livekit_models_1 = __webpack_require__(/*! ./proto/livekit_models */ "./node_modules/livekit-client/dist/proto/livekit_models.js");
Object.defineProperty(exports, "DataPacket_Kind", ({ enumerable: true, get: function () { return livekit_models_1.DataPacket_Kind; } }));
Object.defineProperty(exports, "VideoQuality", ({ enumerable: true, get: function () { return livekit_models_1.VideoQuality; } }));
const LocalParticipant_1 = __importDefault(__webpack_require__(/*! ./room/participant/LocalParticipant */ "./node_modules/livekit-client/dist/room/participant/LocalParticipant.js"));
exports.LocalParticipant = LocalParticipant_1.default;
const Participant_1 = __importStar(__webpack_require__(/*! ./room/participant/Participant */ "./node_modules/livekit-client/dist/room/participant/Participant.js"));
exports.Participant = Participant_1.default;
Object.defineProperty(exports, "ConnectionQuality", ({ enumerable: true, get: function () { return Participant_1.ConnectionQuality; } }));
const RemoteParticipant_1 = __importDefault(__webpack_require__(/*! ./room/participant/RemoteParticipant */ "./node_modules/livekit-client/dist/room/participant/RemoteParticipant.js"));
exports.RemoteParticipant = RemoteParticipant_1.default;
const Room_1 = __importStar(__webpack_require__(/*! ./room/Room */ "./node_modules/livekit-client/dist/room/Room.js"));
exports.Room = Room_1.default;
Object.defineProperty(exports, "RoomState", ({ enumerable: true, get: function () { return Room_1.RoomState; } }));
const LocalAudioTrack_1 = __importDefault(__webpack_require__(/*! ./room/track/LocalAudioTrack */ "./node_modules/livekit-client/dist/room/track/LocalAudioTrack.js"));
exports.LocalAudioTrack = LocalAudioTrack_1.default;
const LocalTrack_1 = __importDefault(__webpack_require__(/*! ./room/track/LocalTrack */ "./node_modules/livekit-client/dist/room/track/LocalTrack.js"));
exports.LocalTrack = LocalTrack_1.default;
const LocalTrackPublication_1 = __importDefault(__webpack_require__(/*! ./room/track/LocalTrackPublication */ "./node_modules/livekit-client/dist/room/track/LocalTrackPublication.js"));
exports.LocalTrackPublication = LocalTrackPublication_1.default;
const LocalVideoTrack_1 = __importDefault(__webpack_require__(/*! ./room/track/LocalVideoTrack */ "./node_modules/livekit-client/dist/room/track/LocalVideoTrack.js"));
exports.LocalVideoTrack = LocalVideoTrack_1.default;
const RemoteAudioTrack_1 = __importDefault(__webpack_require__(/*! ./room/track/RemoteAudioTrack */ "./node_modules/livekit-client/dist/room/track/RemoteAudioTrack.js"));
exports.RemoteAudioTrack = RemoteAudioTrack_1.default;
const RemoteTrack_1 = __importDefault(__webpack_require__(/*! ./room/track/RemoteTrack */ "./node_modules/livekit-client/dist/room/track/RemoteTrack.js"));
exports.RemoteTrack = RemoteTrack_1.default;
const RemoteTrackPublication_1 = __importDefault(__webpack_require__(/*! ./room/track/RemoteTrackPublication */ "./node_modules/livekit-client/dist/room/track/RemoteTrackPublication.js"));
exports.RemoteTrackPublication = RemoteTrackPublication_1.default;
const RemoteVideoTrack_1 = __importDefault(__webpack_require__(/*! ./room/track/RemoteVideoTrack */ "./node_modules/livekit-client/dist/room/track/RemoteVideoTrack.js"));
exports.RemoteVideoTrack = RemoteVideoTrack_1.default;
const TrackPublication_1 = __webpack_require__(/*! ./room/track/TrackPublication */ "./node_modules/livekit-client/dist/room/track/TrackPublication.js");
Object.defineProperty(exports, "TrackPublication", ({ enumerable: true, get: function () { return TrackPublication_1.TrackPublication; } }));
__exportStar(__webpack_require__(/*! ./connect */ "./node_modules/livekit-client/dist/connect.js"), exports);
__exportStar(__webpack_require__(/*! ./options */ "./node_modules/livekit-client/dist/options.js"), exports);
__exportStar(__webpack_require__(/*! ./room/errors */ "./node_modules/livekit-client/dist/room/errors.js"), exports);
__exportStar(__webpack_require__(/*! ./room/events */ "./node_modules/livekit-client/dist/room/events.js"), exports);
__exportStar(__webpack_require__(/*! ./room/track/create */ "./node_modules/livekit-client/dist/room/track/create.js"), exports);
__exportStar(__webpack_require__(/*! ./room/track/options */ "./node_modules/livekit-client/dist/room/track/options.js"), exports);
__exportStar(__webpack_require__(/*! ./room/track/Track */ "./node_modules/livekit-client/dist/room/track/Track.js"), exports);
__exportStar(__webpack_require__(/*! ./room/track/types */ "./node_modules/livekit-client/dist/room/track/types.js"), exports);
__exportStar(__webpack_require__(/*! ./version */ "./node_modules/livekit-client/dist/version.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/logger.js":
/*!****************************************************!*\
  !*** ./node_modules/livekit-client/dist/logger.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setLogLevel = exports.LogLevel = void 0;
const loglevel_1 = __importDefault(__webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js"));
var LogLevel;
(function (LogLevel) {
    LogLevel["trace"] = "trace";
    LogLevel["debug"] = "debug";
    LogLevel["info"] = "info";
    LogLevel["warn"] = "warn";
    LogLevel["error"] = "error";
    LogLevel["silent"] = "silent";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
const livekitLogger = loglevel_1.default.getLogger('livekit');
livekitLogger.setLevel(LogLevel.info);
exports["default"] = livekitLogger;
function setLogLevel(level) {
    livekitLogger.setLevel(level);
}
exports.setLogLevel = setLogLevel;
//# sourceMappingURL=logger.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/options.js":
/*!*****************************************************!*\
  !*** ./node_modules/livekit-client/dist/options.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=options.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/proto/livekit_models.js":
/*!******************************************************************!*\
  !*** ./node_modules/livekit-client/dist/proto/livekit_models.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientInfo = exports.ParticipantTracks = exports.UserPacket = exports.SpeakerInfo = exports.ActiveSpeakerUpdate = exports.DataPacket = exports.VideoLayer = exports.TrackInfo = exports.ParticipantInfo = exports.Codec = exports.Room = exports.clientInfo_SDKToJSON = exports.clientInfo_SDKFromJSON = exports.ClientInfo_SDK = exports.dataPacket_KindToJSON = exports.dataPacket_KindFromJSON = exports.DataPacket_Kind = exports.participantInfo_StateToJSON = exports.participantInfo_StateFromJSON = exports.ParticipantInfo_State = exports.connectionQualityToJSON = exports.connectionQualityFromJSON = exports.ConnectionQuality = exports.videoQualityToJSON = exports.videoQualityFromJSON = exports.VideoQuality = exports.trackSourceToJSON = exports.trackSourceFromJSON = exports.TrackSource = exports.trackTypeToJSON = exports.trackTypeFromJSON = exports.TrackType = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
exports.protobufPackage = "livekit";
var TrackType;
(function (TrackType) {
    TrackType[TrackType["AUDIO"] = 0] = "AUDIO";
    TrackType[TrackType["VIDEO"] = 1] = "VIDEO";
    TrackType[TrackType["DATA"] = 2] = "DATA";
    TrackType[TrackType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TrackType = exports.TrackType || (exports.TrackType = {}));
function trackTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "AUDIO":
            return TrackType.AUDIO;
        case 1:
        case "VIDEO":
            return TrackType.VIDEO;
        case 2:
        case "DATA":
            return TrackType.DATA;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TrackType.UNRECOGNIZED;
    }
}
exports.trackTypeFromJSON = trackTypeFromJSON;
function trackTypeToJSON(object) {
    switch (object) {
        case TrackType.AUDIO:
            return "AUDIO";
        case TrackType.VIDEO:
            return "VIDEO";
        case TrackType.DATA:
            return "DATA";
        default:
            return "UNKNOWN";
    }
}
exports.trackTypeToJSON = trackTypeToJSON;
var TrackSource;
(function (TrackSource) {
    TrackSource[TrackSource["UNKNOWN"] = 0] = "UNKNOWN";
    TrackSource[TrackSource["CAMERA"] = 1] = "CAMERA";
    TrackSource[TrackSource["MICROPHONE"] = 2] = "MICROPHONE";
    TrackSource[TrackSource["SCREEN_SHARE"] = 3] = "SCREEN_SHARE";
    TrackSource[TrackSource["SCREEN_SHARE_AUDIO"] = 4] = "SCREEN_SHARE_AUDIO";
    TrackSource[TrackSource["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TrackSource = exports.TrackSource || (exports.TrackSource = {}));
function trackSourceFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return TrackSource.UNKNOWN;
        case 1:
        case "CAMERA":
            return TrackSource.CAMERA;
        case 2:
        case "MICROPHONE":
            return TrackSource.MICROPHONE;
        case 3:
        case "SCREEN_SHARE":
            return TrackSource.SCREEN_SHARE;
        case 4:
        case "SCREEN_SHARE_AUDIO":
            return TrackSource.SCREEN_SHARE_AUDIO;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TrackSource.UNRECOGNIZED;
    }
}
exports.trackSourceFromJSON = trackSourceFromJSON;
function trackSourceToJSON(object) {
    switch (object) {
        case TrackSource.UNKNOWN:
            return "UNKNOWN";
        case TrackSource.CAMERA:
            return "CAMERA";
        case TrackSource.MICROPHONE:
            return "MICROPHONE";
        case TrackSource.SCREEN_SHARE:
            return "SCREEN_SHARE";
        case TrackSource.SCREEN_SHARE_AUDIO:
            return "SCREEN_SHARE_AUDIO";
        default:
            return "UNKNOWN";
    }
}
exports.trackSourceToJSON = trackSourceToJSON;
var VideoQuality;
(function (VideoQuality) {
    VideoQuality[VideoQuality["LOW"] = 0] = "LOW";
    VideoQuality[VideoQuality["MEDIUM"] = 1] = "MEDIUM";
    VideoQuality[VideoQuality["HIGH"] = 2] = "HIGH";
    VideoQuality[VideoQuality["OFF"] = 3] = "OFF";
    VideoQuality[VideoQuality["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(VideoQuality = exports.VideoQuality || (exports.VideoQuality = {}));
function videoQualityFromJSON(object) {
    switch (object) {
        case 0:
        case "LOW":
            return VideoQuality.LOW;
        case 1:
        case "MEDIUM":
            return VideoQuality.MEDIUM;
        case 2:
        case "HIGH":
            return VideoQuality.HIGH;
        case 3:
        case "OFF":
            return VideoQuality.OFF;
        case -1:
        case "UNRECOGNIZED":
        default:
            return VideoQuality.UNRECOGNIZED;
    }
}
exports.videoQualityFromJSON = videoQualityFromJSON;
function videoQualityToJSON(object) {
    switch (object) {
        case VideoQuality.LOW:
            return "LOW";
        case VideoQuality.MEDIUM:
            return "MEDIUM";
        case VideoQuality.HIGH:
            return "HIGH";
        case VideoQuality.OFF:
            return "OFF";
        default:
            return "UNKNOWN";
    }
}
exports.videoQualityToJSON = videoQualityToJSON;
var ConnectionQuality;
(function (ConnectionQuality) {
    ConnectionQuality[ConnectionQuality["POOR"] = 0] = "POOR";
    ConnectionQuality[ConnectionQuality["GOOD"] = 1] = "GOOD";
    ConnectionQuality[ConnectionQuality["EXCELLENT"] = 2] = "EXCELLENT";
    ConnectionQuality[ConnectionQuality["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConnectionQuality = exports.ConnectionQuality || (exports.ConnectionQuality = {}));
function connectionQualityFromJSON(object) {
    switch (object) {
        case 0:
        case "POOR":
            return ConnectionQuality.POOR;
        case 1:
        case "GOOD":
            return ConnectionQuality.GOOD;
        case 2:
        case "EXCELLENT":
            return ConnectionQuality.EXCELLENT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ConnectionQuality.UNRECOGNIZED;
    }
}
exports.connectionQualityFromJSON = connectionQualityFromJSON;
function connectionQualityToJSON(object) {
    switch (object) {
        case ConnectionQuality.POOR:
            return "POOR";
        case ConnectionQuality.GOOD:
            return "GOOD";
        case ConnectionQuality.EXCELLENT:
            return "EXCELLENT";
        default:
            return "UNKNOWN";
    }
}
exports.connectionQualityToJSON = connectionQualityToJSON;
var ParticipantInfo_State;
(function (ParticipantInfo_State) {
    /** JOINING - websocket' connected, but not offered yet */
    ParticipantInfo_State[ParticipantInfo_State["JOINING"] = 0] = "JOINING";
    /** JOINED - server received client offer */
    ParticipantInfo_State[ParticipantInfo_State["JOINED"] = 1] = "JOINED";
    /** ACTIVE - ICE connectivity established */
    ParticipantInfo_State[ParticipantInfo_State["ACTIVE"] = 2] = "ACTIVE";
    /** DISCONNECTED - WS disconnected */
    ParticipantInfo_State[ParticipantInfo_State["DISCONNECTED"] = 3] = "DISCONNECTED";
    ParticipantInfo_State[ParticipantInfo_State["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ParticipantInfo_State = exports.ParticipantInfo_State || (exports.ParticipantInfo_State = {}));
function participantInfo_StateFromJSON(object) {
    switch (object) {
        case 0:
        case "JOINING":
            return ParticipantInfo_State.JOINING;
        case 1:
        case "JOINED":
            return ParticipantInfo_State.JOINED;
        case 2:
        case "ACTIVE":
            return ParticipantInfo_State.ACTIVE;
        case 3:
        case "DISCONNECTED":
            return ParticipantInfo_State.DISCONNECTED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ParticipantInfo_State.UNRECOGNIZED;
    }
}
exports.participantInfo_StateFromJSON = participantInfo_StateFromJSON;
function participantInfo_StateToJSON(object) {
    switch (object) {
        case ParticipantInfo_State.JOINING:
            return "JOINING";
        case ParticipantInfo_State.JOINED:
            return "JOINED";
        case ParticipantInfo_State.ACTIVE:
            return "ACTIVE";
        case ParticipantInfo_State.DISCONNECTED:
            return "DISCONNECTED";
        default:
            return "UNKNOWN";
    }
}
exports.participantInfo_StateToJSON = participantInfo_StateToJSON;
var DataPacket_Kind;
(function (DataPacket_Kind) {
    DataPacket_Kind[DataPacket_Kind["RELIABLE"] = 0] = "RELIABLE";
    DataPacket_Kind[DataPacket_Kind["LOSSY"] = 1] = "LOSSY";
    DataPacket_Kind[DataPacket_Kind["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DataPacket_Kind = exports.DataPacket_Kind || (exports.DataPacket_Kind = {}));
function dataPacket_KindFromJSON(object) {
    switch (object) {
        case 0:
        case "RELIABLE":
            return DataPacket_Kind.RELIABLE;
        case 1:
        case "LOSSY":
            return DataPacket_Kind.LOSSY;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DataPacket_Kind.UNRECOGNIZED;
    }
}
exports.dataPacket_KindFromJSON = dataPacket_KindFromJSON;
function dataPacket_KindToJSON(object) {
    switch (object) {
        case DataPacket_Kind.RELIABLE:
            return "RELIABLE";
        case DataPacket_Kind.LOSSY:
            return "LOSSY";
        default:
            return "UNKNOWN";
    }
}
exports.dataPacket_KindToJSON = dataPacket_KindToJSON;
var ClientInfo_SDK;
(function (ClientInfo_SDK) {
    ClientInfo_SDK[ClientInfo_SDK["UNKNOWN"] = 0] = "UNKNOWN";
    ClientInfo_SDK[ClientInfo_SDK["JS"] = 1] = "JS";
    ClientInfo_SDK[ClientInfo_SDK["SWIFT"] = 2] = "SWIFT";
    ClientInfo_SDK[ClientInfo_SDK["ANDROID"] = 3] = "ANDROID";
    ClientInfo_SDK[ClientInfo_SDK["FLUTTER"] = 4] = "FLUTTER";
    ClientInfo_SDK[ClientInfo_SDK["GO"] = 5] = "GO";
    ClientInfo_SDK[ClientInfo_SDK["UNITY"] = 6] = "UNITY";
    ClientInfo_SDK[ClientInfo_SDK["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientInfo_SDK = exports.ClientInfo_SDK || (exports.ClientInfo_SDK = {}));
function clientInfo_SDKFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return ClientInfo_SDK.UNKNOWN;
        case 1:
        case "JS":
            return ClientInfo_SDK.JS;
        case 2:
        case "SWIFT":
            return ClientInfo_SDK.SWIFT;
        case 3:
        case "ANDROID":
            return ClientInfo_SDK.ANDROID;
        case 4:
        case "FLUTTER":
            return ClientInfo_SDK.FLUTTER;
        case 5:
        case "GO":
            return ClientInfo_SDK.GO;
        case 6:
        case "UNITY":
            return ClientInfo_SDK.UNITY;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ClientInfo_SDK.UNRECOGNIZED;
    }
}
exports.clientInfo_SDKFromJSON = clientInfo_SDKFromJSON;
function clientInfo_SDKToJSON(object) {
    switch (object) {
        case ClientInfo_SDK.UNKNOWN:
            return "UNKNOWN";
        case ClientInfo_SDK.JS:
            return "JS";
        case ClientInfo_SDK.SWIFT:
            return "SWIFT";
        case ClientInfo_SDK.ANDROID:
            return "ANDROID";
        case ClientInfo_SDK.FLUTTER:
            return "FLUTTER";
        case ClientInfo_SDK.GO:
            return "GO";
        case ClientInfo_SDK.UNITY:
            return "UNITY";
        default:
            return "UNKNOWN";
    }
}
exports.clientInfo_SDKToJSON = clientInfo_SDKToJSON;
const baseRoom = {
    sid: "",
    name: "",
    emptyTimeout: 0,
    maxParticipants: 0,
    creationTime: 0,
    turnPassword: "",
    metadata: "",
    numParticipants: 0,
    activeRecording: false,
};
exports.Room = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sid !== "") {
            writer.uint32(10).string(message.sid);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.emptyTimeout !== 0) {
            writer.uint32(24).uint32(message.emptyTimeout);
        }
        if (message.maxParticipants !== 0) {
            writer.uint32(32).uint32(message.maxParticipants);
        }
        if (message.creationTime !== 0) {
            writer.uint32(40).int64(message.creationTime);
        }
        if (message.turnPassword !== "") {
            writer.uint32(50).string(message.turnPassword);
        }
        for (const v of message.enabledCodecs) {
            exports.Codec.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.metadata !== "") {
            writer.uint32(66).string(message.metadata);
        }
        if (message.numParticipants !== 0) {
            writer.uint32(72).uint32(message.numParticipants);
        }
        if (message.activeRecording === true) {
            writer.uint32(80).bool(message.activeRecording);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRoom);
        message.enabledCodecs = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sid = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.emptyTimeout = reader.uint32();
                    break;
                case 4:
                    message.maxParticipants = reader.uint32();
                    break;
                case 5:
                    message.creationTime = longToNumber(reader.int64());
                    break;
                case 6:
                    message.turnPassword = reader.string();
                    break;
                case 7:
                    message.enabledCodecs.push(exports.Codec.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.metadata = reader.string();
                    break;
                case 9:
                    message.numParticipants = reader.uint32();
                    break;
                case 10:
                    message.activeRecording = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseRoom);
        message.enabledCodecs = [];
        if (object.sid !== undefined && object.sid !== null) {
            message.sid = String(object.sid);
        }
        else {
            message.sid = "";
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        if (object.emptyTimeout !== undefined && object.emptyTimeout !== null) {
            message.emptyTimeout = Number(object.emptyTimeout);
        }
        else {
            message.emptyTimeout = 0;
        }
        if (object.maxParticipants !== undefined &&
            object.maxParticipants !== null) {
            message.maxParticipants = Number(object.maxParticipants);
        }
        else {
            message.maxParticipants = 0;
        }
        if (object.creationTime !== undefined && object.creationTime !== null) {
            message.creationTime = Number(object.creationTime);
        }
        else {
            message.creationTime = 0;
        }
        if (object.turnPassword !== undefined && object.turnPassword !== null) {
            message.turnPassword = String(object.turnPassword);
        }
        else {
            message.turnPassword = "";
        }
        if (object.enabledCodecs !== undefined && object.enabledCodecs !== null) {
            for (const e of object.enabledCodecs) {
                message.enabledCodecs.push(exports.Codec.fromJSON(e));
            }
        }
        if (object.metadata !== undefined && object.metadata !== null) {
            message.metadata = String(object.metadata);
        }
        else {
            message.metadata = "";
        }
        if (object.numParticipants !== undefined &&
            object.numParticipants !== null) {
            message.numParticipants = Number(object.numParticipants);
        }
        else {
            message.numParticipants = 0;
        }
        if (object.activeRecording !== undefined &&
            object.activeRecording !== null) {
            message.activeRecording = Boolean(object.activeRecording);
        }
        else {
            message.activeRecording = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.sid !== undefined && (obj.sid = message.sid);
        message.name !== undefined && (obj.name = message.name);
        message.emptyTimeout !== undefined &&
            (obj.emptyTimeout = message.emptyTimeout);
        message.maxParticipants !== undefined &&
            (obj.maxParticipants = message.maxParticipants);
        message.creationTime !== undefined &&
            (obj.creationTime = message.creationTime);
        message.turnPassword !== undefined &&
            (obj.turnPassword = message.turnPassword);
        if (message.enabledCodecs) {
            obj.enabledCodecs = message.enabledCodecs.map((e) => e ? exports.Codec.toJSON(e) : undefined);
        }
        else {
            obj.enabledCodecs = [];
        }
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.numParticipants !== undefined &&
            (obj.numParticipants = message.numParticipants);
        message.activeRecording !== undefined &&
            (obj.activeRecording = message.activeRecording);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = Object.assign({}, baseRoom);
        message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : "";
        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
        message.emptyTimeout = (_c = object.emptyTimeout) !== null && _c !== void 0 ? _c : 0;
        message.maxParticipants = (_d = object.maxParticipants) !== null && _d !== void 0 ? _d : 0;
        message.creationTime = (_e = object.creationTime) !== null && _e !== void 0 ? _e : 0;
        message.turnPassword = (_f = object.turnPassword) !== null && _f !== void 0 ? _f : "";
        message.enabledCodecs = [];
        if (object.enabledCodecs !== undefined && object.enabledCodecs !== null) {
            for (const e of object.enabledCodecs) {
                message.enabledCodecs.push(exports.Codec.fromPartial(e));
            }
        }
        message.metadata = (_g = object.metadata) !== null && _g !== void 0 ? _g : "";
        message.numParticipants = (_h = object.numParticipants) !== null && _h !== void 0 ? _h : 0;
        message.activeRecording = (_j = object.activeRecording) !== null && _j !== void 0 ? _j : false;
        return message;
    },
};
const baseCodec = { mime: "", fmtpLine: "" };
exports.Codec = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mime !== "") {
            writer.uint32(10).string(message.mime);
        }
        if (message.fmtpLine !== "") {
            writer.uint32(18).string(message.fmtpLine);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCodec);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mime = reader.string();
                    break;
                case 2:
                    message.fmtpLine = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseCodec);
        if (object.mime !== undefined && object.mime !== null) {
            message.mime = String(object.mime);
        }
        else {
            message.mime = "";
        }
        if (object.fmtpLine !== undefined && object.fmtpLine !== null) {
            message.fmtpLine = String(object.fmtpLine);
        }
        else {
            message.fmtpLine = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.mime !== undefined && (obj.mime = message.mime);
        message.fmtpLine !== undefined && (obj.fmtpLine = message.fmtpLine);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseCodec);
        message.mime = (_a = object.mime) !== null && _a !== void 0 ? _a : "";
        message.fmtpLine = (_b = object.fmtpLine) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
const baseParticipantInfo = {
    sid: "",
    identity: "",
    state: 0,
    metadata: "",
    joinedAt: 0,
    hidden: false,
    recorder: false,
    name: "",
};
exports.ParticipantInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sid !== "") {
            writer.uint32(10).string(message.sid);
        }
        if (message.identity !== "") {
            writer.uint32(18).string(message.identity);
        }
        if (message.state !== 0) {
            writer.uint32(24).int32(message.state);
        }
        for (const v of message.tracks) {
            exports.TrackInfo.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.metadata !== "") {
            writer.uint32(42).string(message.metadata);
        }
        if (message.joinedAt !== 0) {
            writer.uint32(48).int64(message.joinedAt);
        }
        if (message.hidden === true) {
            writer.uint32(56).bool(message.hidden);
        }
        if (message.recorder === true) {
            writer.uint32(64).bool(message.recorder);
        }
        if (message.name !== "") {
            writer.uint32(74).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParticipantInfo);
        message.tracks = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sid = reader.string();
                    break;
                case 2:
                    message.identity = reader.string();
                    break;
                case 3:
                    message.state = reader.int32();
                    break;
                case 4:
                    message.tracks.push(exports.TrackInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.metadata = reader.string();
                    break;
                case 6:
                    message.joinedAt = longToNumber(reader.int64());
                    break;
                case 7:
                    message.hidden = reader.bool();
                    break;
                case 8:
                    message.recorder = reader.bool();
                    break;
                case 9:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseParticipantInfo);
        message.tracks = [];
        if (object.sid !== undefined && object.sid !== null) {
            message.sid = String(object.sid);
        }
        else {
            message.sid = "";
        }
        if (object.identity !== undefined && object.identity !== null) {
            message.identity = String(object.identity);
        }
        else {
            message.identity = "";
        }
        if (object.state !== undefined && object.state !== null) {
            message.state = participantInfo_StateFromJSON(object.state);
        }
        else {
            message.state = 0;
        }
        if (object.tracks !== undefined && object.tracks !== null) {
            for (const e of object.tracks) {
                message.tracks.push(exports.TrackInfo.fromJSON(e));
            }
        }
        if (object.metadata !== undefined && object.metadata !== null) {
            message.metadata = String(object.metadata);
        }
        else {
            message.metadata = "";
        }
        if (object.joinedAt !== undefined && object.joinedAt !== null) {
            message.joinedAt = Number(object.joinedAt);
        }
        else {
            message.joinedAt = 0;
        }
        if (object.hidden !== undefined && object.hidden !== null) {
            message.hidden = Boolean(object.hidden);
        }
        else {
            message.hidden = false;
        }
        if (object.recorder !== undefined && object.recorder !== null) {
            message.recorder = Boolean(object.recorder);
        }
        else {
            message.recorder = false;
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.sid !== undefined && (obj.sid = message.sid);
        message.identity !== undefined && (obj.identity = message.identity);
        message.state !== undefined &&
            (obj.state = participantInfo_StateToJSON(message.state));
        if (message.tracks) {
            obj.tracks = message.tracks.map((e) => e ? exports.TrackInfo.toJSON(e) : undefined);
        }
        else {
            obj.tracks = [];
        }
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.joinedAt !== undefined && (obj.joinedAt = message.joinedAt);
        message.hidden !== undefined && (obj.hidden = message.hidden);
        message.recorder !== undefined && (obj.recorder = message.recorder);
        message.name !== undefined && (obj.name = message.name);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = Object.assign({}, baseParticipantInfo);
        message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;
        message.tracks = [];
        if (object.tracks !== undefined && object.tracks !== null) {
            for (const e of object.tracks) {
                message.tracks.push(exports.TrackInfo.fromPartial(e));
            }
        }
        message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : "";
        message.joinedAt = (_e = object.joinedAt) !== null && _e !== void 0 ? _e : 0;
        message.hidden = (_f = object.hidden) !== null && _f !== void 0 ? _f : false;
        message.recorder = (_g = object.recorder) !== null && _g !== void 0 ? _g : false;
        message.name = (_h = object.name) !== null && _h !== void 0 ? _h : "";
        return message;
    },
};
const baseTrackInfo = {
    sid: "",
    type: 0,
    name: "",
    muted: false,
    width: 0,
    height: 0,
    simulcast: false,
    disableDtx: false,
    source: 0,
    mimeType: "",
    mid: "",
};
exports.TrackInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sid !== "") {
            writer.uint32(10).string(message.sid);
        }
        if (message.type !== 0) {
            writer.uint32(16).int32(message.type);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.muted === true) {
            writer.uint32(32).bool(message.muted);
        }
        if (message.width !== 0) {
            writer.uint32(40).uint32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(48).uint32(message.height);
        }
        if (message.simulcast === true) {
            writer.uint32(56).bool(message.simulcast);
        }
        if (message.disableDtx === true) {
            writer.uint32(64).bool(message.disableDtx);
        }
        if (message.source !== 0) {
            writer.uint32(72).int32(message.source);
        }
        for (const v of message.layers) {
            exports.VideoLayer.encode(v, writer.uint32(82).fork()).ldelim();
        }
        if (message.mimeType !== "") {
            writer.uint32(90).string(message.mimeType);
        }
        if (message.mid !== "") {
            writer.uint32(98).string(message.mid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTrackInfo);
        message.layers = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sid = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.muted = reader.bool();
                    break;
                case 5:
                    message.width = reader.uint32();
                    break;
                case 6:
                    message.height = reader.uint32();
                    break;
                case 7:
                    message.simulcast = reader.bool();
                    break;
                case 8:
                    message.disableDtx = reader.bool();
                    break;
                case 9:
                    message.source = reader.int32();
                    break;
                case 10:
                    message.layers.push(exports.VideoLayer.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.mimeType = reader.string();
                    break;
                case 12:
                    message.mid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseTrackInfo);
        message.layers = [];
        if (object.sid !== undefined && object.sid !== null) {
            message.sid = String(object.sid);
        }
        else {
            message.sid = "";
        }
        if (object.type !== undefined && object.type !== null) {
            message.type = trackTypeFromJSON(object.type);
        }
        else {
            message.type = 0;
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        if (object.muted !== undefined && object.muted !== null) {
            message.muted = Boolean(object.muted);
        }
        else {
            message.muted = false;
        }
        if (object.width !== undefined && object.width !== null) {
            message.width = Number(object.width);
        }
        else {
            message.width = 0;
        }
        if (object.height !== undefined && object.height !== null) {
            message.height = Number(object.height);
        }
        else {
            message.height = 0;
        }
        if (object.simulcast !== undefined && object.simulcast !== null) {
            message.simulcast = Boolean(object.simulcast);
        }
        else {
            message.simulcast = false;
        }
        if (object.disableDtx !== undefined && object.disableDtx !== null) {
            message.disableDtx = Boolean(object.disableDtx);
        }
        else {
            message.disableDtx = false;
        }
        if (object.source !== undefined && object.source !== null) {
            message.source = trackSourceFromJSON(object.source);
        }
        else {
            message.source = 0;
        }
        if (object.layers !== undefined && object.layers !== null) {
            for (const e of object.layers) {
                message.layers.push(exports.VideoLayer.fromJSON(e));
            }
        }
        if (object.mimeType !== undefined && object.mimeType !== null) {
            message.mimeType = String(object.mimeType);
        }
        else {
            message.mimeType = "";
        }
        if (object.mid !== undefined && object.mid !== null) {
            message.mid = String(object.mid);
        }
        else {
            message.mid = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.sid !== undefined && (obj.sid = message.sid);
        message.type !== undefined && (obj.type = trackTypeToJSON(message.type));
        message.name !== undefined && (obj.name = message.name);
        message.muted !== undefined && (obj.muted = message.muted);
        message.width !== undefined && (obj.width = message.width);
        message.height !== undefined && (obj.height = message.height);
        message.simulcast !== undefined && (obj.simulcast = message.simulcast);
        message.disableDtx !== undefined && (obj.disableDtx = message.disableDtx);
        message.source !== undefined &&
            (obj.source = trackSourceToJSON(message.source));
        if (message.layers) {
            obj.layers = message.layers.map((e) => e ? exports.VideoLayer.toJSON(e) : undefined);
        }
        else {
            obj.layers = [];
        }
        message.mimeType !== undefined && (obj.mimeType = message.mimeType);
        message.mid !== undefined && (obj.mid = message.mid);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const message = Object.assign({}, baseTrackInfo);
        message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : "";
        message.type = (_b = object.type) !== null && _b !== void 0 ? _b : 0;
        message.name = (_c = object.name) !== null && _c !== void 0 ? _c : "";
        message.muted = (_d = object.muted) !== null && _d !== void 0 ? _d : false;
        message.width = (_e = object.width) !== null && _e !== void 0 ? _e : 0;
        message.height = (_f = object.height) !== null && _f !== void 0 ? _f : 0;
        message.simulcast = (_g = object.simulcast) !== null && _g !== void 0 ? _g : false;
        message.disableDtx = (_h = object.disableDtx) !== null && _h !== void 0 ? _h : false;
        message.source = (_j = object.source) !== null && _j !== void 0 ? _j : 0;
        message.layers = [];
        if (object.layers !== undefined && object.layers !== null) {
            for (const e of object.layers) {
                message.layers.push(exports.VideoLayer.fromPartial(e));
            }
        }
        message.mimeType = (_k = object.mimeType) !== null && _k !== void 0 ? _k : "";
        message.mid = (_l = object.mid) !== null && _l !== void 0 ? _l : "";
        return message;
    },
};
const baseVideoLayer = {
    quality: 0,
    width: 0,
    height: 0,
    bitrate: 0,
    ssrc: 0,
};
exports.VideoLayer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.quality !== 0) {
            writer.uint32(8).int32(message.quality);
        }
        if (message.width !== 0) {
            writer.uint32(16).uint32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(24).uint32(message.height);
        }
        if (message.bitrate !== 0) {
            writer.uint32(32).uint32(message.bitrate);
        }
        if (message.ssrc !== 0) {
            writer.uint32(40).uint32(message.ssrc);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseVideoLayer);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.quality = reader.int32();
                    break;
                case 2:
                    message.width = reader.uint32();
                    break;
                case 3:
                    message.height = reader.uint32();
                    break;
                case 4:
                    message.bitrate = reader.uint32();
                    break;
                case 5:
                    message.ssrc = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseVideoLayer);
        if (object.quality !== undefined && object.quality !== null) {
            message.quality = videoQualityFromJSON(object.quality);
        }
        else {
            message.quality = 0;
        }
        if (object.width !== undefined && object.width !== null) {
            message.width = Number(object.width);
        }
        else {
            message.width = 0;
        }
        if (object.height !== undefined && object.height !== null) {
            message.height = Number(object.height);
        }
        else {
            message.height = 0;
        }
        if (object.bitrate !== undefined && object.bitrate !== null) {
            message.bitrate = Number(object.bitrate);
        }
        else {
            message.bitrate = 0;
        }
        if (object.ssrc !== undefined && object.ssrc !== null) {
            message.ssrc = Number(object.ssrc);
        }
        else {
            message.ssrc = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.quality !== undefined &&
            (obj.quality = videoQualityToJSON(message.quality));
        message.width !== undefined && (obj.width = message.width);
        message.height !== undefined && (obj.height = message.height);
        message.bitrate !== undefined && (obj.bitrate = message.bitrate);
        message.ssrc !== undefined && (obj.ssrc = message.ssrc);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = Object.assign({}, baseVideoLayer);
        message.quality = (_a = object.quality) !== null && _a !== void 0 ? _a : 0;
        message.width = (_b = object.width) !== null && _b !== void 0 ? _b : 0;
        message.height = (_c = object.height) !== null && _c !== void 0 ? _c : 0;
        message.bitrate = (_d = object.bitrate) !== null && _d !== void 0 ? _d : 0;
        message.ssrc = (_e = object.ssrc) !== null && _e !== void 0 ? _e : 0;
        return message;
    },
};
const baseDataPacket = { kind: 0 };
exports.DataPacket = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.kind !== 0) {
            writer.uint32(8).int32(message.kind);
        }
        if (message.user !== undefined) {
            exports.UserPacket.encode(message.user, writer.uint32(18).fork()).ldelim();
        }
        if (message.speaker !== undefined) {
            exports.ActiveSpeakerUpdate.encode(message.speaker, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDataPacket);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.int32();
                    break;
                case 2:
                    message.user = exports.UserPacket.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.speaker = exports.ActiveSpeakerUpdate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseDataPacket);
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = dataPacket_KindFromJSON(object.kind);
        }
        else {
            message.kind = 0;
        }
        if (object.user !== undefined && object.user !== null) {
            message.user = exports.UserPacket.fromJSON(object.user);
        }
        else {
            message.user = undefined;
        }
        if (object.speaker !== undefined && object.speaker !== null) {
            message.speaker = exports.ActiveSpeakerUpdate.fromJSON(object.speaker);
        }
        else {
            message.speaker = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined &&
            (obj.kind = dataPacket_KindToJSON(message.kind));
        message.user !== undefined &&
            (obj.user = message.user ? exports.UserPacket.toJSON(message.user) : undefined);
        message.speaker !== undefined &&
            (obj.speaker = message.speaker
                ? exports.ActiveSpeakerUpdate.toJSON(message.speaker)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseDataPacket);
        message.kind = (_a = object.kind) !== null && _a !== void 0 ? _a : 0;
        if (object.user !== undefined && object.user !== null) {
            message.user = exports.UserPacket.fromPartial(object.user);
        }
        else {
            message.user = undefined;
        }
        if (object.speaker !== undefined && object.speaker !== null) {
            message.speaker = exports.ActiveSpeakerUpdate.fromPartial(object.speaker);
        }
        else {
            message.speaker = undefined;
        }
        return message;
    },
};
const baseActiveSpeakerUpdate = {};
exports.ActiveSpeakerUpdate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.speakers) {
            exports.SpeakerInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseActiveSpeakerUpdate);
        message.speakers = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.speakers.push(exports.SpeakerInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseActiveSpeakerUpdate);
        message.speakers = [];
        if (object.speakers !== undefined && object.speakers !== null) {
            for (const e of object.speakers) {
                message.speakers.push(exports.SpeakerInfo.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.speakers) {
            obj.speakers = message.speakers.map((e) => e ? exports.SpeakerInfo.toJSON(e) : undefined);
        }
        else {
            obj.speakers = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseActiveSpeakerUpdate);
        message.speakers = [];
        if (object.speakers !== undefined && object.speakers !== null) {
            for (const e of object.speakers) {
                message.speakers.push(exports.SpeakerInfo.fromPartial(e));
            }
        }
        return message;
    },
};
const baseSpeakerInfo = { sid: "", level: 0, active: false };
exports.SpeakerInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sid !== "") {
            writer.uint32(10).string(message.sid);
        }
        if (message.level !== 0) {
            writer.uint32(21).float(message.level);
        }
        if (message.active === true) {
            writer.uint32(24).bool(message.active);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpeakerInfo);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sid = reader.string();
                    break;
                case 2:
                    message.level = reader.float();
                    break;
                case 3:
                    message.active = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSpeakerInfo);
        if (object.sid !== undefined && object.sid !== null) {
            message.sid = String(object.sid);
        }
        else {
            message.sid = "";
        }
        if (object.level !== undefined && object.level !== null) {
            message.level = Number(object.level);
        }
        else {
            message.level = 0;
        }
        if (object.active !== undefined && object.active !== null) {
            message.active = Boolean(object.active);
        }
        else {
            message.active = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.sid !== undefined && (obj.sid = message.sid);
        message.level !== undefined && (obj.level = message.level);
        message.active !== undefined && (obj.active = message.active);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseSpeakerInfo);
        message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : "";
        message.level = (_b = object.level) !== null && _b !== void 0 ? _b : 0;
        message.active = (_c = object.active) !== null && _c !== void 0 ? _c : false;
        return message;
    },
};
const baseUserPacket = { participantSid: "", destinationSids: "" };
exports.UserPacket = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.participantSid !== "") {
            writer.uint32(10).string(message.participantSid);
        }
        if (message.payload.length !== 0) {
            writer.uint32(18).bytes(message.payload);
        }
        for (const v of message.destinationSids) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUserPacket);
        message.destinationSids = [];
        message.payload = new Uint8Array();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.participantSid = reader.string();
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                case 3:
                    message.destinationSids.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseUserPacket);
        message.destinationSids = [];
        message.payload = new Uint8Array();
        if (object.participantSid !== undefined && object.participantSid !== null) {
            message.participantSid = String(object.participantSid);
        }
        else {
            message.participantSid = "";
        }
        if (object.payload !== undefined && object.payload !== null) {
            message.payload = bytesFromBase64(object.payload);
        }
        if (object.destinationSids !== undefined &&
            object.destinationSids !== null) {
            for (const e of object.destinationSids) {
                message.destinationSids.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.participantSid !== undefined &&
            (obj.participantSid = message.participantSid);
        message.payload !== undefined &&
            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        if (message.destinationSids) {
            obj.destinationSids = message.destinationSids.map((e) => e);
        }
        else {
            obj.destinationSids = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseUserPacket);
        message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : "";
        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.destinationSids = [];
        if (object.destinationSids !== undefined &&
            object.destinationSids !== null) {
            for (const e of object.destinationSids) {
                message.destinationSids.push(e);
            }
        }
        return message;
    },
};
const baseParticipantTracks = { participantSid: "", trackSids: "" };
exports.ParticipantTracks = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.participantSid !== "") {
            writer.uint32(10).string(message.participantSid);
        }
        for (const v of message.trackSids) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParticipantTracks);
        message.trackSids = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.participantSid = reader.string();
                    break;
                case 2:
                    message.trackSids.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseParticipantTracks);
        message.trackSids = [];
        if (object.participantSid !== undefined && object.participantSid !== null) {
            message.participantSid = String(object.participantSid);
        }
        else {
            message.participantSid = "";
        }
        if (object.trackSids !== undefined && object.trackSids !== null) {
            for (const e of object.trackSids) {
                message.trackSids.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.participantSid !== undefined &&
            (obj.participantSid = message.participantSid);
        if (message.trackSids) {
            obj.trackSids = message.trackSids.map((e) => e);
        }
        else {
            obj.trackSids = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseParticipantTracks);
        message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : "";
        message.trackSids = [];
        if (object.trackSids !== undefined && object.trackSids !== null) {
            for (const e of object.trackSids) {
                message.trackSids.push(e);
            }
        }
        return message;
    },
};
const baseClientInfo = {
    sdk: 0,
    version: "",
    protocol: 0,
    os: "",
    osVersion: "",
    deviceModel: "",
    browser: "",
    browserVersion: "",
};
exports.ClientInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sdk !== 0) {
            writer.uint32(8).int32(message.sdk);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        if (message.protocol !== 0) {
            writer.uint32(24).int32(message.protocol);
        }
        if (message.os !== "") {
            writer.uint32(34).string(message.os);
        }
        if (message.osVersion !== "") {
            writer.uint32(42).string(message.osVersion);
        }
        if (message.deviceModel !== "") {
            writer.uint32(50).string(message.deviceModel);
        }
        if (message.browser !== "") {
            writer.uint32(58).string(message.browser);
        }
        if (message.browserVersion !== "") {
            writer.uint32(66).string(message.browserVersion);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseClientInfo);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sdk = reader.int32();
                    break;
                case 2:
                    message.version = reader.string();
                    break;
                case 3:
                    message.protocol = reader.int32();
                    break;
                case 4:
                    message.os = reader.string();
                    break;
                case 5:
                    message.osVersion = reader.string();
                    break;
                case 6:
                    message.deviceModel = reader.string();
                    break;
                case 7:
                    message.browser = reader.string();
                    break;
                case 8:
                    message.browserVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseClientInfo);
        if (object.sdk !== undefined && object.sdk !== null) {
            message.sdk = clientInfo_SDKFromJSON(object.sdk);
        }
        else {
            message.sdk = 0;
        }
        if (object.version !== undefined && object.version !== null) {
            message.version = String(object.version);
        }
        else {
            message.version = "";
        }
        if (object.protocol !== undefined && object.protocol !== null) {
            message.protocol = Number(object.protocol);
        }
        else {
            message.protocol = 0;
        }
        if (object.os !== undefined && object.os !== null) {
            message.os = String(object.os);
        }
        else {
            message.os = "";
        }
        if (object.osVersion !== undefined && object.osVersion !== null) {
            message.osVersion = String(object.osVersion);
        }
        else {
            message.osVersion = "";
        }
        if (object.deviceModel !== undefined && object.deviceModel !== null) {
            message.deviceModel = String(object.deviceModel);
        }
        else {
            message.deviceModel = "";
        }
        if (object.browser !== undefined && object.browser !== null) {
            message.browser = String(object.browser);
        }
        else {
            message.browser = "";
        }
        if (object.browserVersion !== undefined && object.browserVersion !== null) {
            message.browserVersion = String(object.browserVersion);
        }
        else {
            message.browserVersion = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.sdk !== undefined && (obj.sdk = clientInfo_SDKToJSON(message.sdk));
        message.version !== undefined && (obj.version = message.version);
        message.protocol !== undefined && (obj.protocol = message.protocol);
        message.os !== undefined && (obj.os = message.os);
        message.osVersion !== undefined && (obj.osVersion = message.osVersion);
        message.deviceModel !== undefined &&
            (obj.deviceModel = message.deviceModel);
        message.browser !== undefined && (obj.browser = message.browser);
        message.browserVersion !== undefined &&
            (obj.browserVersion = message.browserVersion);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = Object.assign({}, baseClientInfo);
        message.sdk = (_a = object.sdk) !== null && _a !== void 0 ? _a : 0;
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : "";
        message.protocol = (_c = object.protocol) !== null && _c !== void 0 ? _c : 0;
        message.os = (_d = object.os) !== null && _d !== void 0 ? _d : "";
        message.osVersion = (_e = object.osVersion) !== null && _e !== void 0 ? _e : "";
        message.deviceModel = (_f = object.deviceModel) !== null && _f !== void 0 ? _f : "";
        message.browser = (_g = object.browser) !== null && _g !== void 0 ? _g : "";
        message.browserVersion = (_h = object.browserVersion) !== null && _h !== void 0 ? _h : "";
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof __webpack_require__.g !== "undefined")
        return __webpack_require__.g;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=livekit_models.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/proto/livekit_rtc.js":
/*!***************************************************************!*\
  !*** ./node_modules/livekit-client/dist/proto/livekit_rtc.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimulateScenario = exports.SyncState = exports.SubscriptionPermissionUpdate = exports.SubscriptionPermission = exports.TrackPermission = exports.SubscribedQualityUpdate = exports.SubscribedQuality = exports.StreamStateUpdate = exports.StreamStateInfo = exports.ConnectionQualityUpdate = exports.ConnectionQualityInfo = exports.RoomUpdate = exports.SpeakersChanged = exports.ICEServer = exports.UpdateVideoLayers = exports.LeaveRequest = exports.UpdateTrackSettings = exports.UpdateSubscription = exports.ParticipantUpdate = exports.SessionDescription = exports.TrackPublishedResponse = exports.JoinResponse = exports.MuteTrackRequest = exports.TrickleRequest = exports.AddTrackRequest = exports.SignalResponse = exports.SignalRequest = exports.streamStateToJSON = exports.streamStateFromJSON = exports.StreamState = exports.signalTargetToJSON = exports.signalTargetFromJSON = exports.SignalTarget = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
const livekit_models_1 = __webpack_require__(/*! ./livekit_models */ "./node_modules/livekit-client/dist/proto/livekit_models.js");
exports.protobufPackage = "livekit";
var SignalTarget;
(function (SignalTarget) {
    SignalTarget[SignalTarget["PUBLISHER"] = 0] = "PUBLISHER";
    SignalTarget[SignalTarget["SUBSCRIBER"] = 1] = "SUBSCRIBER";
    SignalTarget[SignalTarget["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SignalTarget = exports.SignalTarget || (exports.SignalTarget = {}));
function signalTargetFromJSON(object) {
    switch (object) {
        case 0:
        case "PUBLISHER":
            return SignalTarget.PUBLISHER;
        case 1:
        case "SUBSCRIBER":
            return SignalTarget.SUBSCRIBER;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SignalTarget.UNRECOGNIZED;
    }
}
exports.signalTargetFromJSON = signalTargetFromJSON;
function signalTargetToJSON(object) {
    switch (object) {
        case SignalTarget.PUBLISHER:
            return "PUBLISHER";
        case SignalTarget.SUBSCRIBER:
            return "SUBSCRIBER";
        default:
            return "UNKNOWN";
    }
}
exports.signalTargetToJSON = signalTargetToJSON;
var StreamState;
(function (StreamState) {
    StreamState[StreamState["ACTIVE"] = 0] = "ACTIVE";
    StreamState[StreamState["PAUSED"] = 1] = "PAUSED";
    StreamState[StreamState["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(StreamState = exports.StreamState || (exports.StreamState = {}));
function streamStateFromJSON(object) {
    switch (object) {
        case 0:
        case "ACTIVE":
            return StreamState.ACTIVE;
        case 1:
        case "PAUSED":
            return StreamState.PAUSED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return StreamState.UNRECOGNIZED;
    }
}
exports.streamStateFromJSON = streamStateFromJSON;
function streamStateToJSON(object) {
    switch (object) {
        case StreamState.ACTIVE:
            return "ACTIVE";
        case StreamState.PAUSED:
            return "PAUSED";
        default:
            return "UNKNOWN";
    }
}
exports.streamStateToJSON = streamStateToJSON;
const baseSignalRequest = {};
exports.SignalRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.offer !== undefined) {
            exports.SessionDescription.encode(message.offer, writer.uint32(10).fork()).ldelim();
        }
        if (message.answer !== undefined) {
            exports.SessionDescription.encode(message.answer, writer.uint32(18).fork()).ldelim();
        }
        if (message.trickle !== undefined) {
            exports.TrickleRequest.encode(message.trickle, writer.uint32(26).fork()).ldelim();
        }
        if (message.addTrack !== undefined) {
            exports.AddTrackRequest.encode(message.addTrack, writer.uint32(34).fork()).ldelim();
        }
        if (message.mute !== undefined) {
            exports.MuteTrackRequest.encode(message.mute, writer.uint32(42).fork()).ldelim();
        }
        if (message.subscription !== undefined) {
            exports.UpdateSubscription.encode(message.subscription, writer.uint32(50).fork()).ldelim();
        }
        if (message.trackSetting !== undefined) {
            exports.UpdateTrackSettings.encode(message.trackSetting, writer.uint32(58).fork()).ldelim();
        }
        if (message.leave !== undefined) {
            exports.LeaveRequest.encode(message.leave, writer.uint32(66).fork()).ldelim();
        }
        if (message.updateLayers !== undefined) {
            exports.UpdateVideoLayers.encode(message.updateLayers, writer.uint32(82).fork()).ldelim();
        }
        if (message.subscriptionPermission !== undefined) {
            exports.SubscriptionPermission.encode(message.subscriptionPermission, writer.uint32(90).fork()).ldelim();
        }
        if (message.syncState !== undefined) {
            exports.SyncState.encode(message.syncState, writer.uint32(98).fork()).ldelim();
        }
        if (message.simulate !== undefined) {
            exports.SimulateScenario.encode(message.simulate, writer.uint32(106).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSignalRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.offer = exports.SessionDescription.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.answer = exports.SessionDescription.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.trickle = exports.TrickleRequest.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.addTrack = exports.AddTrackRequest.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.mute = exports.MuteTrackRequest.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.subscription = exports.UpdateSubscription.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.trackSetting = exports.UpdateTrackSettings.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.leave = exports.LeaveRequest.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.updateLayers = exports.UpdateVideoLayers.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.subscriptionPermission = exports.SubscriptionPermission.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.syncState = exports.SyncState.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.simulate = exports.SimulateScenario.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSignalRequest);
        if (object.offer !== undefined && object.offer !== null) {
            message.offer = exports.SessionDescription.fromJSON(object.offer);
        }
        else {
            message.offer = undefined;
        }
        if (object.answer !== undefined && object.answer !== null) {
            message.answer = exports.SessionDescription.fromJSON(object.answer);
        }
        else {
            message.answer = undefined;
        }
        if (object.trickle !== undefined && object.trickle !== null) {
            message.trickle = exports.TrickleRequest.fromJSON(object.trickle);
        }
        else {
            message.trickle = undefined;
        }
        if (object.addTrack !== undefined && object.addTrack !== null) {
            message.addTrack = exports.AddTrackRequest.fromJSON(object.addTrack);
        }
        else {
            message.addTrack = undefined;
        }
        if (object.mute !== undefined && object.mute !== null) {
            message.mute = exports.MuteTrackRequest.fromJSON(object.mute);
        }
        else {
            message.mute = undefined;
        }
        if (object.subscription !== undefined && object.subscription !== null) {
            message.subscription = exports.UpdateSubscription.fromJSON(object.subscription);
        }
        else {
            message.subscription = undefined;
        }
        if (object.trackSetting !== undefined && object.trackSetting !== null) {
            message.trackSetting = exports.UpdateTrackSettings.fromJSON(object.trackSetting);
        }
        else {
            message.trackSetting = undefined;
        }
        if (object.leave !== undefined && object.leave !== null) {
            message.leave = exports.LeaveRequest.fromJSON(object.leave);
        }
        else {
            message.leave = undefined;
        }
        if (object.updateLayers !== undefined && object.updateLayers !== null) {
            message.updateLayers = exports.UpdateVideoLayers.fromJSON(object.updateLayers);
        }
        else {
            message.updateLayers = undefined;
        }
        if (object.subscriptionPermission !== undefined &&
            object.subscriptionPermission !== null) {
            message.subscriptionPermission = exports.SubscriptionPermission.fromJSON(object.subscriptionPermission);
        }
        else {
            message.subscriptionPermission = undefined;
        }
        if (object.syncState !== undefined && object.syncState !== null) {
            message.syncState = exports.SyncState.fromJSON(object.syncState);
        }
        else {
            message.syncState = undefined;
        }
        if (object.simulate !== undefined && object.simulate !== null) {
            message.simulate = exports.SimulateScenario.fromJSON(object.simulate);
        }
        else {
            message.simulate = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.offer !== undefined &&
            (obj.offer = message.offer
                ? exports.SessionDescription.toJSON(message.offer)
                : undefined);
        message.answer !== undefined &&
            (obj.answer = message.answer
                ? exports.SessionDescription.toJSON(message.answer)
                : undefined);
        message.trickle !== undefined &&
            (obj.trickle = message.trickle
                ? exports.TrickleRequest.toJSON(message.trickle)
                : undefined);
        message.addTrack !== undefined &&
            (obj.addTrack = message.addTrack
                ? exports.AddTrackRequest.toJSON(message.addTrack)
                : undefined);
        message.mute !== undefined &&
            (obj.mute = message.mute
                ? exports.MuteTrackRequest.toJSON(message.mute)
                : undefined);
        message.subscription !== undefined &&
            (obj.subscription = message.subscription
                ? exports.UpdateSubscription.toJSON(message.subscription)
                : undefined);
        message.trackSetting !== undefined &&
            (obj.trackSetting = message.trackSetting
                ? exports.UpdateTrackSettings.toJSON(message.trackSetting)
                : undefined);
        message.leave !== undefined &&
            (obj.leave = message.leave
                ? exports.LeaveRequest.toJSON(message.leave)
                : undefined);
        message.updateLayers !== undefined &&
            (obj.updateLayers = message.updateLayers
                ? exports.UpdateVideoLayers.toJSON(message.updateLayers)
                : undefined);
        message.subscriptionPermission !== undefined &&
            (obj.subscriptionPermission = message.subscriptionPermission
                ? exports.SubscriptionPermission.toJSON(message.subscriptionPermission)
                : undefined);
        message.syncState !== undefined &&
            (obj.syncState = message.syncState
                ? exports.SyncState.toJSON(message.syncState)
                : undefined);
        message.simulate !== undefined &&
            (obj.simulate = message.simulate
                ? exports.SimulateScenario.toJSON(message.simulate)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseSignalRequest);
        if (object.offer !== undefined && object.offer !== null) {
            message.offer = exports.SessionDescription.fromPartial(object.offer);
        }
        else {
            message.offer = undefined;
        }
        if (object.answer !== undefined && object.answer !== null) {
            message.answer = exports.SessionDescription.fromPartial(object.answer);
        }
        else {
            message.answer = undefined;
        }
        if (object.trickle !== undefined && object.trickle !== null) {
            message.trickle = exports.TrickleRequest.fromPartial(object.trickle);
        }
        else {
            message.trickle = undefined;
        }
        if (object.addTrack !== undefined && object.addTrack !== null) {
            message.addTrack = exports.AddTrackRequest.fromPartial(object.addTrack);
        }
        else {
            message.addTrack = undefined;
        }
        if (object.mute !== undefined && object.mute !== null) {
            message.mute = exports.MuteTrackRequest.fromPartial(object.mute);
        }
        else {
            message.mute = undefined;
        }
        if (object.subscription !== undefined && object.subscription !== null) {
            message.subscription = exports.UpdateSubscription.fromPartial(object.subscription);
        }
        else {
            message.subscription = undefined;
        }
        if (object.trackSetting !== undefined && object.trackSetting !== null) {
            message.trackSetting = exports.UpdateTrackSettings.fromPartial(object.trackSetting);
        }
        else {
            message.trackSetting = undefined;
        }
        if (object.leave !== undefined && object.leave !== null) {
            message.leave = exports.LeaveRequest.fromPartial(object.leave);
        }
        else {
            message.leave = undefined;
        }
        if (object.updateLayers !== undefined && object.updateLayers !== null) {
            message.updateLayers = exports.UpdateVideoLayers.fromPartial(object.updateLayers);
        }
        else {
            message.updateLayers = undefined;
        }
        if (object.subscriptionPermission !== undefined &&
            object.subscriptionPermission !== null) {
            message.subscriptionPermission = exports.SubscriptionPermission.fromPartial(object.subscriptionPermission);
        }
        else {
            message.subscriptionPermission = undefined;
        }
        if (object.syncState !== undefined && object.syncState !== null) {
            message.syncState = exports.SyncState.fromPartial(object.syncState);
        }
        else {
            message.syncState = undefined;
        }
        if (object.simulate !== undefined && object.simulate !== null) {
            message.simulate = exports.SimulateScenario.fromPartial(object.simulate);
        }
        else {
            message.simulate = undefined;
        }
        return message;
    },
};
const baseSignalResponse = {};
exports.SignalResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.join !== undefined) {
            exports.JoinResponse.encode(message.join, writer.uint32(10).fork()).ldelim();
        }
        if (message.answer !== undefined) {
            exports.SessionDescription.encode(message.answer, writer.uint32(18).fork()).ldelim();
        }
        if (message.offer !== undefined) {
            exports.SessionDescription.encode(message.offer, writer.uint32(26).fork()).ldelim();
        }
        if (message.trickle !== undefined) {
            exports.TrickleRequest.encode(message.trickle, writer.uint32(34).fork()).ldelim();
        }
        if (message.update !== undefined) {
            exports.ParticipantUpdate.encode(message.update, writer.uint32(42).fork()).ldelim();
        }
        if (message.trackPublished !== undefined) {
            exports.TrackPublishedResponse.encode(message.trackPublished, writer.uint32(50).fork()).ldelim();
        }
        if (message.leave !== undefined) {
            exports.LeaveRequest.encode(message.leave, writer.uint32(66).fork()).ldelim();
        }
        if (message.mute !== undefined) {
            exports.MuteTrackRequest.encode(message.mute, writer.uint32(74).fork()).ldelim();
        }
        if (message.speakersChanged !== undefined) {
            exports.SpeakersChanged.encode(message.speakersChanged, writer.uint32(82).fork()).ldelim();
        }
        if (message.roomUpdate !== undefined) {
            exports.RoomUpdate.encode(message.roomUpdate, writer.uint32(90).fork()).ldelim();
        }
        if (message.connectionQuality !== undefined) {
            exports.ConnectionQualityUpdate.encode(message.connectionQuality, writer.uint32(98).fork()).ldelim();
        }
        if (message.streamStateUpdate !== undefined) {
            exports.StreamStateUpdate.encode(message.streamStateUpdate, writer.uint32(106).fork()).ldelim();
        }
        if (message.subscribedQualityUpdate !== undefined) {
            exports.SubscribedQualityUpdate.encode(message.subscribedQualityUpdate, writer.uint32(114).fork()).ldelim();
        }
        if (message.subscriptionPermissionUpdate !== undefined) {
            exports.SubscriptionPermissionUpdate.encode(message.subscriptionPermissionUpdate, writer.uint32(122).fork()).ldelim();
        }
        if (message.refreshToken !== undefined) {
            writer.uint32(130).string(message.refreshToken);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSignalResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.join = exports.JoinResponse.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.answer = exports.SessionDescription.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.offer = exports.SessionDescription.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.trickle = exports.TrickleRequest.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.update = exports.ParticipantUpdate.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.trackPublished = exports.TrackPublishedResponse.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.leave = exports.LeaveRequest.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.mute = exports.MuteTrackRequest.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.speakersChanged = exports.SpeakersChanged.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.roomUpdate = exports.RoomUpdate.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.connectionQuality = exports.ConnectionQualityUpdate.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.streamStateUpdate = exports.StreamStateUpdate.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.subscribedQualityUpdate = exports.SubscribedQualityUpdate.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.subscriptionPermissionUpdate =
                        exports.SubscriptionPermissionUpdate.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.refreshToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSignalResponse);
        if (object.join !== undefined && object.join !== null) {
            message.join = exports.JoinResponse.fromJSON(object.join);
        }
        else {
            message.join = undefined;
        }
        if (object.answer !== undefined && object.answer !== null) {
            message.answer = exports.SessionDescription.fromJSON(object.answer);
        }
        else {
            message.answer = undefined;
        }
        if (object.offer !== undefined && object.offer !== null) {
            message.offer = exports.SessionDescription.fromJSON(object.offer);
        }
        else {
            message.offer = undefined;
        }
        if (object.trickle !== undefined && object.trickle !== null) {
            message.trickle = exports.TrickleRequest.fromJSON(object.trickle);
        }
        else {
            message.trickle = undefined;
        }
        if (object.update !== undefined && object.update !== null) {
            message.update = exports.ParticipantUpdate.fromJSON(object.update);
        }
        else {
            message.update = undefined;
        }
        if (object.trackPublished !== undefined && object.trackPublished !== null) {
            message.trackPublished = exports.TrackPublishedResponse.fromJSON(object.trackPublished);
        }
        else {
            message.trackPublished = undefined;
        }
        if (object.leave !== undefined && object.leave !== null) {
            message.leave = exports.LeaveRequest.fromJSON(object.leave);
        }
        else {
            message.leave = undefined;
        }
        if (object.mute !== undefined && object.mute !== null) {
            message.mute = exports.MuteTrackRequest.fromJSON(object.mute);
        }
        else {
            message.mute = undefined;
        }
        if (object.speakersChanged !== undefined &&
            object.speakersChanged !== null) {
            message.speakersChanged = exports.SpeakersChanged.fromJSON(object.speakersChanged);
        }
        else {
            message.speakersChanged = undefined;
        }
        if (object.roomUpdate !== undefined && object.roomUpdate !== null) {
            message.roomUpdate = exports.RoomUpdate.fromJSON(object.roomUpdate);
        }
        else {
            message.roomUpdate = undefined;
        }
        if (object.connectionQuality !== undefined &&
            object.connectionQuality !== null) {
            message.connectionQuality = exports.ConnectionQualityUpdate.fromJSON(object.connectionQuality);
        }
        else {
            message.connectionQuality = undefined;
        }
        if (object.streamStateUpdate !== undefined &&
            object.streamStateUpdate !== null) {
            message.streamStateUpdate = exports.StreamStateUpdate.fromJSON(object.streamStateUpdate);
        }
        else {
            message.streamStateUpdate = undefined;
        }
        if (object.subscribedQualityUpdate !== undefined &&
            object.subscribedQualityUpdate !== null) {
            message.subscribedQualityUpdate = exports.SubscribedQualityUpdate.fromJSON(object.subscribedQualityUpdate);
        }
        else {
            message.subscribedQualityUpdate = undefined;
        }
        if (object.subscriptionPermissionUpdate !== undefined &&
            object.subscriptionPermissionUpdate !== null) {
            message.subscriptionPermissionUpdate =
                exports.SubscriptionPermissionUpdate.fromJSON(object.subscriptionPermissionUpdate);
        }
        else {
            message.subscriptionPermissionUpdate = undefined;
        }
        if (object.refreshToken !== undefined && object.refreshToken !== null) {
            message.refreshToken = String(object.refreshToken);
        }
        else {
            message.refreshToken = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.join !== undefined &&
            (obj.join = message.join ? exports.JoinResponse.toJSON(message.join) : undefined);
        message.answer !== undefined &&
            (obj.answer = message.answer
                ? exports.SessionDescription.toJSON(message.answer)
                : undefined);
        message.offer !== undefined &&
            (obj.offer = message.offer
                ? exports.SessionDescription.toJSON(message.offer)
                : undefined);
        message.trickle !== undefined &&
            (obj.trickle = message.trickle
                ? exports.TrickleRequest.toJSON(message.trickle)
                : undefined);
        message.update !== undefined &&
            (obj.update = message.update
                ? exports.ParticipantUpdate.toJSON(message.update)
                : undefined);
        message.trackPublished !== undefined &&
            (obj.trackPublished = message.trackPublished
                ? exports.TrackPublishedResponse.toJSON(message.trackPublished)
                : undefined);
        message.leave !== undefined &&
            (obj.leave = message.leave
                ? exports.LeaveRequest.toJSON(message.leave)
                : undefined);
        message.mute !== undefined &&
            (obj.mute = message.mute
                ? exports.MuteTrackRequest.toJSON(message.mute)
                : undefined);
        message.speakersChanged !== undefined &&
            (obj.speakersChanged = message.speakersChanged
                ? exports.SpeakersChanged.toJSON(message.speakersChanged)
                : undefined);
        message.roomUpdate !== undefined &&
            (obj.roomUpdate = message.roomUpdate
                ? exports.RoomUpdate.toJSON(message.roomUpdate)
                : undefined);
        message.connectionQuality !== undefined &&
            (obj.connectionQuality = message.connectionQuality
                ? exports.ConnectionQualityUpdate.toJSON(message.connectionQuality)
                : undefined);
        message.streamStateUpdate !== undefined &&
            (obj.streamStateUpdate = message.streamStateUpdate
                ? exports.StreamStateUpdate.toJSON(message.streamStateUpdate)
                : undefined);
        message.subscribedQualityUpdate !== undefined &&
            (obj.subscribedQualityUpdate = message.subscribedQualityUpdate
                ? exports.SubscribedQualityUpdate.toJSON(message.subscribedQualityUpdate)
                : undefined);
        message.subscriptionPermissionUpdate !== undefined &&
            (obj.subscriptionPermissionUpdate = message.subscriptionPermissionUpdate
                ? exports.SubscriptionPermissionUpdate.toJSON(message.subscriptionPermissionUpdate)
                : undefined);
        message.refreshToken !== undefined &&
            (obj.refreshToken = message.refreshToken);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseSignalResponse);
        if (object.join !== undefined && object.join !== null) {
            message.join = exports.JoinResponse.fromPartial(object.join);
        }
        else {
            message.join = undefined;
        }
        if (object.answer !== undefined && object.answer !== null) {
            message.answer = exports.SessionDescription.fromPartial(object.answer);
        }
        else {
            message.answer = undefined;
        }
        if (object.offer !== undefined && object.offer !== null) {
            message.offer = exports.SessionDescription.fromPartial(object.offer);
        }
        else {
            message.offer = undefined;
        }
        if (object.trickle !== undefined && object.trickle !== null) {
            message.trickle = exports.TrickleRequest.fromPartial(object.trickle);
        }
        else {
            message.trickle = undefined;
        }
        if (object.update !== undefined && object.update !== null) {
            message.update = exports.ParticipantUpdate.fromPartial(object.update);
        }
        else {
            message.update = undefined;
        }
        if (object.trackPublished !== undefined && object.trackPublished !== null) {
            message.trackPublished = exports.TrackPublishedResponse.fromPartial(object.trackPublished);
        }
        else {
            message.trackPublished = undefined;
        }
        if (object.leave !== undefined && object.leave !== null) {
            message.leave = exports.LeaveRequest.fromPartial(object.leave);
        }
        else {
            message.leave = undefined;
        }
        if (object.mute !== undefined && object.mute !== null) {
            message.mute = exports.MuteTrackRequest.fromPartial(object.mute);
        }
        else {
            message.mute = undefined;
        }
        if (object.speakersChanged !== undefined &&
            object.speakersChanged !== null) {
            message.speakersChanged = exports.SpeakersChanged.fromPartial(object.speakersChanged);
        }
        else {
            message.speakersChanged = undefined;
        }
        if (object.roomUpdate !== undefined && object.roomUpdate !== null) {
            message.roomUpdate = exports.RoomUpdate.fromPartial(object.roomUpdate);
        }
        else {
            message.roomUpdate = undefined;
        }
        if (object.connectionQuality !== undefined &&
            object.connectionQuality !== null) {
            message.connectionQuality = exports.ConnectionQualityUpdate.fromPartial(object.connectionQuality);
        }
        else {
            message.connectionQuality = undefined;
        }
        if (object.streamStateUpdate !== undefined &&
            object.streamStateUpdate !== null) {
            message.streamStateUpdate = exports.StreamStateUpdate.fromPartial(object.streamStateUpdate);
        }
        else {
            message.streamStateUpdate = undefined;
        }
        if (object.subscribedQualityUpdate !== undefined &&
            object.subscribedQualityUpdate !== null) {
            message.subscribedQualityUpdate = exports.SubscribedQualityUpdate.fromPartial(object.subscribedQualityUpdate);
        }
        else {
            message.subscribedQualityUpdate = undefined;
        }
        if (object.subscriptionPermissionUpdate !== undefined &&
            object.subscriptionPermissionUpdate !== null) {
            message.subscriptionPermissionUpdate =
                exports.SubscriptionPermissionUpdate.fromPartial(object.subscriptionPermissionUpdate);
        }
        else {
            message.subscriptionPermissionUpdate = undefined;
        }
        message.refreshToken = (_a = object.refreshToken) !== null && _a !== void 0 ? _a : undefined;
        return message;
    },
};
const baseAddTrackRequest = {
    cid: "",
    name: "",
    type: 0,
    width: 0,
    height: 0,
    muted: false,
    disableDtx: false,
    source: 0,
};
exports.AddTrackRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.cid !== "") {
            writer.uint32(10).string(message.cid);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.type !== 0) {
            writer.uint32(24).int32(message.type);
        }
        if (message.width !== 0) {
            writer.uint32(32).uint32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(40).uint32(message.height);
        }
        if (message.muted === true) {
            writer.uint32(48).bool(message.muted);
        }
        if (message.disableDtx === true) {
            writer.uint32(56).bool(message.disableDtx);
        }
        if (message.source !== 0) {
            writer.uint32(64).int32(message.source);
        }
        for (const v of message.layers) {
            livekit_models_1.VideoLayer.encode(v, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseAddTrackRequest);
        message.layers = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cid = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.width = reader.uint32();
                    break;
                case 5:
                    message.height = reader.uint32();
                    break;
                case 6:
                    message.muted = reader.bool();
                    break;
                case 7:
                    message.disableDtx = reader.bool();
                    break;
                case 8:
                    message.source = reader.int32();
                    break;
                case 9:
                    message.layers.push(livekit_models_1.VideoLayer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseAddTrackRequest);
        message.layers = [];
        if (object.cid !== undefined && object.cid !== null) {
            message.cid = String(object.cid);
        }
        else {
            message.cid = "";
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        if (object.type !== undefined && object.type !== null) {
            message.type = livekit_models_1.trackTypeFromJSON(object.type);
        }
        else {
            message.type = 0;
        }
        if (object.width !== undefined && object.width !== null) {
            message.width = Number(object.width);
        }
        else {
            message.width = 0;
        }
        if (object.height !== undefined && object.height !== null) {
            message.height = Number(object.height);
        }
        else {
            message.height = 0;
        }
        if (object.muted !== undefined && object.muted !== null) {
            message.muted = Boolean(object.muted);
        }
        else {
            message.muted = false;
        }
        if (object.disableDtx !== undefined && object.disableDtx !== null) {
            message.disableDtx = Boolean(object.disableDtx);
        }
        else {
            message.disableDtx = false;
        }
        if (object.source !== undefined && object.source !== null) {
            message.source = livekit_models_1.trackSourceFromJSON(object.source);
        }
        else {
            message.source = 0;
        }
        if (object.layers !== undefined && object.layers !== null) {
            for (const e of object.layers) {
                message.layers.push(livekit_models_1.VideoLayer.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.cid !== undefined && (obj.cid = message.cid);
        message.name !== undefined && (obj.name = message.name);
        message.type !== undefined && (obj.type = livekit_models_1.trackTypeToJSON(message.type));
        message.width !== undefined && (obj.width = message.width);
        message.height !== undefined && (obj.height = message.height);
        message.muted !== undefined && (obj.muted = message.muted);
        message.disableDtx !== undefined && (obj.disableDtx = message.disableDtx);
        message.source !== undefined &&
            (obj.source = livekit_models_1.trackSourceToJSON(message.source));
        if (message.layers) {
            obj.layers = message.layers.map((e) => e ? livekit_models_1.VideoLayer.toJSON(e) : undefined);
        }
        else {
            obj.layers = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = Object.assign({}, baseAddTrackRequest);
        message.cid = (_a = object.cid) !== null && _a !== void 0 ? _a : "";
        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
        message.type = (_c = object.type) !== null && _c !== void 0 ? _c : 0;
        message.width = (_d = object.width) !== null && _d !== void 0 ? _d : 0;
        message.height = (_e = object.height) !== null && _e !== void 0 ? _e : 0;
        message.muted = (_f = object.muted) !== null && _f !== void 0 ? _f : false;
        message.disableDtx = (_g = object.disableDtx) !== null && _g !== void 0 ? _g : false;
        message.source = (_h = object.source) !== null && _h !== void 0 ? _h : 0;
        message.layers = [];
        if (object.layers !== undefined && object.layers !== null) {
            for (const e of object.layers) {
                message.layers.push(livekit_models_1.VideoLayer.fromPartial(e));
            }
        }
        return message;
    },
};
const baseTrickleRequest = { candidateInit: "", target: 0 };
exports.TrickleRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.candidateInit !== "") {
            writer.uint32(10).string(message.candidateInit);
        }
        if (message.target !== 0) {
            writer.uint32(16).int32(message.target);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTrickleRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.candidateInit = reader.string();
                    break;
                case 2:
                    message.target = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseTrickleRequest);
        if (object.candidateInit !== undefined && object.candidateInit !== null) {
            message.candidateInit = String(object.candidateInit);
        }
        else {
            message.candidateInit = "";
        }
        if (object.target !== undefined && object.target !== null) {
            message.target = signalTargetFromJSON(object.target);
        }
        else {
            message.target = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.candidateInit !== undefined &&
            (obj.candidateInit = message.candidateInit);
        message.target !== undefined &&
            (obj.target = signalTargetToJSON(message.target));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseTrickleRequest);
        message.candidateInit = (_a = object.candidateInit) !== null && _a !== void 0 ? _a : "";
        message.target = (_b = object.target) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
const baseMuteTrackRequest = { sid: "", muted: false };
exports.MuteTrackRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sid !== "") {
            writer.uint32(10).string(message.sid);
        }
        if (message.muted === true) {
            writer.uint32(16).bool(message.muted);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMuteTrackRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sid = reader.string();
                    break;
                case 2:
                    message.muted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMuteTrackRequest);
        if (object.sid !== undefined && object.sid !== null) {
            message.sid = String(object.sid);
        }
        else {
            message.sid = "";
        }
        if (object.muted !== undefined && object.muted !== null) {
            message.muted = Boolean(object.muted);
        }
        else {
            message.muted = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.sid !== undefined && (obj.sid = message.sid);
        message.muted !== undefined && (obj.muted = message.muted);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMuteTrackRequest);
        message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : "";
        message.muted = (_b = object.muted) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
const baseJoinResponse = {
    serverVersion: "",
    subscriberPrimary: false,
    alternativeUrl: "",
};
exports.JoinResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== undefined) {
            livekit_models_1.Room.encode(message.room, writer.uint32(10).fork()).ldelim();
        }
        if (message.participant !== undefined) {
            livekit_models_1.ParticipantInfo.encode(message.participant, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.otherParticipants) {
            livekit_models_1.ParticipantInfo.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.serverVersion !== "") {
            writer.uint32(34).string(message.serverVersion);
        }
        for (const v of message.iceServers) {
            exports.ICEServer.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (message.subscriberPrimary === true) {
            writer.uint32(48).bool(message.subscriberPrimary);
        }
        if (message.alternativeUrl !== "") {
            writer.uint32(58).string(message.alternativeUrl);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseJoinResponse);
        message.otherParticipants = [];
        message.iceServers = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = livekit_models_1.Room.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.participant = livekit_models_1.ParticipantInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.otherParticipants.push(livekit_models_1.ParticipantInfo.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.serverVersion = reader.string();
                    break;
                case 5:
                    message.iceServers.push(exports.ICEServer.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.subscriberPrimary = reader.bool();
                    break;
                case 7:
                    message.alternativeUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseJoinResponse);
        message.otherParticipants = [];
        message.iceServers = [];
        if (object.room !== undefined && object.room !== null) {
            message.room = livekit_models_1.Room.fromJSON(object.room);
        }
        else {
            message.room = undefined;
        }
        if (object.participant !== undefined && object.participant !== null) {
            message.participant = livekit_models_1.ParticipantInfo.fromJSON(object.participant);
        }
        else {
            message.participant = undefined;
        }
        if (object.otherParticipants !== undefined &&
            object.otherParticipants !== null) {
            for (const e of object.otherParticipants) {
                message.otherParticipants.push(livekit_models_1.ParticipantInfo.fromJSON(e));
            }
        }
        if (object.serverVersion !== undefined && object.serverVersion !== null) {
            message.serverVersion = String(object.serverVersion);
        }
        else {
            message.serverVersion = "";
        }
        if (object.iceServers !== undefined && object.iceServers !== null) {
            for (const e of object.iceServers) {
                message.iceServers.push(exports.ICEServer.fromJSON(e));
            }
        }
        if (object.subscriberPrimary !== undefined &&
            object.subscriberPrimary !== null) {
            message.subscriberPrimary = Boolean(object.subscriberPrimary);
        }
        else {
            message.subscriberPrimary = false;
        }
        if (object.alternativeUrl !== undefined && object.alternativeUrl !== null) {
            message.alternativeUrl = String(object.alternativeUrl);
        }
        else {
            message.alternativeUrl = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined &&
            (obj.room = message.room ? livekit_models_1.Room.toJSON(message.room) : undefined);
        message.participant !== undefined &&
            (obj.participant = message.participant
                ? livekit_models_1.ParticipantInfo.toJSON(message.participant)
                : undefined);
        if (message.otherParticipants) {
            obj.otherParticipants = message.otherParticipants.map((e) => e ? livekit_models_1.ParticipantInfo.toJSON(e) : undefined);
        }
        else {
            obj.otherParticipants = [];
        }
        message.serverVersion !== undefined &&
            (obj.serverVersion = message.serverVersion);
        if (message.iceServers) {
            obj.iceServers = message.iceServers.map((e) => e ? exports.ICEServer.toJSON(e) : undefined);
        }
        else {
            obj.iceServers = [];
        }
        message.subscriberPrimary !== undefined &&
            (obj.subscriberPrimary = message.subscriberPrimary);
        message.alternativeUrl !== undefined &&
            (obj.alternativeUrl = message.alternativeUrl);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseJoinResponse);
        if (object.room !== undefined && object.room !== null) {
            message.room = livekit_models_1.Room.fromPartial(object.room);
        }
        else {
            message.room = undefined;
        }
        if (object.participant !== undefined && object.participant !== null) {
            message.participant = livekit_models_1.ParticipantInfo.fromPartial(object.participant);
        }
        else {
            message.participant = undefined;
        }
        message.otherParticipants = [];
        if (object.otherParticipants !== undefined &&
            object.otherParticipants !== null) {
            for (const e of object.otherParticipants) {
                message.otherParticipants.push(livekit_models_1.ParticipantInfo.fromPartial(e));
            }
        }
        message.serverVersion = (_a = object.serverVersion) !== null && _a !== void 0 ? _a : "";
        message.iceServers = [];
        if (object.iceServers !== undefined && object.iceServers !== null) {
            for (const e of object.iceServers) {
                message.iceServers.push(exports.ICEServer.fromPartial(e));
            }
        }
        message.subscriberPrimary = (_b = object.subscriberPrimary) !== null && _b !== void 0 ? _b : false;
        message.alternativeUrl = (_c = object.alternativeUrl) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
const baseTrackPublishedResponse = { cid: "" };
exports.TrackPublishedResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.cid !== "") {
            writer.uint32(10).string(message.cid);
        }
        if (message.track !== undefined) {
            livekit_models_1.TrackInfo.encode(message.track, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTrackPublishedResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cid = reader.string();
                    break;
                case 2:
                    message.track = livekit_models_1.TrackInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseTrackPublishedResponse);
        if (object.cid !== undefined && object.cid !== null) {
            message.cid = String(object.cid);
        }
        else {
            message.cid = "";
        }
        if (object.track !== undefined && object.track !== null) {
            message.track = livekit_models_1.TrackInfo.fromJSON(object.track);
        }
        else {
            message.track = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.cid !== undefined && (obj.cid = message.cid);
        message.track !== undefined &&
            (obj.track = message.track ? livekit_models_1.TrackInfo.toJSON(message.track) : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseTrackPublishedResponse);
        message.cid = (_a = object.cid) !== null && _a !== void 0 ? _a : "";
        if (object.track !== undefined && object.track !== null) {
            message.track = livekit_models_1.TrackInfo.fromPartial(object.track);
        }
        else {
            message.track = undefined;
        }
        return message;
    },
};
const baseSessionDescription = { type: "", sdp: "" };
exports.SessionDescription = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== "") {
            writer.uint32(10).string(message.type);
        }
        if (message.sdp !== "") {
            writer.uint32(18).string(message.sdp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSessionDescription);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.sdp = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSessionDescription);
        if (object.type !== undefined && object.type !== null) {
            message.type = String(object.type);
        }
        else {
            message.type = "";
        }
        if (object.sdp !== undefined && object.sdp !== null) {
            message.sdp = String(object.sdp);
        }
        else {
            message.sdp = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.type !== undefined && (obj.type = message.type);
        message.sdp !== undefined && (obj.sdp = message.sdp);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseSessionDescription);
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : "";
        message.sdp = (_b = object.sdp) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
const baseParticipantUpdate = {};
exports.ParticipantUpdate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.participants) {
            livekit_models_1.ParticipantInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParticipantUpdate);
        message.participants = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.participants.push(livekit_models_1.ParticipantInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseParticipantUpdate);
        message.participants = [];
        if (object.participants !== undefined && object.participants !== null) {
            for (const e of object.participants) {
                message.participants.push(livekit_models_1.ParticipantInfo.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.participants) {
            obj.participants = message.participants.map((e) => e ? livekit_models_1.ParticipantInfo.toJSON(e) : undefined);
        }
        else {
            obj.participants = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseParticipantUpdate);
        message.participants = [];
        if (object.participants !== undefined && object.participants !== null) {
            for (const e of object.participants) {
                message.participants.push(livekit_models_1.ParticipantInfo.fromPartial(e));
            }
        }
        return message;
    },
};
const baseUpdateSubscription = { trackSids: "", subscribe: false };
exports.UpdateSubscription = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.trackSids) {
            writer.uint32(10).string(v);
        }
        if (message.subscribe === true) {
            writer.uint32(16).bool(message.subscribe);
        }
        for (const v of message.participantTracks) {
            livekit_models_1.ParticipantTracks.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUpdateSubscription);
        message.trackSids = [];
        message.participantTracks = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.trackSids.push(reader.string());
                    break;
                case 2:
                    message.subscribe = reader.bool();
                    break;
                case 3:
                    message.participantTracks.push(livekit_models_1.ParticipantTracks.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseUpdateSubscription);
        message.trackSids = [];
        message.participantTracks = [];
        if (object.trackSids !== undefined && object.trackSids !== null) {
            for (const e of object.trackSids) {
                message.trackSids.push(String(e));
            }
        }
        if (object.subscribe !== undefined && object.subscribe !== null) {
            message.subscribe = Boolean(object.subscribe);
        }
        else {
            message.subscribe = false;
        }
        if (object.participantTracks !== undefined &&
            object.participantTracks !== null) {
            for (const e of object.participantTracks) {
                message.participantTracks.push(livekit_models_1.ParticipantTracks.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.trackSids) {
            obj.trackSids = message.trackSids.map((e) => e);
        }
        else {
            obj.trackSids = [];
        }
        message.subscribe !== undefined && (obj.subscribe = message.subscribe);
        if (message.participantTracks) {
            obj.participantTracks = message.participantTracks.map((e) => e ? livekit_models_1.ParticipantTracks.toJSON(e) : undefined);
        }
        else {
            obj.participantTracks = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseUpdateSubscription);
        message.trackSids = [];
        if (object.trackSids !== undefined && object.trackSids !== null) {
            for (const e of object.trackSids) {
                message.trackSids.push(e);
            }
        }
        message.subscribe = (_a = object.subscribe) !== null && _a !== void 0 ? _a : false;
        message.participantTracks = [];
        if (object.participantTracks !== undefined &&
            object.participantTracks !== null) {
            for (const e of object.participantTracks) {
                message.participantTracks.push(livekit_models_1.ParticipantTracks.fromPartial(e));
            }
        }
        return message;
    },
};
const baseUpdateTrackSettings = {
    trackSids: "",
    disabled: false,
    quality: 0,
    width: 0,
    height: 0,
};
exports.UpdateTrackSettings = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.trackSids) {
            writer.uint32(10).string(v);
        }
        if (message.disabled === true) {
            writer.uint32(24).bool(message.disabled);
        }
        if (message.quality !== 0) {
            writer.uint32(32).int32(message.quality);
        }
        if (message.width !== 0) {
            writer.uint32(40).uint32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(48).uint32(message.height);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUpdateTrackSettings);
        message.trackSids = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.trackSids.push(reader.string());
                    break;
                case 3:
                    message.disabled = reader.bool();
                    break;
                case 4:
                    message.quality = reader.int32();
                    break;
                case 5:
                    message.width = reader.uint32();
                    break;
                case 6:
                    message.height = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseUpdateTrackSettings);
        message.trackSids = [];
        if (object.trackSids !== undefined && object.trackSids !== null) {
            for (const e of object.trackSids) {
                message.trackSids.push(String(e));
            }
        }
        if (object.disabled !== undefined && object.disabled !== null) {
            message.disabled = Boolean(object.disabled);
        }
        else {
            message.disabled = false;
        }
        if (object.quality !== undefined && object.quality !== null) {
            message.quality = livekit_models_1.videoQualityFromJSON(object.quality);
        }
        else {
            message.quality = 0;
        }
        if (object.width !== undefined && object.width !== null) {
            message.width = Number(object.width);
        }
        else {
            message.width = 0;
        }
        if (object.height !== undefined && object.height !== null) {
            message.height = Number(object.height);
        }
        else {
            message.height = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.trackSids) {
            obj.trackSids = message.trackSids.map((e) => e);
        }
        else {
            obj.trackSids = [];
        }
        message.disabled !== undefined && (obj.disabled = message.disabled);
        message.quality !== undefined &&
            (obj.quality = livekit_models_1.videoQualityToJSON(message.quality));
        message.width !== undefined && (obj.width = message.width);
        message.height !== undefined && (obj.height = message.height);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseUpdateTrackSettings);
        message.trackSids = [];
        if (object.trackSids !== undefined && object.trackSids !== null) {
            for (const e of object.trackSids) {
                message.trackSids.push(e);
            }
        }
        message.disabled = (_a = object.disabled) !== null && _a !== void 0 ? _a : false;
        message.quality = (_b = object.quality) !== null && _b !== void 0 ? _b : 0;
        message.width = (_c = object.width) !== null && _c !== void 0 ? _c : 0;
        message.height = (_d = object.height) !== null && _d !== void 0 ? _d : 0;
        return message;
    },
};
const baseLeaveRequest = { canReconnect: false };
exports.LeaveRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.canReconnect === true) {
            writer.uint32(8).bool(message.canReconnect);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseLeaveRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.canReconnect = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseLeaveRequest);
        if (object.canReconnect !== undefined && object.canReconnect !== null) {
            message.canReconnect = Boolean(object.canReconnect);
        }
        else {
            message.canReconnect = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.canReconnect !== undefined &&
            (obj.canReconnect = message.canReconnect);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseLeaveRequest);
        message.canReconnect = (_a = object.canReconnect) !== null && _a !== void 0 ? _a : false;
        return message;
    },
};
const baseUpdateVideoLayers = { trackSid: "" };
exports.UpdateVideoLayers = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.trackSid !== "") {
            writer.uint32(10).string(message.trackSid);
        }
        for (const v of message.layers) {
            livekit_models_1.VideoLayer.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUpdateVideoLayers);
        message.layers = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.trackSid = reader.string();
                    break;
                case 2:
                    message.layers.push(livekit_models_1.VideoLayer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseUpdateVideoLayers);
        message.layers = [];
        if (object.trackSid !== undefined && object.trackSid !== null) {
            message.trackSid = String(object.trackSid);
        }
        else {
            message.trackSid = "";
        }
        if (object.layers !== undefined && object.layers !== null) {
            for (const e of object.layers) {
                message.layers.push(livekit_models_1.VideoLayer.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.trackSid !== undefined && (obj.trackSid = message.trackSid);
        if (message.layers) {
            obj.layers = message.layers.map((e) => e ? livekit_models_1.VideoLayer.toJSON(e) : undefined);
        }
        else {
            obj.layers = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseUpdateVideoLayers);
        message.trackSid = (_a = object.trackSid) !== null && _a !== void 0 ? _a : "";
        message.layers = [];
        if (object.layers !== undefined && object.layers !== null) {
            for (const e of object.layers) {
                message.layers.push(livekit_models_1.VideoLayer.fromPartial(e));
            }
        }
        return message;
    },
};
const baseICEServer = { urls: "", username: "", credential: "" };
exports.ICEServer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.urls) {
            writer.uint32(10).string(v);
        }
        if (message.username !== "") {
            writer.uint32(18).string(message.username);
        }
        if (message.credential !== "") {
            writer.uint32(26).string(message.credential);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseICEServer);
        message.urls = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.urls.push(reader.string());
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.credential = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseICEServer);
        message.urls = [];
        if (object.urls !== undefined && object.urls !== null) {
            for (const e of object.urls) {
                message.urls.push(String(e));
            }
        }
        if (object.username !== undefined && object.username !== null) {
            message.username = String(object.username);
        }
        else {
            message.username = "";
        }
        if (object.credential !== undefined && object.credential !== null) {
            message.credential = String(object.credential);
        }
        else {
            message.credential = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.urls) {
            obj.urls = message.urls.map((e) => e);
        }
        else {
            obj.urls = [];
        }
        message.username !== undefined && (obj.username = message.username);
        message.credential !== undefined && (obj.credential = message.credential);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseICEServer);
        message.urls = [];
        if (object.urls !== undefined && object.urls !== null) {
            for (const e of object.urls) {
                message.urls.push(e);
            }
        }
        message.username = (_a = object.username) !== null && _a !== void 0 ? _a : "";
        message.credential = (_b = object.credential) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
const baseSpeakersChanged = {};
exports.SpeakersChanged = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.speakers) {
            livekit_models_1.SpeakerInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpeakersChanged);
        message.speakers = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.speakers.push(livekit_models_1.SpeakerInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSpeakersChanged);
        message.speakers = [];
        if (object.speakers !== undefined && object.speakers !== null) {
            for (const e of object.speakers) {
                message.speakers.push(livekit_models_1.SpeakerInfo.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.speakers) {
            obj.speakers = message.speakers.map((e) => e ? livekit_models_1.SpeakerInfo.toJSON(e) : undefined);
        }
        else {
            obj.speakers = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseSpeakersChanged);
        message.speakers = [];
        if (object.speakers !== undefined && object.speakers !== null) {
            for (const e of object.speakers) {
                message.speakers.push(livekit_models_1.SpeakerInfo.fromPartial(e));
            }
        }
        return message;
    },
};
const baseRoomUpdate = {};
exports.RoomUpdate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== undefined) {
            livekit_models_1.Room.encode(message.room, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRoomUpdate);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = livekit_models_1.Room.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseRoomUpdate);
        if (object.room !== undefined && object.room !== null) {
            message.room = livekit_models_1.Room.fromJSON(object.room);
        }
        else {
            message.room = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined &&
            (obj.room = message.room ? livekit_models_1.Room.toJSON(message.room) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseRoomUpdate);
        if (object.room !== undefined && object.room !== null) {
            message.room = livekit_models_1.Room.fromPartial(object.room);
        }
        else {
            message.room = undefined;
        }
        return message;
    },
};
const baseConnectionQualityInfo = {
    participantSid: "",
    quality: 0,
    score: 0,
};
exports.ConnectionQualityInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.participantSid !== "") {
            writer.uint32(10).string(message.participantSid);
        }
        if (message.quality !== 0) {
            writer.uint32(16).int32(message.quality);
        }
        if (message.score !== 0) {
            writer.uint32(29).float(message.score);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseConnectionQualityInfo);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.participantSid = reader.string();
                    break;
                case 2:
                    message.quality = reader.int32();
                    break;
                case 3:
                    message.score = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseConnectionQualityInfo);
        if (object.participantSid !== undefined && object.participantSid !== null) {
            message.participantSid = String(object.participantSid);
        }
        else {
            message.participantSid = "";
        }
        if (object.quality !== undefined && object.quality !== null) {
            message.quality = livekit_models_1.connectionQualityFromJSON(object.quality);
        }
        else {
            message.quality = 0;
        }
        if (object.score !== undefined && object.score !== null) {
            message.score = Number(object.score);
        }
        else {
            message.score = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.participantSid !== undefined &&
            (obj.participantSid = message.participantSid);
        message.quality !== undefined &&
            (obj.quality = livekit_models_1.connectionQualityToJSON(message.quality));
        message.score !== undefined && (obj.score = message.score);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseConnectionQualityInfo);
        message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : "";
        message.quality = (_b = object.quality) !== null && _b !== void 0 ? _b : 0;
        message.score = (_c = object.score) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
const baseConnectionQualityUpdate = {};
exports.ConnectionQualityUpdate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.updates) {
            exports.ConnectionQualityInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseConnectionQualityUpdate);
        message.updates = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.updates.push(exports.ConnectionQualityInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseConnectionQualityUpdate);
        message.updates = [];
        if (object.updates !== undefined && object.updates !== null) {
            for (const e of object.updates) {
                message.updates.push(exports.ConnectionQualityInfo.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.updates) {
            obj.updates = message.updates.map((e) => e ? exports.ConnectionQualityInfo.toJSON(e) : undefined);
        }
        else {
            obj.updates = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseConnectionQualityUpdate);
        message.updates = [];
        if (object.updates !== undefined && object.updates !== null) {
            for (const e of object.updates) {
                message.updates.push(exports.ConnectionQualityInfo.fromPartial(e));
            }
        }
        return message;
    },
};
const baseStreamStateInfo = {
    participantSid: "",
    trackSid: "",
    state: 0,
};
exports.StreamStateInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.participantSid !== "") {
            writer.uint32(10).string(message.participantSid);
        }
        if (message.trackSid !== "") {
            writer.uint32(18).string(message.trackSid);
        }
        if (message.state !== 0) {
            writer.uint32(24).int32(message.state);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseStreamStateInfo);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.participantSid = reader.string();
                    break;
                case 2:
                    message.trackSid = reader.string();
                    break;
                case 3:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseStreamStateInfo);
        if (object.participantSid !== undefined && object.participantSid !== null) {
            message.participantSid = String(object.participantSid);
        }
        else {
            message.participantSid = "";
        }
        if (object.trackSid !== undefined && object.trackSid !== null) {
            message.trackSid = String(object.trackSid);
        }
        else {
            message.trackSid = "";
        }
        if (object.state !== undefined && object.state !== null) {
            message.state = streamStateFromJSON(object.state);
        }
        else {
            message.state = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.participantSid !== undefined &&
            (obj.participantSid = message.participantSid);
        message.trackSid !== undefined && (obj.trackSid = message.trackSid);
        message.state !== undefined &&
            (obj.state = streamStateToJSON(message.state));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseStreamStateInfo);
        message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : "";
        message.trackSid = (_b = object.trackSid) !== null && _b !== void 0 ? _b : "";
        message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
const baseStreamStateUpdate = {};
exports.StreamStateUpdate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.streamStates) {
            exports.StreamStateInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseStreamStateUpdate);
        message.streamStates = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.streamStates.push(exports.StreamStateInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseStreamStateUpdate);
        message.streamStates = [];
        if (object.streamStates !== undefined && object.streamStates !== null) {
            for (const e of object.streamStates) {
                message.streamStates.push(exports.StreamStateInfo.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.streamStates) {
            obj.streamStates = message.streamStates.map((e) => e ? exports.StreamStateInfo.toJSON(e) : undefined);
        }
        else {
            obj.streamStates = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseStreamStateUpdate);
        message.streamStates = [];
        if (object.streamStates !== undefined && object.streamStates !== null) {
            for (const e of object.streamStates) {
                message.streamStates.push(exports.StreamStateInfo.fromPartial(e));
            }
        }
        return message;
    },
};
const baseSubscribedQuality = { quality: 0, enabled: false };
exports.SubscribedQuality = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.quality !== 0) {
            writer.uint32(8).int32(message.quality);
        }
        if (message.enabled === true) {
            writer.uint32(16).bool(message.enabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSubscribedQuality);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.quality = reader.int32();
                    break;
                case 2:
                    message.enabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSubscribedQuality);
        if (object.quality !== undefined && object.quality !== null) {
            message.quality = livekit_models_1.videoQualityFromJSON(object.quality);
        }
        else {
            message.quality = 0;
        }
        if (object.enabled !== undefined && object.enabled !== null) {
            message.enabled = Boolean(object.enabled);
        }
        else {
            message.enabled = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.quality !== undefined &&
            (obj.quality = livekit_models_1.videoQualityToJSON(message.quality));
        message.enabled !== undefined && (obj.enabled = message.enabled);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseSubscribedQuality);
        message.quality = (_a = object.quality) !== null && _a !== void 0 ? _a : 0;
        message.enabled = (_b = object.enabled) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
const baseSubscribedQualityUpdate = { trackSid: "" };
exports.SubscribedQualityUpdate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.trackSid !== "") {
            writer.uint32(10).string(message.trackSid);
        }
        for (const v of message.subscribedQualities) {
            exports.SubscribedQuality.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSubscribedQualityUpdate);
        message.subscribedQualities = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.trackSid = reader.string();
                    break;
                case 2:
                    message.subscribedQualities.push(exports.SubscribedQuality.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSubscribedQualityUpdate);
        message.subscribedQualities = [];
        if (object.trackSid !== undefined && object.trackSid !== null) {
            message.trackSid = String(object.trackSid);
        }
        else {
            message.trackSid = "";
        }
        if (object.subscribedQualities !== undefined &&
            object.subscribedQualities !== null) {
            for (const e of object.subscribedQualities) {
                message.subscribedQualities.push(exports.SubscribedQuality.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.trackSid !== undefined && (obj.trackSid = message.trackSid);
        if (message.subscribedQualities) {
            obj.subscribedQualities = message.subscribedQualities.map((e) => e ? exports.SubscribedQuality.toJSON(e) : undefined);
        }
        else {
            obj.subscribedQualities = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseSubscribedQualityUpdate);
        message.trackSid = (_a = object.trackSid) !== null && _a !== void 0 ? _a : "";
        message.subscribedQualities = [];
        if (object.subscribedQualities !== undefined &&
            object.subscribedQualities !== null) {
            for (const e of object.subscribedQualities) {
                message.subscribedQualities.push(exports.SubscribedQuality.fromPartial(e));
            }
        }
        return message;
    },
};
const baseTrackPermission = {
    participantSid: "",
    allTracks: false,
    trackSids: "",
};
exports.TrackPermission = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.participantSid !== "") {
            writer.uint32(10).string(message.participantSid);
        }
        if (message.allTracks === true) {
            writer.uint32(16).bool(message.allTracks);
        }
        for (const v of message.trackSids) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTrackPermission);
        message.trackSids = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.participantSid = reader.string();
                    break;
                case 2:
                    message.allTracks = reader.bool();
                    break;
                case 3:
                    message.trackSids.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseTrackPermission);
        message.trackSids = [];
        if (object.participantSid !== undefined && object.participantSid !== null) {
            message.participantSid = String(object.participantSid);
        }
        else {
            message.participantSid = "";
        }
        if (object.allTracks !== undefined && object.allTracks !== null) {
            message.allTracks = Boolean(object.allTracks);
        }
        else {
            message.allTracks = false;
        }
        if (object.trackSids !== undefined && object.trackSids !== null) {
            for (const e of object.trackSids) {
                message.trackSids.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.participantSid !== undefined &&
            (obj.participantSid = message.participantSid);
        message.allTracks !== undefined && (obj.allTracks = message.allTracks);
        if (message.trackSids) {
            obj.trackSids = message.trackSids.map((e) => e);
        }
        else {
            obj.trackSids = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseTrackPermission);
        message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : "";
        message.allTracks = (_b = object.allTracks) !== null && _b !== void 0 ? _b : false;
        message.trackSids = [];
        if (object.trackSids !== undefined && object.trackSids !== null) {
            for (const e of object.trackSids) {
                message.trackSids.push(e);
            }
        }
        return message;
    },
};
const baseSubscriptionPermission = { allParticipants: false };
exports.SubscriptionPermission = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.allParticipants === true) {
            writer.uint32(8).bool(message.allParticipants);
        }
        for (const v of message.trackPermissions) {
            exports.TrackPermission.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSubscriptionPermission);
        message.trackPermissions = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.allParticipants = reader.bool();
                    break;
                case 2:
                    message.trackPermissions.push(exports.TrackPermission.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSubscriptionPermission);
        message.trackPermissions = [];
        if (object.allParticipants !== undefined &&
            object.allParticipants !== null) {
            message.allParticipants = Boolean(object.allParticipants);
        }
        else {
            message.allParticipants = false;
        }
        if (object.trackPermissions !== undefined &&
            object.trackPermissions !== null) {
            for (const e of object.trackPermissions) {
                message.trackPermissions.push(exports.TrackPermission.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.allParticipants !== undefined &&
            (obj.allParticipants = message.allParticipants);
        if (message.trackPermissions) {
            obj.trackPermissions = message.trackPermissions.map((e) => e ? exports.TrackPermission.toJSON(e) : undefined);
        }
        else {
            obj.trackPermissions = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseSubscriptionPermission);
        message.allParticipants = (_a = object.allParticipants) !== null && _a !== void 0 ? _a : false;
        message.trackPermissions = [];
        if (object.trackPermissions !== undefined &&
            object.trackPermissions !== null) {
            for (const e of object.trackPermissions) {
                message.trackPermissions.push(exports.TrackPermission.fromPartial(e));
            }
        }
        return message;
    },
};
const baseSubscriptionPermissionUpdate = {
    participantSid: "",
    trackSid: "",
    allowed: false,
};
exports.SubscriptionPermissionUpdate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.participantSid !== "") {
            writer.uint32(10).string(message.participantSid);
        }
        if (message.trackSid !== "") {
            writer.uint32(18).string(message.trackSid);
        }
        if (message.allowed === true) {
            writer.uint32(24).bool(message.allowed);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSubscriptionPermissionUpdate);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.participantSid = reader.string();
                    break;
                case 2:
                    message.trackSid = reader.string();
                    break;
                case 3:
                    message.allowed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSubscriptionPermissionUpdate);
        if (object.participantSid !== undefined && object.participantSid !== null) {
            message.participantSid = String(object.participantSid);
        }
        else {
            message.participantSid = "";
        }
        if (object.trackSid !== undefined && object.trackSid !== null) {
            message.trackSid = String(object.trackSid);
        }
        else {
            message.trackSid = "";
        }
        if (object.allowed !== undefined && object.allowed !== null) {
            message.allowed = Boolean(object.allowed);
        }
        else {
            message.allowed = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.participantSid !== undefined &&
            (obj.participantSid = message.participantSid);
        message.trackSid !== undefined && (obj.trackSid = message.trackSid);
        message.allowed !== undefined && (obj.allowed = message.allowed);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseSubscriptionPermissionUpdate);
        message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : "";
        message.trackSid = (_b = object.trackSid) !== null && _b !== void 0 ? _b : "";
        message.allowed = (_c = object.allowed) !== null && _c !== void 0 ? _c : false;
        return message;
    },
};
const baseSyncState = {};
exports.SyncState = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.answer !== undefined) {
            exports.SessionDescription.encode(message.answer, writer.uint32(10).fork()).ldelim();
        }
        if (message.subscription !== undefined) {
            exports.UpdateSubscription.encode(message.subscription, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.publishTracks) {
            exports.TrackPublishedResponse.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSyncState);
        message.publishTracks = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.answer = exports.SessionDescription.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.subscription = exports.UpdateSubscription.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.publishTracks.push(exports.TrackPublishedResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSyncState);
        message.publishTracks = [];
        if (object.answer !== undefined && object.answer !== null) {
            message.answer = exports.SessionDescription.fromJSON(object.answer);
        }
        else {
            message.answer = undefined;
        }
        if (object.subscription !== undefined && object.subscription !== null) {
            message.subscription = exports.UpdateSubscription.fromJSON(object.subscription);
        }
        else {
            message.subscription = undefined;
        }
        if (object.publishTracks !== undefined && object.publishTracks !== null) {
            for (const e of object.publishTracks) {
                message.publishTracks.push(exports.TrackPublishedResponse.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.answer !== undefined &&
            (obj.answer = message.answer
                ? exports.SessionDescription.toJSON(message.answer)
                : undefined);
        message.subscription !== undefined &&
            (obj.subscription = message.subscription
                ? exports.UpdateSubscription.toJSON(message.subscription)
                : undefined);
        if (message.publishTracks) {
            obj.publishTracks = message.publishTracks.map((e) => e ? exports.TrackPublishedResponse.toJSON(e) : undefined);
        }
        else {
            obj.publishTracks = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseSyncState);
        if (object.answer !== undefined && object.answer !== null) {
            message.answer = exports.SessionDescription.fromPartial(object.answer);
        }
        else {
            message.answer = undefined;
        }
        if (object.subscription !== undefined && object.subscription !== null) {
            message.subscription = exports.UpdateSubscription.fromPartial(object.subscription);
        }
        else {
            message.subscription = undefined;
        }
        message.publishTracks = [];
        if (object.publishTracks !== undefined && object.publishTracks !== null) {
            for (const e of object.publishTracks) {
                message.publishTracks.push(exports.TrackPublishedResponse.fromPartial(e));
            }
        }
        return message;
    },
};
const baseSimulateScenario = {};
exports.SimulateScenario = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.speakerUpdate !== undefined) {
            writer.uint32(8).int32(message.speakerUpdate);
        }
        if (message.nodeFailure !== undefined) {
            writer.uint32(16).bool(message.nodeFailure);
        }
        if (message.migration !== undefined) {
            writer.uint32(24).bool(message.migration);
        }
        if (message.serverLeave !== undefined) {
            writer.uint32(32).bool(message.serverLeave);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSimulateScenario);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.speakerUpdate = reader.int32();
                    break;
                case 2:
                    message.nodeFailure = reader.bool();
                    break;
                case 3:
                    message.migration = reader.bool();
                    break;
                case 4:
                    message.serverLeave = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSimulateScenario);
        if (object.speakerUpdate !== undefined && object.speakerUpdate !== null) {
            message.speakerUpdate = Number(object.speakerUpdate);
        }
        else {
            message.speakerUpdate = undefined;
        }
        if (object.nodeFailure !== undefined && object.nodeFailure !== null) {
            message.nodeFailure = Boolean(object.nodeFailure);
        }
        else {
            message.nodeFailure = undefined;
        }
        if (object.migration !== undefined && object.migration !== null) {
            message.migration = Boolean(object.migration);
        }
        else {
            message.migration = undefined;
        }
        if (object.serverLeave !== undefined && object.serverLeave !== null) {
            message.serverLeave = Boolean(object.serverLeave);
        }
        else {
            message.serverLeave = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.speakerUpdate !== undefined &&
            (obj.speakerUpdate = message.speakerUpdate);
        message.nodeFailure !== undefined &&
            (obj.nodeFailure = message.nodeFailure);
        message.migration !== undefined && (obj.migration = message.migration);
        message.serverLeave !== undefined &&
            (obj.serverLeave = message.serverLeave);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseSimulateScenario);
        message.speakerUpdate = (_a = object.speakerUpdate) !== null && _a !== void 0 ? _a : undefined;
        message.nodeFailure = (_b = object.nodeFailure) !== null && _b !== void 0 ? _b : undefined;
        message.migration = (_c = object.migration) !== null && _c !== void 0 ? _c : undefined;
        message.serverLeave = (_d = object.serverLeave) !== null && _d !== void 0 ? _d : undefined;
        return message;
    },
};
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=livekit_rtc.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/DeviceManager.js":
/*!****************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/DeviceManager.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const defaultId = 'default';
class DeviceManager {
    static getInstance() {
        if (this.instance === undefined) {
            this.instance = new DeviceManager();
        }
        return this.instance;
    }
    getDevices(kind) {
        return __awaiter(this, void 0, void 0, function* () {
            let devices = yield navigator.mediaDevices.enumerateDevices();
            devices = devices.filter((device) => device.kind === kind);
            // Chrome returns 'default' devices, we would filter them out, but put the default
            // device at first
            // we would only do this if there are more than 1 device though
            if (devices.length > 1 && devices[0].deviceId === defaultId) {
                // find another device with matching group id, and move that to 0
                const defaultDevice = devices[0];
                for (let i = 1; i < devices.length; i += 1) {
                    if (devices[i].groupId === defaultDevice.groupId) {
                        const temp = devices[0];
                        devices[0] = devices[i];
                        devices[i] = temp;
                        break;
                    }
                }
                return devices.filter((device) => device !== defaultDevice);
            }
            return devices;
        });
    }
    normalizeDeviceId(kind, deviceId, groupId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (deviceId !== defaultId) {
                return deviceId;
            }
            // resolve actual device id if it's 'default': Chrome returns it when no
            // device has been chosen
            const devices = yield this.getDevices(kind);
            const device = devices.find((d) => d.groupId === groupId && d.deviceId !== defaultId);
            return device === null || device === void 0 ? void 0 : device.deviceId;
        });
    }
}
exports["default"] = DeviceManager;
DeviceManager.mediaDeviceKinds = [
    'audioinput',
    'audiooutput',
    'videoinput',
];
//# sourceMappingURL=DeviceManager.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/PCTransport.js":
/*!**************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/PCTransport.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ts_debounce_1 = __webpack_require__(/*! ts-debounce */ "./node_modules/ts-debounce/dist/src/index.esm.js");
const logger_1 = __importDefault(__webpack_require__(/*! ../logger */ "./node_modules/livekit-client/dist/logger.js"));
/** @internal */
class PCTransport {
    constructor(config) {
        this.pendingCandidates = [];
        this.restartingIce = false;
        this.renegotiate = false;
        // debounced negotiate interface
        this.negotiate = ts_debounce_1.debounce(() => { this.createAndSendOffer(); }, 100);
        this.pc = new RTCPeerConnection(config);
    }
    get isICEConnected() {
        return this.pc.iceConnectionState === 'connected' || this.pc.iceConnectionState === 'completed';
    }
    addIceCandidate(candidate) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pc.remoteDescription && !this.restartingIce) {
                return this.pc.addIceCandidate(candidate);
            }
            this.pendingCandidates.push(candidate);
        });
    }
    setRemoteDescription(sd) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.pc.setRemoteDescription(sd);
            this.pendingCandidates.forEach((candidate) => {
                this.pc.addIceCandidate(candidate);
            });
            this.pendingCandidates = [];
            this.restartingIce = false;
            if (this.renegotiate) {
                this.renegotiate = false;
                this.createAndSendOffer();
            }
        });
    }
    createAndSendOffer(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.onOffer === undefined) {
                return;
            }
            if (options === null || options === void 0 ? void 0 : options.iceRestart) {
                logger_1.default.debug('restarting ICE');
                this.restartingIce = true;
            }
            if (this.pc.signalingState === 'have-local-offer') {
                // we're waiting for the peer to accept our offer, so we'll just wait
                // the only exception to this is when ICE restart is needed
                const currentSD = this.pc.remoteDescription;
                if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {
                    // TODO: handle when ICE restart is needed but we don't have a remote description
                    // the best thing to do is to recreate the peerconnection
                    yield this.pc.setRemoteDescription(currentSD);
                }
                else {
                    this.renegotiate = true;
                    return;
                }
            }
            else if (this.pc.signalingState === 'closed') {
                logger_1.default.warn('could not createOffer with closed peer connection');
                return;
            }
            // actually negotiate
            logger_1.default.debug('starting to negotiate');
            const offer = yield this.pc.createOffer(options);
            yield this.pc.setLocalDescription(offer);
            this.onOffer(offer);
        });
    }
    close() {
        this.pc.close();
    }
}
exports["default"] = PCTransport;
//# sourceMappingURL=PCTransport.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/RTCEngine.js":
/*!************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/RTCEngine.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.maxICEConnectTimeout = void 0;
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const SignalClient_1 = __webpack_require__(/*! ../api/SignalClient */ "./node_modules/livekit-client/dist/api/SignalClient.js");
const logger_1 = __importDefault(__webpack_require__(/*! ../logger */ "./node_modules/livekit-client/dist/logger.js"));
const livekit_models_1 = __webpack_require__(/*! ../proto/livekit_models */ "./node_modules/livekit-client/dist/proto/livekit_models.js");
const livekit_rtc_1 = __webpack_require__(/*! ../proto/livekit_rtc */ "./node_modules/livekit-client/dist/proto/livekit_rtc.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/livekit-client/dist/room/errors.js");
const events_2 = __webpack_require__(/*! ./events */ "./node_modules/livekit-client/dist/room/events.js");
const PCTransport_1 = __importDefault(__webpack_require__(/*! ./PCTransport */ "./node_modules/livekit-client/dist/room/PCTransport.js"));
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/livekit-client/dist/room/utils.js");
const lossyDataChannel = '_lossy';
const reliableDataChannel = '_reliable';
const maxReconnectRetries = 10;
const minReconnectWait = 1 * 1000;
const maxReconnectDuration = 60 * 1000;
exports.maxICEConnectTimeout = 15 * 1000;
/** @internal */
class RTCEngine extends events_1.EventEmitter {
    constructor() {
        super();
        this.rtcConfig = {};
        this.subscriberPrimary = false;
        this.pcConnected = false;
        this.isClosed = true;
        this.pendingTrackResolvers = {};
        // true if publisher connection has already been established.
        // this is helpful to know if we need to restart ICE on the publisher connection
        this.hasPublished = false;
        this.reconnectAttempts = 0;
        this.reconnectStart = 0;
        this.fullReconnect = false;
        this.handleDataChannel = ({ channel }) => __awaiter(this, void 0, void 0, function* () {
            if (!channel) {
                return;
            }
            if (channel.label === reliableDataChannel) {
                this.reliableDCSub = channel;
            }
            else if (channel.label === lossyDataChannel) {
                this.lossyDCSub = channel;
            }
            else {
                return;
            }
            channel.onmessage = this.handleDataMessage;
        });
        this.handleDataMessage = (message) => __awaiter(this, void 0, void 0, function* () {
            // decode
            let buffer;
            if (message.data instanceof ArrayBuffer) {
                buffer = message.data;
            }
            else if (message.data instanceof Blob) {
                buffer = yield message.data.arrayBuffer();
            }
            else {
                logger_1.default.error('unsupported data type', message.data);
                return;
            }
            const dp = livekit_models_1.DataPacket.decode(new Uint8Array(buffer));
            if (dp.speaker) {
                // dispatch speaker updates
                this.emit(events_2.EngineEvent.ActiveSpeakersUpdate, dp.speaker.speakers);
            }
            else if (dp.user) {
                this.emit(events_2.EngineEvent.DataPacketReceived, dp.user, dp.kind);
            }
        });
        this.handleDataError = (event) => {
            const channel = event.currentTarget;
            const channelKind = channel.maxRetransmits === 0 ? 'lossy' : 'reliable';
            if (event instanceof ErrorEvent) {
                const { error } = event.error;
                logger_1.default.error(`DataChannel error on ${channelKind}: ${event.message}`, error);
            }
            else {
                logger_1.default.error(`Unknown DataChannel Error on ${channelKind}`, event);
            }
        };
        // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection
        // continues to work, we can reconnect to websocket to continue the session
        // after a number of retries, we'll close and give up permanently
        this.handleDisconnect = (connection) => {
            if (this.isClosed) {
                return;
            }
            logger_1.default.debug(`${connection} disconnected`);
            if (this.reconnectAttempts === 0) {
                // only reset start time on the first try
                this.reconnectStart = Date.now();
            }
            const delay = (this.reconnectAttempts * this.reconnectAttempts) * 300;
            setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                if (this.isClosed) {
                    return;
                }
                try {
                    if (this.fullReconnect) {
                        yield this.restartConnection();
                    }
                    else {
                        yield this.resumeConnection();
                    }
                    this.reconnectAttempts = 0;
                    this.fullReconnect = false;
                }
                catch (e) {
                    this.reconnectAttempts += 1;
                    let recoverable = true;
                    if (e instanceof errors_1.UnexpectedConnectionState) {
                        logger_1.default.debug('received unrecoverable error', e.message);
                        // unrecoverable
                        recoverable = false;
                    }
                    else if (!(e instanceof SignalReconnectError)) {
                        // cannot resume
                        this.fullReconnect = true;
                    }
                    const duration = Date.now() - this.reconnectStart;
                    if (this.reconnectAttempts >= maxReconnectRetries || duration > maxReconnectDuration) {
                        recoverable = false;
                    }
                    if (recoverable) {
                        this.handleDisconnect('reconnect');
                    }
                    else {
                        logger_1.default.info(`could not recover connection after ${maxReconnectRetries} attempts, ${duration}ms. giving up`);
                        this.emit(events_2.EngineEvent.Disconnected);
                        this.close();
                    }
                }
            }), delay);
        };
        this.client = new SignalClient_1.SignalClient();
    }
    join(url, token, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            this.url = url;
            this.token = token;
            this.signalOpts = opts;
            const joinResponse = yield this.client.join(url, token, opts);
            this.isClosed = false;
            this.subscriberPrimary = joinResponse.subscriberPrimary;
            if (!this.publisher) {
                this.configure(joinResponse);
            }
            // create offer
            if (!this.subscriberPrimary) {
                this.negotiate();
            }
            return joinResponse;
        });
    }
    close() {
        this.isClosed = true;
        this.removeAllListeners();
        if (this.publisher && this.publisher.pc.signalingState !== 'closed') {
            this.publisher.pc.getSenders().forEach((sender) => {
                var _a;
                try {
                    (_a = this.publisher) === null || _a === void 0 ? void 0 : _a.pc.removeTrack(sender);
                }
                catch (e) {
                    logger_1.default.warn('could not removeTrack', e);
                }
            });
            this.publisher.close();
            this.publisher = undefined;
        }
        if (this.subscriber) {
            this.subscriber.close();
            this.subscriber = undefined;
        }
        this.client.close();
    }
    addTrack(req) {
        if (this.pendingTrackResolvers[req.cid]) {
            throw new errors_1.TrackInvalidError('a track with the same ID has already been published');
        }
        return new Promise((resolve) => {
            this.pendingTrackResolvers[req.cid] = resolve;
            this.client.sendAddTrack(req);
        });
    }
    updateMuteStatus(trackSid, muted) {
        this.client.sendMuteTrack(trackSid, muted);
    }
    get dataSubscriberReadyState() {
        var _a;
        return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;
    }
    get connectedServerAddress() {
        return this.connectedServerAddr;
    }
    configure(joinResponse) {
        // already configured
        if (this.publisher || this.subscriber) {
            return;
        }
        // update ICE servers before creating PeerConnection
        if (joinResponse.iceServers && !this.rtcConfig.iceServers) {
            const rtcIceServers = [];
            joinResponse.iceServers.forEach((iceServer) => {
                const rtcIceServer = {
                    urls: iceServer.urls,
                };
                if (iceServer.username)
                    rtcIceServer.username = iceServer.username;
                if (iceServer.credential) {
                    rtcIceServer.credential = iceServer.credential;
                }
                rtcIceServers.push(rtcIceServer);
            });
            this.rtcConfig.iceServers = rtcIceServers;
        }
        this.publisher = new PCTransport_1.default(this.rtcConfig);
        this.subscriber = new PCTransport_1.default(this.rtcConfig);
        this.publisher.pc.onicecandidate = (ev) => {
            if (!ev.candidate)
                return;
            logger_1.default.trace('adding ICE candidate for peer', ev.candidate);
            this.client.sendIceCandidate(ev.candidate, livekit_rtc_1.SignalTarget.PUBLISHER);
        };
        this.subscriber.pc.onicecandidate = (ev) => {
            if (!ev.candidate)
                return;
            this.client.sendIceCandidate(ev.candidate, livekit_rtc_1.SignalTarget.SUBSCRIBER);
        };
        this.publisher.onOffer = (offer) => {
            this.client.sendOffer(offer);
        };
        let primaryPC = this.publisher.pc;
        if (joinResponse.subscriberPrimary) {
            primaryPC = this.subscriber.pc;
            // in subscriber primary mode, server side opens sub data channels.
            this.subscriber.pc.ondatachannel = this.handleDataChannel;
        }
        this.primaryPC = primaryPC;
        primaryPC.onconnectionstatechange = () => {
            if (primaryPC.connectionState === 'connected') {
                logger_1.default.trace('pc connected');
                if (!this.pcConnected) {
                    this.pcConnected = true;
                    this.emit(events_2.EngineEvent.Connected);
                }
                getConnectedAddress(primaryPC).then((v) => {
                    this.connectedServerAddr = v;
                });
            }
            else if (primaryPC.connectionState === 'failed') {
                // on Safari, PeerConnection will switch to 'disconnected' during renegotiation
                logger_1.default.trace('pc disconnected');
                if (this.pcConnected) {
                    this.pcConnected = false;
                    this.handleDisconnect('peerconnection');
                }
            }
        };
        this.subscriber.pc.ontrack = (ev) => {
            this.emit(events_2.EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);
        };
        // data channels
        this.lossyDC = this.publisher.pc.createDataChannel(lossyDataChannel, {
            // will drop older packets that arrive
            ordered: true,
            maxRetransmits: 0,
        });
        this.reliableDC = this.publisher.pc.createDataChannel(reliableDataChannel, {
            ordered: true,
        });
        // also handle messages over the pub channel, for backwards compatibility
        this.lossyDC.onmessage = this.handleDataMessage;
        this.reliableDC.onmessage = this.handleDataMessage;
        // handle datachannel errors
        this.lossyDC.onerror = this.handleDataError;
        this.reliableDC.onerror = this.handleDataError;
        // configure signaling client
        this.client.onAnswer = (sd) => __awaiter(this, void 0, void 0, function* () {
            if (!this.publisher) {
                return;
            }
            logger_1.default.debug('received server answer', sd.type, this.publisher.pc.signalingState);
            yield this.publisher.setRemoteDescription(sd);
        });
        // add candidate on trickle
        this.client.onTrickle = (candidate, target) => {
            if (!this.publisher || !this.subscriber) {
                return;
            }
            logger_1.default.trace('got ICE candidate from peer', candidate, target);
            if (target === livekit_rtc_1.SignalTarget.PUBLISHER) {
                this.publisher.addIceCandidate(candidate);
            }
            else {
                this.subscriber.addIceCandidate(candidate);
            }
        };
        // when server creates an offer for the client
        this.client.onOffer = (sd) => __awaiter(this, void 0, void 0, function* () {
            if (!this.subscriber) {
                return;
            }
            logger_1.default.debug('received server offer', sd.type, this.subscriber.pc.signalingState);
            yield this.subscriber.setRemoteDescription(sd);
            // answer the offer
            const answer = yield this.subscriber.pc.createAnswer();
            yield this.subscriber.pc.setLocalDescription(answer);
            this.client.sendAnswer(answer);
        });
        this.client.onLocalTrackPublished = (res) => {
            logger_1.default.debug('received trackPublishedResponse', res);
            const resolve = this.pendingTrackResolvers[res.cid];
            if (!resolve) {
                logger_1.default.error('missing track resolver for ', res.cid);
                return;
            }
            delete this.pendingTrackResolvers[res.cid];
            resolve(res.track);
        };
        this.client.onTokenRefresh = (token) => {
            this.token = token;
        };
        this.client.onClose = () => {
            this.handleDisconnect('signal');
        };
        this.client.onLeave = (leave) => {
            if (leave === null || leave === void 0 ? void 0 : leave.canReconnect) {
                this.fullReconnect = true;
                this.primaryPC = undefined;
            }
            else {
                this.emit(events_2.EngineEvent.Disconnected);
                this.close();
            }
        };
    }
    restartConnection() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.url || !this.token) {
                // permanent failure, don't attempt reconnection
                throw new errors_1.UnexpectedConnectionState('could not reconnect, url or token not saved');
            }
            logger_1.default.info('reconnecting, attempt', this.reconnectAttempts);
            if (this.reconnectAttempts === 0) {
                this.emit(events_2.EngineEvent.Restarting);
            }
            this.primaryPC = undefined;
            (_a = this.publisher) === null || _a === void 0 ? void 0 : _a.close();
            this.publisher = undefined;
            (_b = this.subscriber) === null || _b === void 0 ? void 0 : _b.close();
            this.subscriber = undefined;
            let joinResponse;
            try {
                joinResponse = yield this.join(this.url, this.token, this.signalOpts);
            }
            catch (e) {
                throw new SignalReconnectError();
            }
            yield this.waitForPCConnected();
            // reconnect success
            this.emit(events_2.EngineEvent.Restarted, joinResponse);
        });
    }
    resumeConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.url || !this.token) {
                // permanent failure, don't attempt reconnection
                throw new errors_1.UnexpectedConnectionState('could not reconnect, url or token not saved');
            }
            // trigger publisher reconnect
            if (!this.publisher || !this.subscriber) {
                throw new errors_1.UnexpectedConnectionState('publisher and subscriber connections unset');
            }
            logger_1.default.info('resuming signal connection, attempt', this.reconnectAttempts);
            if (this.reconnectAttempts === 0) {
                this.emit(events_2.EngineEvent.Resuming);
            }
            try {
                yield this.client.reconnect(this.url, this.token);
            }
            catch (e) {
                throw new SignalReconnectError();
            }
            this.emit(events_2.EngineEvent.SignalResumed);
            this.subscriber.restartingIce = true;
            // only restart publisher if it's needed
            if (this.hasPublished) {
                yield this.publisher.createAndSendOffer({ iceRestart: true });
            }
            yield this.waitForPCConnected();
            // resume success
            this.emit(events_2.EngineEvent.Resumed);
        });
    }
    waitForPCConnected() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const startTime = (new Date()).getTime();
            let now = startTime;
            this.pcConnected = false;
            while (now - startTime < exports.maxICEConnectTimeout) {
                // if there is no connectionstatechange callback fired
                // check connectionstate after minReconnectWait
                if (this.primaryPC === undefined) {
                    // we can abort early, connection is hosed
                    break;
                }
                else if (now - startTime > minReconnectWait && ((_a = this.primaryPC) === null || _a === void 0 ? void 0 : _a.connectionState) === 'connected') {
                    this.pcConnected = true;
                }
                if (this.pcConnected) {
                    return;
                }
                yield utils_1.sleep(100);
                now = (new Date()).getTime();
            }
            // have not reconnected, throw
            throw new errors_1.ConnectionError('could not establish PC connection');
        });
    }
    /* @internal */
    sendDataPacket(packet, kind) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = livekit_models_1.DataPacket.encode(packet).finish();
            // make sure we do have a data connection
            yield this.ensurePublisherConnected(kind);
            if (kind === livekit_models_1.DataPacket_Kind.LOSSY && this.lossyDC) {
                this.lossyDC.send(msg);
            }
            else if (kind === livekit_models_1.DataPacket_Kind.RELIABLE && this.reliableDC) {
                this.reliableDC.send(msg);
            }
        });
    }
    ensurePublisherConnected(kind) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.subscriberPrimary) {
                return;
            }
            if (!this.publisher) {
                throw new errors_1.ConnectionError('publisher connection not set');
            }
            if (!this.publisher.isICEConnected && this.publisher.pc.iceConnectionState !== 'checking') {
                // start negotiation
                this.negotiate();
            }
            const targetChannel = this.dataChannelForKind(kind);
            if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === 'open') {
                return;
            }
            // wait until publisher ICE connected
            const endTime = (new Date()).getTime() + exports.maxICEConnectTimeout;
            while ((new Date()).getTime() < endTime) {
                if (this.publisher.isICEConnected && ((_a = this.dataChannelForKind(kind)) === null || _a === void 0 ? void 0 : _a.readyState) === 'open') {
                    return;
                }
                yield utils_1.sleep(50);
            }
            throw new errors_1.ConnectionError(`could not establish publisher connection, state ${(_b = this.publisher) === null || _b === void 0 ? void 0 : _b.pc.iceConnectionState}`);
        });
    }
    /** @internal */
    negotiate() {
        if (!this.publisher) {
            return;
        }
        this.hasPublished = true;
        this.publisher.negotiate();
    }
    dataChannelForKind(kind) {
        if (kind === livekit_models_1.DataPacket_Kind.LOSSY) {
            return this.lossyDC;
        }
        if (kind === livekit_models_1.DataPacket_Kind.RELIABLE) {
            return this.reliableDC;
        }
    }
}
exports["default"] = RTCEngine;
function getConnectedAddress(pc) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        let selectedCandidatePairId = '';
        const candidatePairs = new Map();
        // id -> candidate ip
        const candidates = new Map();
        const stats = yield pc.getStats();
        stats.forEach((v) => {
            switch (v.type) {
                case 'transport':
                    selectedCandidatePairId = v.selectedCandidatePairId;
                    break;
                case 'candidate-pair':
                    if (selectedCandidatePairId === '' && v.selected) {
                        selectedCandidatePairId = v.id;
                    }
                    candidatePairs.set(v.id, v);
                    break;
                case 'remote-candidate':
                    candidates.set(v.id, `${v.address}:${v.port}`);
                    break;
                default:
            }
        });
        if (selectedCandidatePairId === '') {
            return undefined;
        }
        const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;
        if (selectedID === undefined) {
            return undefined;
        }
        return candidates.get(selectedID);
    });
}
class SignalReconnectError extends Error {
}
//# sourceMappingURL=RTCEngine.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/Room.js":
/*!*******************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/Room.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoomState = void 0;
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const SignalClient_1 = __webpack_require__(/*! ../api/SignalClient */ "./node_modules/livekit-client/dist/api/SignalClient.js");
const logger_1 = __importDefault(__webpack_require__(/*! ../logger */ "./node_modules/livekit-client/dist/logger.js"));
const livekit_models_1 = __webpack_require__(/*! ../proto/livekit_models */ "./node_modules/livekit-client/dist/proto/livekit_models.js");
const livekit_rtc_1 = __webpack_require__(/*! ../proto/livekit_rtc */ "./node_modules/livekit-client/dist/proto/livekit_rtc.js");
const DeviceManager_1 = __importDefault(__webpack_require__(/*! ./DeviceManager */ "./node_modules/livekit-client/dist/room/DeviceManager.js"));
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/livekit-client/dist/room/errors.js");
const events_2 = __webpack_require__(/*! ./events */ "./node_modules/livekit-client/dist/room/events.js");
const LocalParticipant_1 = __importDefault(__webpack_require__(/*! ./participant/LocalParticipant */ "./node_modules/livekit-client/dist/room/participant/LocalParticipant.js"));
const RemoteParticipant_1 = __importDefault(__webpack_require__(/*! ./participant/RemoteParticipant */ "./node_modules/livekit-client/dist/room/participant/RemoteParticipant.js"));
const RTCEngine_1 = __importStar(__webpack_require__(/*! ./RTCEngine */ "./node_modules/livekit-client/dist/room/RTCEngine.js"));
const defaults_1 = __webpack_require__(/*! ./track/defaults */ "./node_modules/livekit-client/dist/room/track/defaults.js");
const RemoteTrackPublication_1 = __importDefault(__webpack_require__(/*! ./track/RemoteTrackPublication */ "./node_modules/livekit-client/dist/room/track/RemoteTrackPublication.js"));
const Track_1 = __webpack_require__(/*! ./track/Track */ "./node_modules/livekit-client/dist/room/track/Track.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/livekit-client/dist/room/utils.js");
var RoomState;
(function (RoomState) {
    RoomState["Disconnected"] = "disconnected";
    RoomState["Connected"] = "connected";
    RoomState["Reconnecting"] = "reconnecting";
})(RoomState = exports.RoomState || (exports.RoomState = {}));
/**
 * In LiveKit, a room is the logical grouping for a list of participants.
 * Participants in a room can publish tracks, and subscribe to others' tracks.
 *
 * a Room fires [[RoomEvent | RoomEvents]].
 *
 * @noInheritDoc
 */
class Room extends events_1.EventEmitter {
    /**
     * Creates a new Room, the primary construct for a LiveKit session.
     * @param options
     */
    constructor(options) {
        super();
        this.state = RoomState.Disconnected;
        /**
         * list of participants that are actively speaking. when this changes
         * a [[RoomEvent.ActiveSpeakersChanged]] event is fired
         */
        this.activeSpeakers = [];
        // available after connected
        /** server assigned unique room id */
        this.sid = '';
        /** user assigned name, derived from JWT token */
        this.name = '';
        /** room metadata */
        this.metadata = undefined;
        this.audioEnabled = true;
        this.connect = (url, token, opts) => __awaiter(this, void 0, void 0, function* () {
            // guard against calling connect
            if (this.state !== RoomState.Disconnected) {
                logger_1.default.warn('already connected to room', this.name);
                return;
            }
            // recreate engine if previously disconnected
            this.createEngine();
            this.acquireAudioContext();
            if (opts === null || opts === void 0 ? void 0 : opts.rtcConfig) {
                this.engine.rtcConfig = opts.rtcConfig;
            }
            this.connOptions = opts;
            try {
                const joinResponse = yield this.engine.join(url, token, opts);
                logger_1.default.debug('connected to Livekit Server', joinResponse.serverVersion);
                if (!joinResponse.serverVersion) {
                    throw new errors_1.UnsupportedServer('unknown server version');
                }
                if (joinResponse.serverVersion === '0.15.1' && this.options.dynacast) {
                    logger_1.default.debug('disabling dynacast due to server version');
                    // dynacast has a bug in 0.15.1, so we cannot use it then
                    this.options.dynacast = false;
                }
                this.state = RoomState.Connected;
                const pi = joinResponse.participant;
                this.localParticipant = new LocalParticipant_1.default(pi.sid, pi.identity, this.engine, this.options);
                this.localParticipant.updateInfo(pi);
                // forward metadata changed for the local participant
                this.localParticipant
                    .on(events_2.ParticipantEvent.MetadataChanged, (metadata) => {
                    this.emit(events_2.RoomEvent.MetadataChanged, metadata, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.ParticipantMetadataChanged, (metadata) => {
                    this.emit(events_2.RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.TrackMuted, (pub) => {
                    this.emit(events_2.RoomEvent.TrackMuted, pub, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.TrackUnmuted, (pub) => {
                    this.emit(events_2.RoomEvent.TrackUnmuted, pub, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.LocalTrackPublished, (pub) => {
                    this.emit(events_2.RoomEvent.LocalTrackPublished, pub, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.LocalTrackUnpublished, (pub) => {
                    this.emit(events_2.RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.ConnectionQualityChanged, (quality) => {
                    this.emit(events_2.RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.MediaDevicesError, (e) => {
                    this.emit(events_2.RoomEvent.MediaDevicesError, e);
                });
                // populate remote participants, these should not trigger new events
                joinResponse.otherParticipants.forEach((info) => {
                    this.getOrCreateParticipant(info.sid, info);
                });
                this.name = joinResponse.room.name;
                this.sid = joinResponse.room.sid;
                this.metadata = joinResponse.room.metadata;
            }
            catch (err) {
                this.engine.close();
                throw err;
            }
            // don't return until ICE connected
            return new Promise((resolve, reject) => {
                const connectTimeout = setTimeout(() => {
                    // timeout
                    this.engine.close();
                    reject(new errors_1.ConnectionError('could not connect after timeout'));
                }, RTCEngine_1.maxICEConnectTimeout);
                this.engine.once(events_2.EngineEvent.Connected, () => {
                    clearTimeout(connectTimeout);
                    // also hook unload event
                    window.addEventListener('beforeunload', this.onBeforeUnload);
                    navigator.mediaDevices.addEventListener('devicechange', this.handleDeviceChange);
                    resolve(this);
                });
            });
        });
        /**
         * disconnects the room, emits [[RoomEvent.Disconnected]]
         */
        this.disconnect = (stopTracks = true) => {
            // send leave
            if (this.engine) {
                this.engine.client.sendLeave();
                this.engine.close();
            }
            this.handleDisconnect(stopTracks);
            /* @ts-ignore */
            this.engine = undefined;
        };
        this.onBeforeUnload = () => {
            this.disconnect();
        };
        this.handleRestarting = () => {
            this.state = RoomState.Reconnecting;
            this.emit(events_2.RoomEvent.Reconnecting);
            // also unwind existing participants & existing subscriptions
            for (const p of this.participants.values()) {
                this.handleParticipantDisconnected(p.sid, p);
            }
        };
        this.handleRestarted = (joinResponse) => __awaiter(this, void 0, void 0, function* () {
            this.state = RoomState.Connected;
            this.emit(events_2.RoomEvent.Reconnected);
            // rehydrate participants
            if (joinResponse.participant) {
                // with a restart, the sid will have changed, we'll map our understanding to it
                this.localParticipant.sid = joinResponse.participant.sid;
                this.handleParticipantUpdates([joinResponse.participant]);
            }
            this.handleParticipantUpdates(joinResponse.otherParticipants);
            // unpublish & republish tracks
            const localPubs = [];
            this.localParticipant.tracks.forEach((pub) => {
                if (pub.track) {
                    localPubs.push(pub);
                }
            });
            yield Promise.all(localPubs.map((pub) => __awaiter(this, void 0, void 0, function* () {
                const track = pub.track;
                this.localParticipant.unpublishTrack(track, false);
                this.localParticipant.publishTrack(track, pub.options);
            })));
        });
        this.handleParticipantUpdates = (participantInfos) => {
            // handle changes to participant state, and send events
            participantInfos.forEach((info) => {
                if (info.sid === this.localParticipant.sid
                    || info.identity === this.localParticipant.identity) {
                    this.localParticipant.updateInfo(info);
                    return;
                }
                let remoteParticipant = this.participants.get(info.sid);
                const isNewParticipant = !remoteParticipant;
                // create participant if doesn't exist
                remoteParticipant = this.getOrCreateParticipant(info.sid, info);
                // when it's disconnected, send updates
                if (info.state === livekit_models_1.ParticipantInfo_State.DISCONNECTED) {
                    this.handleParticipantDisconnected(info.sid, remoteParticipant);
                }
                else if (isNewParticipant) {
                    // fire connected event
                    this.emit(events_2.RoomEvent.ParticipantConnected, remoteParticipant);
                }
                else {
                    // just update, no events
                    remoteParticipant.updateInfo(info);
                }
            });
        };
        // updates are sent only when there's a change to speaker ordering
        this.handleActiveSpeakersUpdate = (speakers) => {
            const activeSpeakers = [];
            const seenSids = {};
            speakers.forEach((speaker) => {
                seenSids[speaker.sid] = true;
                if (speaker.sid === this.localParticipant.sid) {
                    this.localParticipant.audioLevel = speaker.level;
                    this.localParticipant.setIsSpeaking(true);
                    activeSpeakers.push(this.localParticipant);
                }
                else {
                    const p = this.participants.get(speaker.sid);
                    if (p) {
                        p.audioLevel = speaker.level;
                        p.setIsSpeaking(true);
                        activeSpeakers.push(p);
                    }
                }
            });
            if (!seenSids[this.localParticipant.sid]) {
                this.localParticipant.audioLevel = 0;
                this.localParticipant.setIsSpeaking(false);
            }
            this.participants.forEach((p) => {
                if (!seenSids[p.sid]) {
                    p.audioLevel = 0;
                    p.setIsSpeaking(false);
                }
            });
            this.activeSpeakers = activeSpeakers;
            this.emit(events_2.RoomEvent.ActiveSpeakersChanged, activeSpeakers);
        };
        // process list of changed speakers
        this.handleSpeakersChanged = (speakerUpdates) => {
            const lastSpeakers = new Map();
            this.activeSpeakers.forEach((p) => {
                lastSpeakers.set(p.sid, p);
            });
            speakerUpdates.forEach((speaker) => {
                let p = this.participants.get(speaker.sid);
                if (speaker.sid === this.localParticipant.sid) {
                    p = this.localParticipant;
                }
                if (!p) {
                    return;
                }
                p.audioLevel = speaker.level;
                p.setIsSpeaking(speaker.active);
                if (speaker.active) {
                    lastSpeakers.set(speaker.sid, p);
                }
                else {
                    lastSpeakers.delete(speaker.sid);
                }
            });
            const activeSpeakers = Array.from(lastSpeakers.values());
            activeSpeakers.sort((a, b) => b.audioLevel - a.audioLevel);
            this.activeSpeakers = activeSpeakers;
            this.emit(events_2.RoomEvent.ActiveSpeakersChanged, activeSpeakers);
        };
        this.handleStreamStateUpdate = (streamStateUpdate) => {
            streamStateUpdate.streamStates.forEach((streamState) => {
                const participant = this.participants.get(streamState.participantSid);
                if (!participant) {
                    return;
                }
                const pub = participant.getTrackPublication(streamState.trackSid);
                if (!pub || !pub.track) {
                    return;
                }
                pub.track.streamState = Track_1.Track.streamStateFromProto(streamState.state);
                participant.emit(events_2.ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);
                this.emit(events_2.ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);
            });
        };
        this.handleSubscriptionPermissionUpdate = (update) => {
            const participant = this.participants.get(update.participantSid);
            if (!participant) {
                return;
            }
            const pub = participant.getTrackPublication(update.trackSid);
            if (!pub) {
                return;
            }
            pub._allowed = update.allowed;
            participant.emit(events_2.ParticipantEvent.TrackSubscriptionPermissionChanged, pub, pub.subscriptionStatus);
            this.emit(events_2.ParticipantEvent.TrackSubscriptionPermissionChanged, pub, pub.subscriptionStatus, participant);
        };
        this.handleDataPacket = (userPacket, kind) => {
            // find the participant
            const participant = this.participants.get(userPacket.participantSid);
            this.emit(events_2.RoomEvent.DataReceived, userPacket.payload, participant, kind);
            // also emit on the participant
            participant === null || participant === void 0 ? void 0 : participant.emit(events_2.ParticipantEvent.DataReceived, userPacket.payload, kind);
        };
        this.handleAudioPlaybackStarted = () => {
            if (this.canPlaybackAudio) {
                return;
            }
            this.audioEnabled = true;
            this.emit(events_2.RoomEvent.AudioPlaybackStatusChanged, true);
        };
        this.handleAudioPlaybackFailed = (e) => {
            logger_1.default.warn('could not playback audio', e);
            if (!this.canPlaybackAudio) {
                return;
            }
            this.audioEnabled = false;
            this.emit(events_2.RoomEvent.AudioPlaybackStatusChanged, false);
        };
        this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {
            this.emit(events_2.RoomEvent.MediaDevicesChanged);
        });
        this.handleRoomUpdate = (r) => {
            this.metadata = r.metadata;
            this.emit(events_2.RoomEvent.RoomMetadataChanged, r.metadata);
        };
        this.handleConnectionQualityUpdate = (update) => {
            update.updates.forEach((info) => {
                if (info.participantSid === this.localParticipant.sid) {
                    this.localParticipant.setConnectionQuality(info.quality);
                    return;
                }
                const participant = this.participants.get(info.participantSid);
                if (participant) {
                    participant.setConnectionQuality(info.quality);
                }
            });
        };
        this.participants = new Map();
        this.options = options || {};
        this.options.audioCaptureDefaults = Object.assign(Object.assign({}, defaults_1.audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);
        this.options.videoCaptureDefaults = Object.assign(Object.assign({}, defaults_1.videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);
        this.options.publishDefaults = Object.assign(Object.assign({}, defaults_1.publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);
        this.createEngine();
        this.localParticipant = new LocalParticipant_1.default('', '', this.engine, this.options);
    }
    createEngine() {
        if (this.engine) {
            return;
        }
        this.engine = new RTCEngine_1.default();
        this.engine.client.signalLatency = this.options.expSignalLatency;
        this.engine.client.onParticipantUpdate = this.handleParticipantUpdates;
        this.engine.client.onRoomUpdate = this.handleRoomUpdate;
        this.engine.client.onSpeakersChanged = this.handleSpeakersChanged;
        this.engine.client.onStreamStateUpdate = this.handleStreamStateUpdate;
        this.engine.client.onSubscriptionPermissionUpdate = this.handleSubscriptionPermissionUpdate;
        this.engine.client.onConnectionQuality = this.handleConnectionQualityUpdate;
        this.engine
            .on(events_2.EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {
            this.onTrackAdded(mediaTrack, stream, receiver);
        })
            .on(events_2.EngineEvent.Disconnected, () => {
            this.handleDisconnect();
        })
            .on(events_2.EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate)
            .on(events_2.EngineEvent.DataPacketReceived, this.handleDataPacket)
            .on(events_2.EngineEvent.Resuming, () => {
            this.state = RoomState.Reconnecting;
            this.emit(events_2.RoomEvent.Reconnecting);
        })
            .on(events_2.EngineEvent.Resumed, () => {
            this.state = RoomState.Connected;
            this.emit(events_2.RoomEvent.Reconnected);
            this.updateSubscriptions();
        })
            .on(events_2.EngineEvent.SignalResumed, () => {
            if (this.state === RoomState.Reconnecting) {
                this.sendSyncState();
            }
        })
            .on(events_2.EngineEvent.Restarting, this.handleRestarting)
            .on(events_2.EngineEvent.Restarted, this.handleRestarted);
    }
    /**
     * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
     * In particular, it handles Chrome's unique behavior of creating `default`
     * devices. When encountered, it'll be removed from the list of devices.
     * The actual default device will be placed at top.
     * @param kind
     * @returns a list of available local devices
     */
    static getLocalDevices(kind) {
        return DeviceManager_1.default.getInstance().getDevices(kind);
    }
    /**
     * retrieves a participant by identity
     * @param identity
     * @returns
     */
    getParticipantByIdentity(identity) {
        for (const [, p] of this.participants) {
            if (p.identity === identity) {
                return p;
            }
        }
        if (this.localParticipant.identity === identity) {
            return this.localParticipant;
        }
    }
    /**
     * @internal for testing
     */
    simulateScenario(scenario) {
        let req;
        switch (scenario) {
            case 'speaker':
                req = livekit_rtc_1.SimulateScenario.fromPartial({
                    speakerUpdate: 3,
                });
                break;
            case 'node-failure':
                req = livekit_rtc_1.SimulateScenario.fromPartial({
                    nodeFailure: true,
                });
                break;
            case 'server-leave':
                req = livekit_rtc_1.SimulateScenario.fromPartial({
                    serverLeave: true,
                });
                break;
            case 'migration':
                req = livekit_rtc_1.SimulateScenario.fromPartial({
                    migration: true,
                });
                break;
            default:
        }
        if (req) {
            this.engine.client.sendSimulateScenario(req);
        }
    }
    /**
     * Browsers have different policies regarding audio playback. Most requiring
     * some form of user interaction (click/tap/etc).
     * In those cases, audio will be silent until a click/tap triggering one of the following
     * - `startAudio`
     * - `getUserMedia`
     */
    startAudio() {
        return __awaiter(this, void 0, void 0, function* () {
            this.acquireAudioContext();
            const elements = [];
            this.participants.forEach((p) => {
                p.audioTracks.forEach((t) => {
                    if (t.track) {
                        t.track.attachedElements.forEach((e) => {
                            elements.push(e);
                        });
                    }
                });
            });
            try {
                yield Promise.all(elements.map((e) => e.play()));
                this.handleAudioPlaybackStarted();
            }
            catch (err) {
                this.handleAudioPlaybackFailed(err);
                throw err;
            }
        });
    }
    /**
     * Returns true if audio playback is enabled
     */
    get canPlaybackAudio() {
        return this.audioEnabled;
    }
    /**
     * Switches all active device used in this room to the given device.
     *
     * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
     *
     * @param kind use `videoinput` for camera track,
     *  `audioinput` for microphone track,
     *  `audiooutput` to set speaker for all incoming audio tracks
     * @param deviceId
     */
    switchActiveDevice(kind, deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (kind === 'audioinput') {
                const tracks = Array
                    .from(this.localParticipant.audioTracks.values())
                    .filter((track) => track.source === Track_1.Track.Source.Microphone);
                yield Promise.all(tracks.map((t) => { var _a; return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceId); }));
                this.options.audioCaptureDefaults.deviceId = deviceId;
            }
            else if (kind === 'videoinput') {
                const tracks = Array
                    .from(this.localParticipant.videoTracks.values())
                    .filter((track) => track.source === Track_1.Track.Source.Camera);
                yield Promise.all(tracks.map((t) => { var _a; return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceId); }));
                this.options.videoCaptureDefaults.deviceId = deviceId;
            }
            else if (kind === 'audiooutput') {
                const elements = [];
                this.participants.forEach((p) => {
                    p.audioTracks.forEach((t) => {
                        if (t.isSubscribed && t.track) {
                            t.track.attachedElements.forEach((e) => {
                                elements.push(e);
                            });
                        }
                    });
                });
                yield Promise.all(elements.map((e) => __awaiter(this, void 0, void 0, function* () {
                    if ('setSinkId' in e) {
                        /* @ts-ignore */
                        yield e.setSinkId(deviceId);
                    }
                })));
            }
        });
    }
    onTrackAdded(mediaTrack, stream, receiver) {
        const parts = utils_1.unpackStreamId(stream.id);
        const participantId = parts[0];
        let trackId = parts[1];
        if (!trackId || trackId === '')
            trackId = mediaTrack.id;
        const participant = this.getOrCreateParticipant(participantId);
        participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, this.options.adaptiveStream);
    }
    handleDisconnect(shouldStopTracks = true) {
        if (this.state === RoomState.Disconnected) {
            return;
        }
        this.participants.forEach((p) => {
            p.tracks.forEach((pub) => {
                p.unpublishTrack(pub.trackSid);
            });
        });
        this.localParticipant.tracks.forEach((pub) => {
            var _a, _b;
            if (pub.track) {
                this.localParticipant.unpublishTrack(pub.track);
            }
            if (shouldStopTracks) {
                (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();
                (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();
            }
        });
        this.participants.clear();
        this.activeSpeakers = [];
        if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = undefined;
        }
        window.removeEventListener('beforeunload', this.onBeforeUnload);
        navigator.mediaDevices.removeEventListener('devicechange', this.handleDeviceChange);
        this.state = RoomState.Disconnected;
        this.emit(events_2.RoomEvent.Disconnected);
    }
    handleParticipantDisconnected(sid, participant) {
        // remove and send event
        this.participants.delete(sid);
        if (!participant) {
            return;
        }
        participant.tracks.forEach((publication) => {
            participant.unpublishTrack(publication.trackSid);
        });
        this.emit(events_2.RoomEvent.ParticipantDisconnected, participant);
    }
    acquireAudioContext() {
        if (this.audioContext) {
            this.audioContext.close();
        }
        // by using an AudioContext, it reduces lag on audio elements
        // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854
        // @ts-ignore
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (AudioContext) {
            this.audioContext = new AudioContext();
        }
    }
    getOrCreateParticipant(id, info) {
        let participant = this.participants.get(id);
        if (!participant) {
            // it's possible for the RTC track to arrive before signaling data
            // when this happens, we'll create the participant and make the track work
            if (info) {
                participant = RemoteParticipant_1.default.fromParticipantInfo(this.engine.client, info);
            }
            else {
                participant = new RemoteParticipant_1.default(this.engine.client, id, '');
            }
            this.participants.set(id, participant);
            // also forward events
            // trackPublished is only fired for tracks added after both local participant
            // and remote participant joined the room
            participant
                .on(events_2.ParticipantEvent.TrackPublished, (trackPublication) => {
                this.emit(events_2.RoomEvent.TrackPublished, trackPublication, participant);
            })
                .on(events_2.ParticipantEvent.TrackSubscribed, (track, publication) => {
                // monitor playback status
                if (track.kind === Track_1.Track.Kind.Audio) {
                    track.on(events_2.TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);
                    track.on(events_2.TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);
                }
                this.emit(events_2.RoomEvent.TrackSubscribed, track, publication, participant);
            })
                .on(events_2.ParticipantEvent.TrackUnpublished, (publication) => {
                this.emit(events_2.RoomEvent.TrackUnpublished, publication, participant);
            })
                .on(events_2.ParticipantEvent.TrackUnsubscribed, (track, publication) => {
                this.emit(events_2.RoomEvent.TrackUnsubscribed, track, publication, participant);
            })
                .on(events_2.ParticipantEvent.TrackSubscriptionFailed, (sid) => {
                this.emit(events_2.RoomEvent.TrackSubscriptionFailed, sid, participant);
            })
                .on(events_2.ParticipantEvent.TrackMuted, (pub) => {
                this.emit(events_2.RoomEvent.TrackMuted, pub, participant);
            })
                .on(events_2.ParticipantEvent.TrackUnmuted, (pub) => {
                this.emit(events_2.RoomEvent.TrackUnmuted, pub, participant);
            })
                .on(events_2.ParticipantEvent.MetadataChanged, (metadata) => {
                this.emit(events_2.RoomEvent.MetadataChanged, metadata, participant);
            })
                .on(events_2.ParticipantEvent.ParticipantMetadataChanged, (metadata) => {
                this.emit(events_2.RoomEvent.ParticipantMetadataChanged, metadata, participant);
            })
                .on(events_2.ParticipantEvent.ConnectionQualityChanged, (quality) => {
                this.emit(events_2.RoomEvent.ConnectionQualityChanged, quality, participant);
            });
        }
        return participant;
    }
    sendSyncState() {
        var _a;
        if (this.engine.subscriber === undefined
            || this.engine.subscriber.pc.localDescription === null) {
            return;
        }
        const previousSdp = this.engine.subscriber.pc.localDescription;
        /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,
              in this case, we send unsub tracks, so server add all tracks to this
              subscribe pc and unsub special tracks from it.
           2. autosubscribe off, we send subscribed tracks.
        */
        const sendUnsub = ((_a = this.connOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe) || false;
        const trackSids = new Array();
        this.participants.forEach((participant) => {
            participant.tracks.forEach((track) => {
                if (track.isSubscribed !== sendUnsub) {
                    trackSids.push(track.trackSid);
                }
            });
        });
        this.engine.client.sendSyncState({
            answer: SignalClient_1.toProtoSessionDescription({
                sdp: previousSdp.sdp,
                type: previousSdp.type,
            }),
            subscription: {
                trackSids,
                subscribe: !sendUnsub,
                participantTracks: [],
            },
            publishTracks: this.localParticipant.publishedTracksInfo(),
        });
    }
    /**
     * After resuming, we'll need to notify the server of the current
     * subscription settings.
     */
    updateSubscriptions() {
        for (const p of this.participants.values()) {
            for (const pub of p.videoTracks.values()) {
                if (pub.isSubscribed && pub instanceof RemoteTrackPublication_1.default) {
                    pub.emitTrackUpdate();
                }
            }
        }
    }
    /** @internal */
    emit(event, ...args) {
        logger_1.default.debug('room event', event, ...args);
        return super.emit(event, ...args);
    }
}
exports["default"] = Room;
//# sourceMappingURL=Room.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/errors.js":
/*!*********************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/errors.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MediaDeviceFailure = exports.PublishDataError = exports.UnexpectedConnectionState = exports.UnsupportedServer = exports.TrackInvalidError = exports.ConnectionError = exports.LivekitError = void 0;
class LivekitError extends Error {
    constructor(code, message) {
        super(message || 'an error has occured');
        this.code = code;
    }
}
exports.LivekitError = LivekitError;
class ConnectionError extends LivekitError {
    constructor(message) {
        super(1, message);
    }
}
exports.ConnectionError = ConnectionError;
class TrackInvalidError extends LivekitError {
    constructor(message) {
        super(20, message || 'Track is invalid');
    }
}
exports.TrackInvalidError = TrackInvalidError;
class UnsupportedServer extends LivekitError {
    constructor(message) {
        super(10, message || 'Unsupported server');
    }
}
exports.UnsupportedServer = UnsupportedServer;
class UnexpectedConnectionState extends LivekitError {
    constructor(message) {
        super(12, message || 'Unexpected connection state');
    }
}
exports.UnexpectedConnectionState = UnexpectedConnectionState;
class PublishDataError extends LivekitError {
    constructor(message) {
        super(13, message || 'Unable to publish data');
    }
}
exports.PublishDataError = PublishDataError;
var MediaDeviceFailure;
(function (MediaDeviceFailure) {
    // user rejected permissions
    MediaDeviceFailure["PermissionDenied"] = "PermissionDenied";
    // device is not available
    MediaDeviceFailure["NotFound"] = "NotFound";
    // device is in use. On Windows, only a single tab may get access to a device at a time.
    MediaDeviceFailure["DeviceInUse"] = "DeviceInUse";
    MediaDeviceFailure["Other"] = "Other";
})(MediaDeviceFailure = exports.MediaDeviceFailure || (exports.MediaDeviceFailure = {}));
(function (MediaDeviceFailure) {
    function getFailure(error) {
        if (error && 'name' in error) {
            if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                return MediaDeviceFailure.NotFound;
            }
            if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                return MediaDeviceFailure.PermissionDenied;
            }
            if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                return MediaDeviceFailure.DeviceInUse;
            }
            return MediaDeviceFailure.Other;
        }
    }
    MediaDeviceFailure.getFailure = getFailure;
})(MediaDeviceFailure = exports.MediaDeviceFailure || (exports.MediaDeviceFailure = {}));
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/events.js":
/*!*********************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/events.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TrackEvent = exports.EngineEvent = exports.ParticipantEvent = exports.RoomEvent = void 0;
/**
 * Events are the primary way LiveKit notifies your application of changes.
 *
 * The following are events emitted by [[Room]], listen to room events like
 *
 * ```typescript
 * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})
 * ```
 */
var RoomEvent;
(function (RoomEvent) {
    /**
     * When the connection to the server has been interrupted and it's attempting
     * to reconnect.
     */
    RoomEvent["Reconnecting"] = "reconnecting";
    /**
     * Fires when a reconnection has been successful.
     */
    RoomEvent["Reconnected"] = "reconnected";
    /**
     * When disconnected from room. This fires when room.disconnect() is called or
     * when an unrecoverable connection issue had occured
     */
    RoomEvent["Disconnected"] = "disconnected";
    /**
     * When input or output devices on the machine have changed.
     */
    RoomEvent["MediaDevicesChanged"] = "mediaDevicesChanged";
    /**
     * When a [[RemoteParticipant]] joins *after* the local
     * participant. It will not emit events for participants that are already
     * in the room
     *
     * args: ([[RemoteParticipant]])
     */
    RoomEvent["ParticipantConnected"] = "participantConnected";
    /**
     * When a [[RemoteParticipant]] leaves *after* the local
     * participant has joined.
     *
     * args: ([[RemoteParticipant]])
     */
    RoomEvent["ParticipantDisconnected"] = "participantDisconnected";
    /**
     * When a new track is published to room *after* the local
     * participant has joined. It will not fire for tracks that are already published.
     *
     * A track published doesn't mean the participant has subscribed to it. It's
     * simply reflecting the state of the room.
     *
     * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])
     */
    RoomEvent["TrackPublished"] = "trackPublished";
    /**
     * The [[LocalParticipant]] has subscribed to a new track. This event will **always**
     * fire as long as new tracks are ready for use.
     *
     * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])
     */
    RoomEvent["TrackSubscribed"] = "trackSubscribed";
    /**
     * Could not subscribe to a track
     *
     * args: (track sid, [[RemoteParticipant]])
     */
    RoomEvent["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
    /**
     * A [[RemoteParticipant]] has unpublished a track
     *
     * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])
     */
    RoomEvent["TrackUnpublished"] = "trackUnpublished";
    /**
     * A subscribed track is no longer available. Clients should listen to this
     * event and ensure they detach tracks.
     *
     * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])
     */
    RoomEvent["TrackUnsubscribed"] = "trackUnsubscribed";
    /**
     * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]
     *
     * args: ([[TrackPublication]], [[Participant]])
     */
    RoomEvent["TrackMuted"] = "trackMuted";
    /**
     * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]
     *
     * args: ([[TrackPublication]], [[Participant]])
     */
    RoomEvent["TrackUnmuted"] = "trackUnmuted";
    /**
     * A local track was published successfully. This event is helpful to know
     * when to update your local UI with the newly published track.
     *
     * args: ([[LocalTrackPublication]], [[LocalParticipant]])
     */
    RoomEvent["LocalTrackPublished"] = "localTrackPublished";
    /**
     * A local track was unpublished. This event is helpful to know when to remove
     * the local track from your UI.
     *
     * When a user stops sharing their screen by pressing "End" on the browser UI,
     * this event will also fire.
     *
     * args: ([[LocalTrackPublication]], [[LocalParticipant]])
     */
    RoomEvent["LocalTrackUnpublished"] = "localTrackUnpublished";
    /**
     * Active speakers changed. List of speakers are ordered by their audio level.
     * loudest speakers first. This will include the LocalParticipant too.
     *
     * Speaker updates are sent only to the publishing participant and their subscribers.
     *
     * args: (Array<[[Participant]]>)
     */
    RoomEvent["ActiveSpeakersChanged"] = "activeSpeakersChanged";
    /**
     * @deprecated Use ParticipantMetadataChanged instead
     * @internal
     */
    RoomEvent["MetadataChanged"] = "metadataChanged";
    /**
     * Participant metadata is a simple way for app-specific state to be pushed to
     * all users.
     * When RoomService.UpdateParticipantMetadata is called to change a participant's
     * state, *all*  participants in the room will fire this event.
     *
     * args: (prevMetadata: string, [[Participant]])
     *
     */
    RoomEvent["ParticipantMetadataChanged"] = "participantMetaDataChanged";
    /**
     * Room metadata is a simple way for app-specific state to be pushed to
     * all users.
     * When RoomService.UpdateRoomMetadata is called to change a room's state,
     * *all*  participants in the room will fire this event.
     *
     * args: (string)
     */
    RoomEvent["RoomMetadataChanged"] = "roomMetadataChanged";
    /**
     * Data received from another participant.
     * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.
     * All participants in the room will receive the messages sent to the room.
     *
     * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]])
     */
    RoomEvent["DataReceived"] = "dataReceived";
    /**
     * Connection quality was changed for a Participant. It'll receive updates
     * from the local participant, as well as any [[RemoteParticipant]]s that we are
     * subscribed to.
     *
     * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])
     */
    RoomEvent["ConnectionQualityChanged"] = "connectionQualityChanged";
    /**
     * StreamState indicates if a subscribed track has been paused by the SFU
     * (typically this happens because of subscriber's bandwidth constraints)
     *
     * When bandwidth conditions allow, the track will be resumed automatically.
     * TrackStreamStateChanged will also be emitted when that happens.
     *
     * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],
     *        participant: [[RemoteParticipant]])
     */
    RoomEvent["TrackStreamStateChanged"] = "trackStreamStateChanged";
    /**
     * One of subscribed tracks have changed its permissions for the current
     * participant. If permission was revoked, then the track will no longer
     * be subscribed. If permission was granted, a TrackSubscribed event will
     * be emitted.
     *
     * args: (pub: [[RemoteTrackPublication]],
     *        status: [[TrackPublication.SubscriptionStatus]],
     *        participant: [[RemoteParticipant]])
     */
    RoomEvent["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
    /**
     * LiveKit will attempt to autoplay all audio tracks when you attach them to
     * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.
     * `Room.canPlayAudio` will indicate if audio playback is permitted.
     */
    RoomEvent["AudioPlaybackStatusChanged"] = "audioPlaybackChanged";
    /**
     * When we have encountered an error while attempting to create a track.
     * The errors take place in getUserMedia().
     * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.
     * [[getAudioCreateError]] and [[getVideoCreateError]] will indicate if it had
     * an error while creating the audio or video track respectively.
     *
     * args: (error: Error)
     */
    RoomEvent["MediaDevicesError"] = "mediaDevicesError";
})(RoomEvent = exports.RoomEvent || (exports.RoomEvent = {}));
var ParticipantEvent;
(function (ParticipantEvent) {
    /**
     * When a new track is published to room *after* the local
     * participant has joined. It will not fire for tracks that are already published.
     *
     * A track published doesn't mean the participant has subscribed to it. It's
     * simply reflecting the state of the room.
     *
     * args: ([[RemoteTrackPublication]])
     */
    ParticipantEvent["TrackPublished"] = "trackPublished";
    /**
     * Successfully subscribed to the [[RemoteParticipant]]'s track.
     * This event will **always** fire as long as new tracks are ready for use.
     *
     * args: ([[RemoteTrack]], [[RemoteTrackPublication]])
     */
    ParticipantEvent["TrackSubscribed"] = "trackSubscribed";
    /**
     * Could not subscribe to a track
     *
     * args: (track sid)
     */
    ParticipantEvent["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
    /**
     * A [[RemoteParticipant]] has unpublished a track
     *
     * args: ([[RemoteTrackPublication]])
     */
    ParticipantEvent["TrackUnpublished"] = "trackUnpublished";
    /**
     * A subscribed track is no longer available. Clients should listen to this
     * event and ensure they detach tracks.
     *
     * args: ([[RemoteTrack]], [[RemoteTrackPublication]])
     */
    ParticipantEvent["TrackUnsubscribed"] = "trackUnsubscribed";
    /**
     * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]
     *
     * args: ([[TrackPublication]])
     */
    ParticipantEvent["TrackMuted"] = "trackMuted";
    /**
     * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]
     *
     * args: ([[TrackPublication]])
     */
    ParticipantEvent["TrackUnmuted"] = "trackUnmuted";
    /**
     * A local track was published successfully. This event is helpful to know
     * when to update your local UI with the newly published track.
     *
     * args: ([[LocalTrackPublication]])
     */
    ParticipantEvent["LocalTrackPublished"] = "localTrackPublished";
    /**
     * A local track was unpublished. This event is helpful to know when to remove
     * the local track from your UI.
     *
     * When a user stops sharing their screen by pressing "End" on the browser UI,
     * this event will also fire.
     *
     * args: ([[LocalTrackPublication]])
     */
    ParticipantEvent["LocalTrackUnpublished"] = "localTrackUnpublished";
    /**
     * @deprecated Use ParticipantMetadataChanged instead
     * @internal
     */
    ParticipantEvent["MetadataChanged"] = "metadataChanged";
    /**
     * Participant metadata is a simple way for app-specific state to be pushed to
     * all users.
     * When RoomService.UpdateParticipantMetadata is called to change a participant's
     * state, *all*  participants in the room will fire this event.
     * To access the current metadata, see [[Participant.metadata]].
     *
     * args: (prevMetadata: string)
     *
     */
    ParticipantEvent["ParticipantMetadataChanged"] = "participantMetadataChanged";
    /**
     * Data received from this participant as sender.
     * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.
     * All participants in the room will receive the messages sent to the room.
     *
     * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])
     */
    ParticipantEvent["DataReceived"] = "dataReceived";
    /**
     * Has speaking status changed for the current participant
     *
     * args: (speaking: boolean)
     */
    ParticipantEvent["IsSpeakingChanged"] = "isSpeakingChanged";
    /**
     * Connection quality was changed for a Participant. It'll receive updates
     * from the local participant, as well as any [[RemoteParticipant]]s that we are
     * subscribed to.
     *
     * args: (connectionQuality: [[ConnectionQuality]])
     */
    ParticipantEvent["ConnectionQualityChanged"] = "connectionQualityChanged";
    /**
     * StreamState indicates if a subscribed track has been paused by the SFU
     * (typically this happens because of subscriber's bandwidth constraints)
     *
     * When bandwidth conditions allow, the track will be resumed automatically.
     * TrackStreamStateChanged will also be emitted when that happens.
     *
     * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])
     */
    ParticipantEvent["TrackStreamStateChanged"] = "trackStreamStateChanged";
    /**
     * One of subscribed tracks have changed its permissions for the current
     * participant. If permission was revoked, then the track will no longer
     * be subscribed. If permission was granted, a TrackSubscribed event will
     * be emitted.
     *
     * args: (pub: [[RemoteTrackPublication]],
     *        status: [[TrackPublication.SubscriptionStatus]])
     */
    ParticipantEvent["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
    // fired only on LocalParticipant
    /** @internal */
    ParticipantEvent["MediaDevicesError"] = "mediaDevicesError";
})(ParticipantEvent = exports.ParticipantEvent || (exports.ParticipantEvent = {}));
/** @internal */
var EngineEvent;
(function (EngineEvent) {
    EngineEvent["Connected"] = "connected";
    EngineEvent["Disconnected"] = "disconnected";
    EngineEvent["Resuming"] = "resuming";
    EngineEvent["Resumed"] = "resumed";
    EngineEvent["Restarting"] = "restarting";
    EngineEvent["Restarted"] = "restarted";
    EngineEvent["SignalResumed"] = "signalResumed";
    EngineEvent["MediaTrackAdded"] = "mediaTrackAdded";
    EngineEvent["ActiveSpeakersUpdate"] = "activeSpeakersUpdate";
    EngineEvent["DataPacketReceived"] = "dataPacketReceived";
})(EngineEvent = exports.EngineEvent || (exports.EngineEvent = {}));
var TrackEvent;
(function (TrackEvent) {
    TrackEvent["Message"] = "message";
    TrackEvent["Muted"] = "muted";
    TrackEvent["Unmuted"] = "unmuted";
    TrackEvent["Ended"] = "ended";
    /** @internal */
    TrackEvent["UpdateSettings"] = "updateSettings";
    /** @internal */
    TrackEvent["UpdateSubscription"] = "updateSubscription";
    /** @internal */
    TrackEvent["AudioPlaybackStarted"] = "audioPlaybackStarted";
    /** @internal */
    TrackEvent["AudioPlaybackFailed"] = "audioPlaybackFailed";
    /** @internal */
    TrackEvent["VisibilityChanged"] = "visibilityChanged";
    /** @internal */
    TrackEvent["VideoDimensionsChanged"] = "videoDimensionsChanged";
})(TrackEvent = exports.TrackEvent || (exports.TrackEvent = {}));
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/participant/LocalParticipant.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/participant/LocalParticipant.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ "./node_modules/livekit-client/dist/logger.js"));
const livekit_rtc_1 = __webpack_require__(/*! ../../proto/livekit_rtc */ "./node_modules/livekit-client/dist/proto/livekit_rtc.js");
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/livekit-client/dist/room/errors.js");
const events_1 = __webpack_require__(/*! ../events */ "./node_modules/livekit-client/dist/room/events.js");
const LocalAudioTrack_1 = __importDefault(__webpack_require__(/*! ../track/LocalAudioTrack */ "./node_modules/livekit-client/dist/room/track/LocalAudioTrack.js"));
const LocalTrackPublication_1 = __importDefault(__webpack_require__(/*! ../track/LocalTrackPublication */ "./node_modules/livekit-client/dist/room/track/LocalTrackPublication.js"));
const LocalVideoTrack_1 = __importStar(__webpack_require__(/*! ../track/LocalVideoTrack */ "./node_modules/livekit-client/dist/room/track/LocalVideoTrack.js"));
const options_1 = __webpack_require__(/*! ../track/options */ "./node_modules/livekit-client/dist/room/track/options.js");
const Track_1 = __webpack_require__(/*! ../track/Track */ "./node_modules/livekit-client/dist/room/track/Track.js");
const utils_1 = __webpack_require__(/*! ../track/utils */ "./node_modules/livekit-client/dist/room/track/utils.js");
const Participant_1 = __importDefault(__webpack_require__(/*! ./Participant */ "./node_modules/livekit-client/dist/room/participant/Participant.js"));
const ParticipantTrackPermission_1 = __webpack_require__(/*! ./ParticipantTrackPermission */ "./node_modules/livekit-client/dist/room/participant/ParticipantTrackPermission.js");
const publishUtils_1 = __webpack_require__(/*! ./publishUtils */ "./node_modules/livekit-client/dist/room/participant/publishUtils.js");
const RemoteParticipant_1 = __importDefault(__webpack_require__(/*! ./RemoteParticipant */ "./node_modules/livekit-client/dist/room/participant/RemoteParticipant.js"));
class LocalParticipant extends Participant_1.default {
    /** @internal */
    constructor(sid, identity, engine, options) {
        super(sid, identity);
        this.pendingPublishing = new Set();
        /** @internal */
        this.onTrackUnmuted = (track) => {
            this.onTrackMuted(track, false);
        };
        // when the local track changes in mute status, we'll notify server as such
        /** @internal */
        this.onTrackMuted = (track, muted) => {
            if (muted === undefined) {
                muted = true;
            }
            if (!track.sid) {
                logger_1.default.error('could not update mute status for unpublished track', track);
                return;
            }
            this.engine.updateMuteStatus(track.sid, muted);
        };
        this.handleSubscribedQualityUpdate = (update) => {
            var _a, _b;
            if (!((_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.dynacast)) {
                return;
            }
            const pub = this.videoTracks.get(update.trackSid);
            if (!pub) {
                logger_1.default.warn('handleSubscribedQualityUpdate', 'received subscribed quality update for unknown track', update.trackSid);
                return;
            }
            (_b = pub.videoTrack) === null || _b === void 0 ? void 0 : _b.setPublishingLayers(update.subscribedQualities);
        };
        this.onTrackUnpublish = (track) => {
            this.unpublishTrack(track);
        };
        this.audioTracks = new Map();
        this.videoTracks = new Map();
        this.tracks = new Map();
        this.engine = engine;
        this.roomOptions = options;
        this.engine.client.onRemoteMuteChanged = (trackSid, muted) => {
            const pub = this.tracks.get(trackSid);
            if (!pub || !pub.track) {
                return;
            }
            if (muted) {
                pub.mute();
            }
            else {
                pub.unmute();
            }
        };
        this.engine.client.onSubscribedQualityUpdate = this.handleSubscribedQualityUpdate;
    }
    get lastCameraError() {
        return this.cameraError;
    }
    get lastMicrophoneError() {
        return this.microphoneError;
    }
    getTrack(source) {
        const track = super.getTrack(source);
        if (track) {
            return track;
        }
    }
    getTrackByName(name) {
        const track = super.getTrackByName(name);
        if (track) {
            return track;
        }
    }
    /**
     * Enable or disable a participant's camera track.
     *
     * If a track has already published, it'll mute or unmute the track.
     */
    setCameraEnabled(enabled) {
        return this.setTrackEnabled(Track_1.Track.Source.Camera, enabled);
    }
    /**
     * Enable or disable a participant's microphone track.
     *
     * If a track has already published, it'll mute or unmute the track.
     */
    setMicrophoneEnabled(enabled) {
        return this.setTrackEnabled(Track_1.Track.Source.Microphone, enabled);
    }
    /**
     * Start or stop sharing a participant's screen
     */
    setScreenShareEnabled(enabled) {
        return this.setTrackEnabled(Track_1.Track.Source.ScreenShare, enabled);
    }
    /**
     * Enable or disable publishing for a track by source. This serves as a simple
     * way to manage the common tracks (camera, mic, or screen share)
     */
    setTrackEnabled(source, enabled) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.debug('setTrackEnabled', source, enabled);
            const track = this.getTrack(source);
            if (enabled) {
                if (track) {
                    yield track.unmute();
                }
                else {
                    let localTrack;
                    if (this.pendingPublishing.has(source)) {
                        logger_1.default.info('skipping duplicate published source', source);
                        // no-op it's already been requested
                        return;
                    }
                    this.pendingPublishing.add(source);
                    try {
                        switch (source) {
                            case Track_1.Track.Source.Camera:
                                [localTrack] = yield this.createTracks({
                                    video: true,
                                });
                                break;
                            case Track_1.Track.Source.Microphone:
                                [localTrack] = yield this.createTracks({
                                    audio: true,
                                });
                                break;
                            case Track_1.Track.Source.ScreenShare:
                                [localTrack] = yield this.createScreenTracks({ audio: false });
                                break;
                            default:
                                throw new errors_1.TrackInvalidError(source);
                        }
                        yield this.publishTrack(localTrack);
                    }
                    catch (e) {
                        if (e instanceof Error && !(e instanceof errors_1.TrackInvalidError)) {
                            this.emit(events_1.ParticipantEvent.MediaDevicesError, e);
                        }
                        throw e;
                    }
                    finally {
                        this.pendingPublishing.delete(source);
                    }
                }
            }
            else if (track && track.track) {
                // screenshare cannot be muted, unpublish instead
                if (source === Track_1.Track.Source.ScreenShare) {
                    this.unpublishTrack(track.track);
                }
                else {
                    yield track.mute();
                }
            }
        });
    }
    /**
     * Publish both camera and microphone at the same time. This is useful for
     * displaying a single Permission Dialog box to the end user.
     */
    enableCameraAndMicrophone() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pendingPublishing.has(Track_1.Track.Source.Camera)
                || this.pendingPublishing.has(Track_1.Track.Source.Microphone)) {
                // no-op it's already been requested
                return;
            }
            this.pendingPublishing.add(Track_1.Track.Source.Camera);
            this.pendingPublishing.add(Track_1.Track.Source.Microphone);
            try {
                const tracks = yield this.createTracks({
                    audio: true,
                    video: true,
                });
                yield Promise.all(tracks.map((track) => this.publishTrack(track)));
            }
            finally {
                this.pendingPublishing.delete(Track_1.Track.Source.Camera);
                this.pendingPublishing.delete(Track_1.Track.Source.Microphone);
            }
        });
    }
    /**
     * Create local camera and/or microphone tracks
     * @param options
     * @returns
     */
    createTracks(options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const opts = utils_1.mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);
            const constraints = utils_1.constraintsForOptions(opts);
            let stream;
            try {
                stream = yield navigator.mediaDevices.getUserMedia(constraints);
            }
            catch (err) {
                if (err instanceof Error) {
                    if (constraints.audio) {
                        this.microphoneError = err;
                    }
                    if (constraints.video) {
                        this.cameraError = err;
                    }
                }
                throw err;
            }
            if (constraints.audio) {
                this.microphoneError = undefined;
            }
            if (constraints.video) {
                this.cameraError = undefined;
            }
            return stream.getTracks().map((mediaStreamTrack) => {
                const isAudio = mediaStreamTrack.kind === 'audio';
                let trackOptions = isAudio ? options.audio : options.video;
                if (typeof trackOptions === 'boolean' || !trackOptions) {
                    trackOptions = {};
                }
                let trackConstraints;
                const conOrBool = isAudio ? constraints.audio : constraints.video;
                if (typeof conOrBool !== 'boolean') {
                    trackConstraints = conOrBool;
                }
                const track = publishUtils_1.mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);
                if (track.kind === Track_1.Track.Kind.Video) {
                    track.source = Track_1.Track.Source.Camera;
                }
                else if (track.kind === Track_1.Track.Kind.Audio) {
                    track.source = Track_1.Track.Source.Microphone;
                }
                return track;
            });
        });
    }
    /**
     * Creates a screen capture tracks with getDisplayMedia().
     * A LocalVideoTrack is always created and returned.
     * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
     */
    createScreenTracks(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (options === undefined) {
                options = {};
            }
            if (options.resolution === undefined) {
                options.resolution = options_1.VideoPresets.fhd.resolution;
            }
            let videoConstraints = true;
            if (options.resolution) {
                videoConstraints = {
                    width: options.resolution.width,
                    height: options.resolution.height,
                    frameRate: options.resolution.frameRate,
                };
            }
            // typescript definition is missing getDisplayMedia: https://github.com/microsoft/TypeScript/issues/33232
            // @ts-ignore
            const stream = yield navigator.mediaDevices.getDisplayMedia({
                audio: (_a = options.audio) !== null && _a !== void 0 ? _a : false,
                video: videoConstraints,
            });
            const tracks = stream.getVideoTracks();
            if (tracks.length === 0) {
                throw new errors_1.TrackInvalidError('no video track found');
            }
            const screenVideo = new LocalVideoTrack_1.default(tracks[0]);
            screenVideo.source = Track_1.Track.Source.ScreenShare;
            const localTracks = [screenVideo];
            if (stream.getAudioTracks().length > 0) {
                const screenAudio = new LocalAudioTrack_1.default(stream.getAudioTracks()[0]);
                screenAudio.source = Track_1.Track.Source.ScreenShareAudio;
                localTracks.push(screenAudio);
            }
            return localTracks;
        });
    }
    /**
     * Publish a new track to the room
     * @param track
     * @param options
     */
    publishTrack(track, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter(this, void 0, void 0, function* () {
            const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);
            // convert raw media track into audio or video track
            if (track instanceof MediaStreamTrack) {
                switch (track.kind) {
                    case 'audio':
                        track = new LocalAudioTrack_1.default(track);
                        break;
                    case 'video':
                        track = new LocalVideoTrack_1.default(track);
                        break;
                    default:
                        throw new errors_1.TrackInvalidError(`unsupported MediaStreamTrack kind ${track.kind}`);
                }
            }
            // is it already published? if so skip
            let existingPublication;
            this.tracks.forEach((publication) => {
                if (!publication.track) {
                    return;
                }
                if (publication.track === track) {
                    existingPublication = publication;
                }
            });
            if (existingPublication)
                return existingPublication;
            if (opts.source) {
                track.source = opts.source;
            }
            if (opts.stopMicTrackOnMute && track instanceof LocalAudioTrack_1.default) {
                track.stopOnMute = true;
            }
            // handle track actions
            track.on(events_1.TrackEvent.Muted, this.onTrackMuted);
            track.on(events_1.TrackEvent.Unmuted, this.onTrackUnmuted);
            track.on(events_1.TrackEvent.Ended, this.onTrackUnpublish);
            // create track publication from track
            const req = livekit_rtc_1.AddTrackRequest.fromPartial({
                // get local track id for use during publishing
                cid: track.mediaStreamTrack.id,
                name: options === null || options === void 0 ? void 0 : options.name,
                type: Track_1.Track.kindToProto(track.kind),
                muted: track.isMuted,
                source: Track_1.Track.sourceToProto(track.source),
                disableDtx: !((_b = opts === null || opts === void 0 ? void 0 : opts.dtx) !== null && _b !== void 0 ? _b : true),
            });
            // compute encodings and layers for video
            let encodings;
            if (track.kind === Track_1.Track.Kind.Video) {
                // TODO: support react native, which doesn't expose getSettings
                const settings = track.mediaStreamTrack.getSettings();
                const width = (_c = settings.width) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.width;
                const height = (_e = settings.height) !== null && _e !== void 0 ? _e : (_f = track.dimensions) === null || _f === void 0 ? void 0 : _f.height;
                // width and height should be defined for video
                req.width = width !== null && width !== void 0 ? width : 0;
                req.height = height !== null && height !== void 0 ? height : 0;
                encodings = publishUtils_1.computeVideoEncodings(track.source === Track_1.Track.Source.ScreenShare, width, height, opts);
                req.layers = LocalVideoTrack_1.videoLayersFromEncodings(req.width, req.height, encodings);
            }
            else if (track.kind === Track_1.Track.Kind.Audio && opts.audioBitrate) {
                encodings = [
                    {
                        maxBitrate: opts.audioBitrate,
                    },
                ];
            }
            const ti = yield this.engine.addTrack(req);
            const publication = new LocalTrackPublication_1.default(track.kind, ti, track);
            track.sid = ti.sid;
            if (!this.engine.publisher) {
                throw new errors_1.UnexpectedConnectionState('publisher is closed');
            }
            logger_1.default.debug(`publishing ${track.kind} with encodings`, encodings, ti);
            const transceiverInit = { direction: 'sendonly' };
            if (encodings) {
                transceiverInit.sendEncodings = encodings;
            }
            const transceiver = this.engine.publisher.pc.addTransceiver(track.mediaStreamTrack, transceiverInit);
            this.engine.negotiate();
            // store RTPSender
            track.sender = transceiver.sender;
            if (track instanceof LocalVideoTrack_1.default) {
                const disableLayerPause = (_h = (_g = this.roomOptions) === null || _g === void 0 ? void 0 : _g.expDisableLayerPause) !== null && _h !== void 0 ? _h : false;
                track.startMonitor(this.engine.client, disableLayerPause);
            }
            else if (track instanceof LocalAudioTrack_1.default) {
                track.startMonitor();
            }
            if (opts.videoCodec) {
                this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);
            }
            this.addTrackPublication(publication);
            // send event for publication
            this.emit(events_1.ParticipantEvent.LocalTrackPublished, publication);
            return publication;
        });
    }
    unpublishTrack(track, stopOnUnpublish) {
        var _a, _b;
        // look through all published tracks to find the right ones
        const publication = this.getPublicationForTrack(track);
        logger_1.default.debug('unpublishTrack', 'unpublishing track', track);
        if (!publication || !publication.track) {
            logger_1.default.warn('unpublishTrack', 'track was not unpublished because no publication was found', track);
            return null;
        }
        track = publication.track;
        track.off(events_1.TrackEvent.Muted, this.onTrackMuted);
        track.off(events_1.TrackEvent.Unmuted, this.onTrackUnmuted);
        track.off(events_1.TrackEvent.Ended, this.onTrackUnpublish);
        if (stopOnUnpublish === undefined) {
            stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;
        }
        if (stopOnUnpublish) {
            track.stop();
        }
        const { mediaStreamTrack } = track;
        if (this.engine.publisher) {
            const senders = this.engine.publisher.pc.getSenders();
            senders.forEach((sender) => {
                var _a;
                if (sender.track === mediaStreamTrack) {
                    try {
                        (_a = this.engine.publisher) === null || _a === void 0 ? void 0 : _a.pc.removeTrack(sender);
                        this.engine.negotiate();
                    }
                    catch (e) {
                        logger_1.default.warn('unpublishTrack', 'failed to remove track', e);
                    }
                }
            });
        }
        // remove from our maps
        this.tracks.delete(publication.trackSid);
        switch (publication.kind) {
            case Track_1.Track.Kind.Audio:
                this.audioTracks.delete(publication.trackSid);
                break;
            case Track_1.Track.Kind.Video:
                this.videoTracks.delete(publication.trackSid);
                break;
            default:
                break;
        }
        publication.setTrack(undefined);
        this.emit(events_1.ParticipantEvent.LocalTrackUnpublished, publication);
        return publication;
    }
    unpublishTracks(tracks) {
        const publications = [];
        tracks.forEach((track) => {
            const pub = this.unpublishTrack(track);
            if (pub) {
                publications.push(pub);
            }
        });
        return publications;
    }
    /**
     * Publish a new data payload to the room. Data will be forwarded to each
     * participant in the room if the destination argument is empty
     *
     * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode
     * @param kind whether to send this as reliable or lossy.
     * For data that you need delivery guarantee (such as chat messages), use Reliable.
     * For data that should arrive as quickly as possible, but you are ok with dropped
     * packets, use Lossy.
     * @param destination the participants who will receive the message
     */
    publishData(data, kind, destination) {
        return __awaiter(this, void 0, void 0, function* () {
            const dest = [];
            if (destination !== undefined) {
                destination.forEach((val) => {
                    if (val instanceof RemoteParticipant_1.default) {
                        dest.push(val.sid);
                    }
                    else {
                        dest.push(val);
                    }
                });
            }
            const packet = {
                kind,
                user: {
                    participantSid: this.sid,
                    payload: data,
                    destinationSids: dest,
                },
            };
            yield this.engine.sendDataPacket(packet, kind);
        });
    }
    /**
     * Control who can subscribe to LocalParticipant's published tracks.
     *
     * By default, all participants can subscribe. This allows fine-grained control over
     * who is able to subscribe at a participant and track level.
     *
     * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and
     * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks
     * will not grant permissions to any participants and will require a subsequent
     * permissions update to allow subscription.
     *
     * @param allParticipantsAllowed Allows all participants to subscribe all tracks.
     *  Takes precedence over [[participantTrackPermissions]] if set to true.
     *  By default this is set to true.
     * @param participantTrackPermissions Full list of individual permissions per
     *  participant/track. Any omitted participants will not receive any permissions.
     */
    setTrackSubscriptionPermissions(allParticipantsAllowed, participantTrackPermissions = []) {
        this.engine.client.sendUpdateSubscriptionPermissions(allParticipantsAllowed, participantTrackPermissions.map((p) => ParticipantTrackPermission_1.trackPermissionToProto(p)));
    }
    getPublicationForTrack(track) {
        let publication;
        this.tracks.forEach((pub) => {
            const localTrack = pub.track;
            if (!localTrack) {
                return;
            }
            // this looks overly complicated due to this object tree
            if (track instanceof MediaStreamTrack) {
                if (localTrack instanceof LocalAudioTrack_1.default
                    || localTrack instanceof LocalVideoTrack_1.default) {
                    if (localTrack.mediaStreamTrack === track) {
                        publication = pub;
                    }
                }
            }
            else if (track === localTrack) {
                publication = pub;
            }
        });
        return publication;
    }
    setPreferredCodec(transceiver, kind, videoCodec) {
        if (!('getCapabilities' in RTCRtpSender)) {
            return;
        }
        const cap = RTCRtpSender.getCapabilities(kind);
        if (!cap)
            return;
        const selected = cap.codecs.find((c) => {
            const codec = c.mimeType.toLowerCase();
            const matchesVideoCodec = codec === `video/${videoCodec}`;
            // for h264 codecs that have sdpFmtpLine available, use only if the
            // profile-level-id is 42e01f for cross-browser compatibility
            if (videoCodec === 'h264' && c.sdpFmtpLine) {
                return matchesVideoCodec && c.sdpFmtpLine.includes('profile-level-id=42e01f');
            }
            return matchesVideoCodec || codec === 'audio/opus';
        });
        if (selected && 'setCodecPreferences' in transceiver) {
            // @ts-ignore
            transceiver.setCodecPreferences([selected]);
        }
    }
    /** @internal */
    publishedTracksInfo() {
        const infos = [];
        this.tracks.forEach((track) => {
            if (track.track !== undefined) {
                infos.push({
                    cid: track.track.mediaStreamTrack.id,
                    track: track.trackInfo,
                });
            }
        });
        return infos;
    }
}
exports["default"] = LocalParticipant;
//# sourceMappingURL=LocalParticipant.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/participant/Participant.js":
/*!**************************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/participant/Participant.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionQuality = void 0;
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const livekit_models_1 = __webpack_require__(/*! ../../proto/livekit_models */ "./node_modules/livekit-client/dist/proto/livekit_models.js");
const events_2 = __webpack_require__(/*! ../events */ "./node_modules/livekit-client/dist/room/events.js");
const Track_1 = __webpack_require__(/*! ../track/Track */ "./node_modules/livekit-client/dist/room/track/Track.js");
var ConnectionQuality;
(function (ConnectionQuality) {
    ConnectionQuality["Excellent"] = "excellent";
    ConnectionQuality["Good"] = "good";
    ConnectionQuality["Poor"] = "poor";
    ConnectionQuality["Unknown"] = "unknown";
})(ConnectionQuality = exports.ConnectionQuality || (exports.ConnectionQuality = {}));
function qualityFromProto(q) {
    switch (q) {
        case livekit_models_1.ConnectionQuality.EXCELLENT:
            return ConnectionQuality.Excellent;
        case livekit_models_1.ConnectionQuality.GOOD:
            return ConnectionQuality.Good;
        case livekit_models_1.ConnectionQuality.POOR:
            return ConnectionQuality.Poor;
        default:
            return ConnectionQuality.Unknown;
    }
}
class Participant extends events_1.EventEmitter {
    /** @internal */
    constructor(sid, identity) {
        super();
        /** audio level between 0-1.0, 1 being loudest, 0 being softest */
        this.audioLevel = 0;
        /** if participant is currently speaking */
        this.isSpeaking = false;
        this._connectionQuality = ConnectionQuality.Unknown;
        this.sid = sid;
        this.identity = identity;
        this.audioTracks = new Map();
        this.videoTracks = new Map();
        this.tracks = new Map();
    }
    getTracks() {
        return Array.from(this.tracks.values());
    }
    /**
     * Finds the first track that matches the source filter, for example, getting
     * the user's camera track with getTrackBySource(Track.Source.Camera).
     * @param source
     * @returns
     */
    getTrack(source) {
        if (source === Track_1.Track.Source.Unknown) {
            return;
        }
        for (const [, pub] of this.tracks) {
            if (pub.source === source) {
                return pub;
            }
            if (pub.source === Track_1.Track.Source.Unknown) {
                if (source === Track_1.Track.Source.Microphone && pub.kind === Track_1.Track.Kind.Audio && pub.trackName !== 'screen') {
                    return pub;
                }
                if (source === Track_1.Track.Source.Camera && pub.kind === Track_1.Track.Kind.Video && pub.trackName !== 'screen') {
                    return pub;
                }
                if (source === Track_1.Track.Source.ScreenShare && pub.kind === Track_1.Track.Kind.Video && pub.trackName === 'screen') {
                    return pub;
                }
                if (source === Track_1.Track.Source.ScreenShareAudio && pub.kind === Track_1.Track.Kind.Audio && pub.trackName === 'screen') {
                    return pub;
                }
            }
        }
    }
    /**
     * Finds the first track that matches the track's name.
     * @param name
     * @returns
     */
    getTrackByName(name) {
        for (const [, pub] of this.tracks) {
            if (pub.trackName === name) {
                return pub;
            }
        }
    }
    get connectionQuality() {
        return this._connectionQuality;
    }
    get isCameraEnabled() {
        var _a;
        const track = this.getTrack(Track_1.Track.Source.Camera);
        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);
    }
    get isMicrophoneEnabled() {
        var _a;
        const track = this.getTrack(Track_1.Track.Source.Microphone);
        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);
    }
    get isScreenShareEnabled() {
        const track = this.getTrack(Track_1.Track.Source.ScreenShare);
        return !!track;
    }
    /** when participant joined the room */
    get joinedAt() {
        if (this.participantInfo) {
            return new Date(this.participantInfo.joinedAt * 1000);
        }
        return new Date();
    }
    /** @internal */
    updateInfo(info) {
        this.identity = info.identity;
        this.sid = info.sid;
        this.name = info.name;
        this.setMetadata(info.metadata);
        // set this last so setMetadata can detect changes
        this.participantInfo = info;
    }
    /** @internal */
    setMetadata(md) {
        const changed = !this.participantInfo || this.participantInfo.metadata !== md;
        const prevMetadata = this.metadata;
        this.metadata = md;
        if (changed) {
            this.emit(events_2.ParticipantEvent.MetadataChanged, prevMetadata, this);
            this.emit(events_2.ParticipantEvent.ParticipantMetadataChanged, prevMetadata, this);
        }
    }
    /** @internal */
    setIsSpeaking(speaking) {
        if (speaking === this.isSpeaking) {
            return;
        }
        this.isSpeaking = speaking;
        if (speaking) {
            this.lastSpokeAt = new Date();
        }
        this.emit(events_2.ParticipantEvent.IsSpeakingChanged, speaking);
    }
    /** @internal */
    setConnectionQuality(q) {
        const prevQuality = this._connectionQuality;
        this._connectionQuality = qualityFromProto(q);
        if (prevQuality !== this._connectionQuality) {
            this.emit(events_2.ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);
        }
    }
    addTrackPublication(publication) {
        // forward publication driven events
        publication.on(events_2.TrackEvent.Muted, () => {
            this.emit(events_2.ParticipantEvent.TrackMuted, publication);
        });
        publication.on(events_2.TrackEvent.Unmuted, () => {
            this.emit(events_2.ParticipantEvent.TrackUnmuted, publication);
        });
        const pub = publication;
        if (pub.track) {
            pub.track.sid = publication.trackSid;
        }
        this.tracks.set(publication.trackSid, publication);
        switch (publication.kind) {
            case Track_1.Track.Kind.Audio:
                this.audioTracks.set(publication.trackSid, publication);
                break;
            case Track_1.Track.Kind.Video:
                this.videoTracks.set(publication.trackSid, publication);
                break;
            default:
                break;
        }
    }
}
exports["default"] = Participant;
//# sourceMappingURL=Participant.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/participant/ParticipantTrackPermission.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/participant/ParticipantTrackPermission.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.trackPermissionToProto = void 0;
function trackPermissionToProto(perms) {
    var _a;
    if (!perms.participantSid) {
        throw new Error('Invalid track permission, missing participantSid');
    }
    return {
        participantSid: perms.participantSid,
        allTracks: (_a = perms.allowAll) !== null && _a !== void 0 ? _a : false,
        trackSids: perms.allowedTrackSids || [],
    };
}
exports.trackPermissionToProto = trackPermissionToProto;
//# sourceMappingURL=ParticipantTrackPermission.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/participant/RemoteParticipant.js":
/*!********************************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/participant/RemoteParticipant.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ "./node_modules/livekit-client/dist/logger.js"));
const events_1 = __webpack_require__(/*! ../events */ "./node_modules/livekit-client/dist/room/events.js");
const RemoteAudioTrack_1 = __importDefault(__webpack_require__(/*! ../track/RemoteAudioTrack */ "./node_modules/livekit-client/dist/room/track/RemoteAudioTrack.js"));
const RemoteTrackPublication_1 = __importDefault(__webpack_require__(/*! ../track/RemoteTrackPublication */ "./node_modules/livekit-client/dist/room/track/RemoteTrackPublication.js"));
const RemoteVideoTrack_1 = __importDefault(__webpack_require__(/*! ../track/RemoteVideoTrack */ "./node_modules/livekit-client/dist/room/track/RemoteVideoTrack.js"));
const Track_1 = __webpack_require__(/*! ../track/Track */ "./node_modules/livekit-client/dist/room/track/Track.js");
const Participant_1 = __importDefault(__webpack_require__(/*! ./Participant */ "./node_modules/livekit-client/dist/room/participant/Participant.js"));
class RemoteParticipant extends Participant_1.default {
    /** @internal */
    constructor(signalClient, id, name) {
        super(id, name || '');
        this.signalClient = signalClient;
        this.tracks = new Map();
        this.audioTracks = new Map();
        this.videoTracks = new Map();
    }
    /** @internal */
    static fromParticipantInfo(signalClient, pi) {
        const rp = new RemoteParticipant(signalClient, pi.sid, pi.identity);
        rp.updateInfo(pi);
        return rp;
    }
    addTrackPublication(publication) {
        super.addTrackPublication(publication);
        // register action events
        publication.on(events_1.TrackEvent.UpdateSettings, (settings) => {
            this.signalClient.sendUpdateTrackSettings(settings);
        });
        publication.on(events_1.TrackEvent.UpdateSubscription, (sub) => {
            sub.participantTracks.forEach((pt) => {
                pt.participantSid = this.sid;
            });
            this.signalClient.sendUpdateSubscription(sub);
        });
        publication.on(events_1.TrackEvent.Ended, (track) => {
            this.emit(events_1.ParticipantEvent.TrackUnsubscribed, track, publication);
        });
    }
    getTrack(source) {
        const track = super.getTrack(source);
        if (track) {
            return track;
        }
    }
    getTrackByName(name) {
        const track = super.getTrackByName(name);
        if (track) {
            return track;
        }
    }
    /** @internal */
    addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStream, triesLeft) {
        // find the track publication
        // it's possible for the media track to arrive before participant info
        let publication = this.getTrackPublication(sid);
        // it's also possible that the browser didn't honor our original track id
        // FireFox would use its own local uuid instead of server track id
        if (!publication) {
            if (!sid.startsWith('TR')) {
                // find the first track that matches type
                this.tracks.forEach((p) => {
                    if (!publication && mediaTrack.kind === p.kind.toString()) {
                        publication = p;
                    }
                });
            }
        }
        // when we couldn't locate the track, it's possible that the metadata hasn't
        // yet arrived. Wait a bit longer for it to arrive, or fire an error
        if (!publication) {
            if (triesLeft === 0) {
                logger_1.default.error('could not find published track', this.sid, sid);
                this.emit(events_1.ParticipantEvent.TrackSubscriptionFailed, sid);
                return;
            }
            if (triesLeft === undefined)
                triesLeft = 20;
            setTimeout(() => {
                this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStream, triesLeft - 1);
            }, 150);
            return;
        }
        const isVideo = mediaTrack.kind === 'video';
        let track;
        if (isVideo) {
            track = new RemoteVideoTrack_1.default(mediaTrack, sid, receiver, adaptiveStream);
        }
        else {
            track = new RemoteAudioTrack_1.default(mediaTrack, sid, receiver);
        }
        // set track info
        track.source = publication.source;
        // keep publication's muted status
        track.isMuted = publication.isMuted;
        track.setMediaStream(mediaStream);
        track.start();
        publication.setTrack(track);
        this.emit(events_1.ParticipantEvent.TrackSubscribed, track, publication);
        return publication;
    }
    /** @internal */
    get hasMetadata() {
        return !!this.participantInfo;
    }
    getTrackPublication(sid) {
        return this.tracks.get(sid);
    }
    /** @internal */
    updateInfo(info) {
        const alreadyHasMetadata = this.hasMetadata;
        super.updateInfo(info);
        // we are getting a list of all available tracks, reconcile in here
        // and send out events for changes
        // reconcile track publications, publish events only if metadata is already there
        // i.e. changes since the local participant has joined
        const validTracks = new Map();
        const newTracks = new Map();
        info.tracks.forEach((ti) => {
            let publication = this.getTrackPublication(ti.sid);
            if (!publication) {
                // new publication
                const kind = Track_1.Track.kindFromProto(ti.type);
                if (!kind) {
                    return;
                }
                publication = new RemoteTrackPublication_1.default(kind, ti.sid, ti.name);
                publication.updateInfo(ti);
                newTracks.set(ti.sid, publication);
                this.addTrackPublication(publication);
            }
            else {
                publication.updateInfo(ti);
            }
            validTracks.set(ti.sid, publication);
        });
        // send new tracks
        if (alreadyHasMetadata) {
            newTracks.forEach((publication) => {
                this.emit(events_1.ParticipantEvent.TrackPublished, publication);
            });
        }
        // detect removed tracks
        this.tracks.forEach((publication) => {
            if (!validTracks.has(publication.trackSid)) {
                this.unpublishTrack(publication.trackSid, true);
            }
        });
    }
    /** @internal */
    unpublishTrack(sid, sendUnpublish) {
        const publication = this.tracks.get(sid);
        if (!publication) {
            return;
        }
        this.tracks.delete(sid);
        // remove from the right type map
        switch (publication.kind) {
            case Track_1.Track.Kind.Audio:
                this.audioTracks.delete(sid);
                break;
            case Track_1.Track.Kind.Video:
                this.videoTracks.delete(sid);
                break;
            default:
                break;
        }
        // also send unsubscribe, if track is actively subscribed
        const { track } = publication;
        if (track) {
            const { isSubscribed } = publication;
            track.stop();
            publication.setTrack(undefined);
            // always send unsubscribed, since apps may rely on this
            if (isSubscribed) {
                this.emit(events_1.ParticipantEvent.TrackUnsubscribed, track, publication);
            }
        }
        if (sendUnpublish) {
            this.emit(events_1.ParticipantEvent.TrackUnpublished, publication);
        }
    }
    /** @internal */
    emit(event, ...args) {
        logger_1.default.trace('participant event', this.sid, event, ...args);
        return super.emit(event, ...args);
    }
}
exports["default"] = RemoteParticipant;
//# sourceMappingURL=RemoteParticipant.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/participant/publishUtils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/participant/publishUtils.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.presetsForResolution = exports.determineAppropriateEncoding = exports.computeVideoEncodings = exports.presetsScreenShare = exports.presets43 = exports.presets169 = exports.mediaTrackToLocalTrack = void 0;
const logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ "./node_modules/livekit-client/dist/logger.js"));
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/livekit-client/dist/room/errors.js");
const LocalAudioTrack_1 = __importDefault(__webpack_require__(/*! ../track/LocalAudioTrack */ "./node_modules/livekit-client/dist/room/track/LocalAudioTrack.js"));
const LocalVideoTrack_1 = __importDefault(__webpack_require__(/*! ../track/LocalVideoTrack */ "./node_modules/livekit-client/dist/room/track/LocalVideoTrack.js"));
const options_1 = __webpack_require__(/*! ../track/options */ "./node_modules/livekit-client/dist/room/track/options.js");
/** @internal */
function mediaTrackToLocalTrack(mediaStreamTrack, constraints) {
    switch (mediaStreamTrack.kind) {
        case 'audio':
            return new LocalAudioTrack_1.default(mediaStreamTrack, constraints);
        case 'video':
            return new LocalVideoTrack_1.default(mediaStreamTrack, constraints);
        default:
            throw new errors_1.TrackInvalidError(`unsupported track type: ${mediaStreamTrack.kind}`);
    }
}
exports.mediaTrackToLocalTrack = mediaTrackToLocalTrack;
/* @internal */
exports.presets169 = [
    options_1.VideoPresets.qvga,
    options_1.VideoPresets.vga,
    options_1.VideoPresets.qhd,
    options_1.VideoPresets.hd,
    options_1.VideoPresets.fhd,
];
/* @internal */
exports.presets43 = [
    options_1.VideoPresets43.qvga,
    options_1.VideoPresets43.vga,
    options_1.VideoPresets43.qhd,
    options_1.VideoPresets43.hd,
    options_1.VideoPresets43.fhd,
];
/* @internal */
exports.presetsScreenShare = [
    options_1.ScreenSharePresets.vga,
    options_1.ScreenSharePresets.hd_8,
    options_1.ScreenSharePresets.hd_15,
    options_1.ScreenSharePresets.fhd_15,
    options_1.ScreenSharePresets.fhd_30,
];
const videoRids = ['q', 'h', 'f'];
/* @internal */
function computeVideoEncodings(isScreenShare, width, height, options) {
    let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;
    if (isScreenShare) {
        videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;
    }
    const useSimulcast = !isScreenShare && (options === null || options === void 0 ? void 0 : options.simulcast);
    if ((!videoEncoding && !useSimulcast) || !width || !height) {
        // when we aren't simulcasting, will need to return a single encoding without
        // capping bandwidth. we always require a encoding for dynacast
        return [{}];
    }
    if (!videoEncoding) {
        // find the right encoding based on width/height
        videoEncoding = determineAppropriateEncoding(isScreenShare, width, height);
        logger_1.default.debug('using video encoding', videoEncoding);
    }
    if (!useSimulcast) {
        return [videoEncoding];
    }
    const presets = presetsForResolution(isScreenShare, width, height);
    let midPreset;
    const lowPreset = presets[0];
    if (presets.length > 1) {
        [, midPreset] = presets;
    }
    const original = new options_1.VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate);
    // NOTE:
    //   1. Ordering of these encodings is important. Chrome seems
    //      to use the index into encodings to decide which layer
    //      to disable when CPU constrained.
    //      So encodings should be ordered in increasing spatial
    //      resolution order.
    //   2. ion-sfu translates rids into layers. So, all encodings
    //      should have the base layer `q` and then more added
    //      based on other conditions.
    const size = Math.max(width, height);
    if (size >= 960 && midPreset) {
        return encodingsFromPresets(width, height, [
            lowPreset, midPreset, original,
        ]);
    }
    if (size >= 500) {
        return encodingsFromPresets(width, height, [
            lowPreset, original,
        ]);
    }
    return encodingsFromPresets(width, height, [
        original,
    ]);
}
exports.computeVideoEncodings = computeVideoEncodings;
/* @internal */
function determineAppropriateEncoding(isScreenShare, width, height) {
    const presets = presetsForResolution(isScreenShare, width, height);
    let { encoding } = presets[0];
    // handle portrait by swapping dimensions
    const size = Math.max(width, height);
    for (let i = 0; i < presets.length; i += 1) {
        const preset = presets[i];
        encoding = preset.encoding;
        if (preset.width >= size) {
            break;
        }
    }
    return encoding;
}
exports.determineAppropriateEncoding = determineAppropriateEncoding;
/* @internal */
function presetsForResolution(isScreenShare, width, height) {
    if (isScreenShare) {
        return exports.presetsScreenShare;
    }
    const aspect = width > height ? width / height : height / width;
    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {
        return exports.presets169;
    }
    return exports.presets43;
}
exports.presetsForResolution = presetsForResolution;
// presets should be ordered by low, medium, high
function encodingsFromPresets(width, height, presets) {
    const encodings = [];
    presets.forEach((preset, idx) => {
        if (idx >= videoRids.length) {
            return;
        }
        const size = Math.min(width, height);
        const rid = videoRids[idx];
        encodings.push({
            rid,
            scaleResolutionDownBy: size / Math.min(preset.width, preset.height),
            maxBitrate: preset.encoding.maxBitrate,
            /* @ts-ignore */
            maxFramerate: preset.encoding.maxFramerate,
        });
    });
    return encodings;
}
//# sourceMappingURL=publishUtils.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/stats.js":
/*!********************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/stats.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.computeBitrate = exports.monitorFrequency = void 0;
exports.monitorFrequency = 2000;
function computeBitrate(currentStats, prevStats) {
    if (!prevStats) {
        return 0;
    }
    let bytesNow;
    let bytesPrev;
    if ('bytesReceived' in currentStats) {
        bytesNow = currentStats.bytesReceived;
        bytesPrev = prevStats.bytesReceived;
    }
    else if ('bytesSent' in currentStats) {
        bytesNow = currentStats.bytesSent;
        bytesPrev = prevStats.bytesSent;
    }
    if (bytesNow === undefined || bytesPrev === undefined
        || currentStats.timestamp === undefined || prevStats.timestamp === undefined) {
        return 0;
    }
    return ((bytesNow - bytesPrev) * 8 * 1000) / (currentStats.timestamp - prevStats.timestamp);
}
exports.computeBitrate = computeBitrate;
//# sourceMappingURL=stats.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/LocalAudioTrack.js":
/*!************************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/LocalAudioTrack.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ "./node_modules/livekit-client/dist/logger.js"));
const stats_1 = __webpack_require__(/*! ../stats */ "./node_modules/livekit-client/dist/room/stats.js");
const LocalTrack_1 = __importDefault(__webpack_require__(/*! ./LocalTrack */ "./node_modules/livekit-client/dist/room/track/LocalTrack.js"));
const Track_1 = __webpack_require__(/*! ./Track */ "./node_modules/livekit-client/dist/room/track/Track.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/livekit-client/dist/room/track/utils.js");
class LocalAudioTrack extends LocalTrack_1.default {
    constructor(mediaTrack, constraints) {
        super(mediaTrack, Track_1.Track.Kind.Audio, constraints);
        /** @internal */
        this.stopOnMute = false;
        this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.sender) {
                this._currentBitrate = 0;
                return;
            }
            const stats = yield this.getSenderStats();
            if (stats && this.prevStats) {
                this._currentBitrate = stats_1.computeBitrate(stats, this.prevStats);
            }
            this.prevStats = stats;
            setTimeout(() => {
                this.monitorSender();
            }, stats_1.monitorFrequency);
        });
    }
    setDeviceId(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.constraints.deviceId === deviceId) {
                return;
            }
            this.constraints.deviceId = deviceId;
            if (!this.isMuted) {
                yield this.restartTrack();
            }
        });
    }
    mute() {
        const _super = Object.create(null, {
            mute: { get: () => super.mute }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // disabled special handling as it will cause BT headsets to switch communication modes
            if (this.source === Track_1.Track.Source.Microphone && this.stopOnMute) {
                logger_1.default.debug('stopping mic track');
                // also stop the track, so that microphone indicator is turned off
                this.mediaStreamTrack.stop();
            }
            yield _super.mute.call(this);
            return this;
        });
    }
    unmute() {
        const _super = Object.create(null, {
            unmute: { get: () => super.unmute }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.source === Track_1.Track.Source.Microphone && this.stopOnMute) {
                logger_1.default.debug('reacquiring mic track');
                yield this.restartTrack();
            }
            yield _super.unmute.call(this);
            return this;
        });
    }
    restartTrack(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let constraints;
            if (options) {
                const streamConstraints = utils_1.constraintsForOptions({ audio: options });
                if (typeof streamConstraints.audio !== 'boolean') {
                    constraints = streamConstraints.audio;
                }
            }
            yield this.restart(constraints);
        });
    }
    /* @internal */
    startMonitor() {
        setTimeout(() => {
            this.monitorSender();
        }, stats_1.monitorFrequency);
    }
    getSenderStats() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sender) {
                return undefined;
            }
            const stats = yield this.sender.getStats();
            let audioStats;
            stats.forEach((v) => {
                if (v.type === 'outbound-rtp') {
                    audioStats = {
                        type: 'audio',
                        streamId: v.id,
                        packetsSent: v.packetsSent,
                        packetsLost: v.packetsLost,
                        bytesSent: v.bytesSent,
                        timestamp: v.timestamp,
                        roundTripTime: v.roundTripTime,
                        jitter: v.jitter,
                    };
                }
            });
            return audioStats;
        });
    }
}
exports["default"] = LocalAudioTrack;
//# sourceMappingURL=LocalAudioTrack.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/LocalTrack.js":
/*!*******************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/LocalTrack.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ "./node_modules/livekit-client/dist/logger.js"));
const DeviceManager_1 = __importDefault(__webpack_require__(/*! ../DeviceManager */ "./node_modules/livekit-client/dist/room/DeviceManager.js"));
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/livekit-client/dist/room/errors.js");
const events_1 = __webpack_require__(/*! ../events */ "./node_modules/livekit-client/dist/room/events.js");
const Track_1 = __webpack_require__(/*! ./Track */ "./node_modules/livekit-client/dist/room/track/Track.js");
class LocalTrack extends Track_1.Track {
    constructor(mediaTrack, kind, constraints) {
        super(mediaTrack, kind);
        this.handleEnded = () => {
            this.emit(events_1.TrackEvent.Ended, this);
        };
        this.mediaStreamTrack.addEventListener('ended', this.handleEnded);
        this.constraints = constraints !== null && constraints !== void 0 ? constraints : mediaTrack.getConstraints();
    }
    get id() {
        return this.mediaStreamTrack.id;
    }
    get dimensions() {
        if (this.kind !== Track_1.Track.Kind.Video) {
            return undefined;
        }
        const { width, height } = this.mediaStreamTrack.getSettings();
        if (width && height) {
            return {
                width,
                height,
            };
        }
        return undefined;
    }
    /**
     * @returns DeviceID of the device that is currently being used for this track
     */
    getDeviceId() {
        return __awaiter(this, void 0, void 0, function* () {
            // screen share doesn't have a usable device id
            if (this.source === Track_1.Track.Source.ScreenShare) {
                return;
            }
            const { deviceId, groupId } = this.mediaStreamTrack.getSettings();
            const kind = this.kind === Track_1.Track.Kind.Audio ? 'audioinput' : 'videoinput';
            return DeviceManager_1.default.getInstance().normalizeDeviceId(kind, deviceId, groupId);
        });
    }
    mute() {
        return __awaiter(this, void 0, void 0, function* () {
            this.setTrackMuted(true);
            return this;
        });
    }
    unmute() {
        return __awaiter(this, void 0, void 0, function* () {
            this.setTrackMuted(false);
            return this;
        });
    }
    restart(constraints) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sender) {
                throw new errors_1.TrackInvalidError('unable to restart an unpublished track');
            }
            if (!constraints) {
                constraints = this.constraints;
            }
            logger_1.default.debug('restarting track with constraints', constraints);
            const streamConstraints = {
                audio: false,
                video: false,
            };
            if (this.kind === Track_1.Track.Kind.Video) {
                streamConstraints.video = constraints;
            }
            else {
                streamConstraints.audio = constraints;
            }
            // detach
            this.attachedElements.forEach((el) => {
                Track_1.detachTrack(this.mediaStreamTrack, el);
            });
            this.mediaStreamTrack.removeEventListener('ended', this.handleEnded);
            // on Safari, the old audio track must be stopped before attempting to acquire
            // the new track, otherwise the new track will stop with
            // 'A MediaStreamTrack ended due to a capture failure`
            this.mediaStreamTrack.stop();
            // create new track and attach
            const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);
            const newTrack = mediaStream.getTracks()[0];
            newTrack.addEventListener('ended', this.handleEnded);
            logger_1.default.debug('re-acquired MediaStreamTrack');
            yield this.sender.replaceTrack(newTrack);
            this.mediaStreamTrack = newTrack;
            this.attachedElements.forEach((el) => {
                Track_1.attachToElement(newTrack, el);
            });
            this.constraints = constraints;
            return this;
        });
    }
    setTrackMuted(muted) {
        if (this.isMuted === muted) {
            return;
        }
        this.isMuted = muted;
        this.mediaStreamTrack.enabled = !muted;
        this.emit(muted ? events_1.TrackEvent.Muted : events_1.TrackEvent.Unmuted, this);
    }
}
exports["default"] = LocalTrack;
//# sourceMappingURL=LocalTrack.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/LocalTrackPublication.js":
/*!******************************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/LocalTrackPublication.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(/*! ../events */ "./node_modules/livekit-client/dist/room/events.js");
const TrackPublication_1 = __webpack_require__(/*! ./TrackPublication */ "./node_modules/livekit-client/dist/room/track/TrackPublication.js");
class LocalTrackPublication extends TrackPublication_1.TrackPublication {
    constructor(kind, ti, track) {
        super(kind, ti.sid, ti.name);
        this.handleTrackEnded = (track) => {
            this.emit(events_1.TrackEvent.Ended, track);
        };
        this.updateInfo(ti);
        this.setTrack(track);
    }
    setTrack(track) {
        if (this.track) {
            this.track.off(events_1.TrackEvent.Ended, this.handleTrackEnded);
        }
        super.setTrack(track);
        if (track) {
            track.on(events_1.TrackEvent.Ended, this.handleTrackEnded);
        }
    }
    get isMuted() {
        if (this.track) {
            return this.track.isMuted;
        }
        return super.isMuted;
    }
    get audioTrack() {
        return super.audioTrack;
    }
    get videoTrack() {
        return super.videoTrack;
    }
    /**
     * Mute the track associated with this publication
     */
    mute() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();
        });
    }
    /**
     * Unmute track associated with this publication
     */
    unmute() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();
        });
    }
}
exports["default"] = LocalTrackPublication;
//# sourceMappingURL=LocalTrackPublication.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/LocalVideoTrack.js":
/*!************************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/LocalVideoTrack.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.videoLayersFromEncodings = exports.videoQualityForRid = void 0;
const logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ "./node_modules/livekit-client/dist/logger.js"));
const livekit_models_1 = __webpack_require__(/*! ../../proto/livekit_models */ "./node_modules/livekit-client/dist/proto/livekit_models.js");
const stats_1 = __webpack_require__(/*! ../stats */ "./node_modules/livekit-client/dist/room/stats.js");
const utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/livekit-client/dist/room/utils.js");
const LocalTrack_1 = __importDefault(__webpack_require__(/*! ./LocalTrack */ "./node_modules/livekit-client/dist/room/track/LocalTrack.js"));
const Track_1 = __webpack_require__(/*! ./Track */ "./node_modules/livekit-client/dist/room/track/Track.js");
const utils_2 = __webpack_require__(/*! ./utils */ "./node_modules/livekit-client/dist/room/track/utils.js");
// delay before attempting to upgrade
const QUALITY_UPGRADE_DELAY = 60 * 1000;
// avoid downgrading too quickly
const QUALITY_DOWNGRADE_DELAY = 5 * 1000;
const ridOrder = ['q', 'h', 'f'];
class LocalVideoTrack extends LocalTrack_1.default {
    constructor(mediaTrack, constraints) {
        super(mediaTrack, Track_1.Track.Kind.Video, constraints);
        this.monitorSender = (disableLayerPause) => __awaiter(this, void 0, void 0, function* () {
            if (!this.sender) {
                this._currentBitrate = 0;
                return;
            }
            const stats = yield this.getSenderStats();
            const statsMap = new Map(stats.map((s) => [s.rid, s]));
            if (!disableLayerPause && this.prevStats && this.isSimulcast) {
                this.checkAndUpdateSimulcast(statsMap);
            }
            if (this.prevStats) {
                let totalBitrate = 0;
                statsMap.forEach((s, key) => {
                    var _a;
                    const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);
                    totalBitrate += stats_1.computeBitrate(s, prev);
                });
                this._currentBitrate = totalBitrate;
            }
            this.prevStats = statsMap;
            setTimeout(() => {
                this.monitorSender(disableLayerPause);
            }, stats_1.monitorFrequency);
        });
    }
    get isSimulcast() {
        if (this.sender && this.sender.getParameters().encodings.length > 1) {
            return true;
        }
        return false;
    }
    /* @internal */
    startMonitor(signalClient, disableLayerPause) {
        var _a;
        this.signalClient = signalClient;
        // save original encodings
        const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();
        if (params) {
            this.encodings = params.encodings;
        }
        setTimeout(() => {
            this.monitorSender(disableLayerPause);
        }, stats_1.monitorFrequency);
    }
    stop() {
        this.sender = undefined;
        this.mediaStreamTrack.getConstraints();
        super.stop();
    }
    mute() {
        const _super = Object.create(null, {
            mute: { get: () => super.mute }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.source === Track_1.Track.Source.Camera) {
                logger_1.default.debug('stopping camera track');
                // also stop the track, so that camera indicator is turned off
                this.mediaStreamTrack.stop();
            }
            yield _super.mute.call(this);
            return this;
        });
    }
    unmute() {
        const _super = Object.create(null, {
            unmute: { get: () => super.unmute }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.source === Track_1.Track.Source.Camera) {
                logger_1.default.debug('reacquiring camera track');
                yield this.restartTrack();
            }
            yield _super.unmute.call(this);
            return this;
        });
    }
    getSenderStats() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sender) {
                return [];
            }
            const items = [];
            const stats = yield this.sender.getStats();
            stats.forEach((v) => {
                var _a;
                if (v.type === 'outbound-rtp') {
                    const vs = {
                        type: 'video',
                        streamId: v.id,
                        frameHeight: v.frameHeight,
                        frameWidth: v.frameWidth,
                        firCount: v.firCount,
                        pliCount: v.pliCount,
                        nackCount: v.nackCount,
                        packetsSent: v.packetsSent,
                        bytesSent: v.bytesSent,
                        framesSent: v.framesSent,
                        timestamp: v.timestamp,
                        rid: (_a = v.rid) !== null && _a !== void 0 ? _a : '',
                        retransmittedPacketsSent: v.retransmittedPacketsSent,
                        qualityLimitationReason: v.qualityLimitationReason,
                        qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,
                    };
                    // locate the appropriate remote-inbound-rtp item
                    const r = stats.get(v.remoteId);
                    if (r) {
                        vs.jitter = r.jitter;
                        vs.packetsLost = r.packetsLost;
                        vs.roundTripTime = r.roundTripTime;
                    }
                    items.push(vs);
                }
            });
            return items;
        });
    }
    setPublishingQuality(maxQuality) {
        const qualities = [];
        for (let q = livekit_models_1.VideoQuality.LOW; q <= livekit_models_1.VideoQuality.HIGH; q += 1) {
            qualities.push({
                quality: q,
                enabled: q <= maxQuality,
            });
        }
        logger_1.default.debug('setting publishing quality. max quality', maxQuality);
        this.setPublishingLayers(qualities);
    }
    setDeviceId(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.constraints.deviceId === deviceId) {
                return;
            }
            this.constraints.deviceId = deviceId;
            // when video is muted, underlying media stream track is stopped and
            // will be restarted later
            if (!this.isMuted) {
                yield this.restartTrack();
            }
        });
    }
    restartTrack(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let constraints;
            if (options) {
                const streamConstraints = utils_2.constraintsForOptions({ video: options });
                if (typeof streamConstraints.video !== 'boolean') {
                    constraints = streamConstraints.video;
                }
            }
            yield this.restart(constraints);
        });
    }
    /**
     * @internal
     * Sets layers that should be publishing
     */
    setPublishingLayers(qualities) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.debug('setting publishing layers', qualities);
            if (!this.sender || !this.encodings) {
                return;
            }
            const params = this.sender.getParameters();
            const { encodings } = params;
            if (!encodings) {
                return;
            }
            if (encodings.length !== this.encodings.length) {
                logger_1.default.warn('cannot set publishing layers, encodings mismatch');
                return;
            }
            this.activeQualities = qualities;
            let hasChanged = false;
            encodings.forEach((encoding, idx) => {
                var _a;
                let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : '';
                if (rid === '') {
                    rid = 'q';
                }
                const quality = videoQualityForRid(rid);
                const subscribedQuality = qualities.find((q) => q.quality === quality);
                if (!subscribedQuality) {
                    return;
                }
                if (encoding.active !== subscribedQuality.enabled) {
                    hasChanged = true;
                    encoding.active = subscribedQuality.enabled;
                    logger_1.default.debug(`setting layer ${subscribedQuality.quality} to ${encoding.active ? 'enabled' : 'disabled'}`);
                    // FireFox does not support setting encoding.active to false, so we
                    // have a workaround of lowering its bitrate and resolution to the min.
                    if (utils_1.isFireFox()) {
                        if (subscribedQuality.enabled) {
                            encoding.scaleResolutionDownBy = this.encodings[idx].scaleResolutionDownBy;
                            encoding.maxBitrate = this.encodings[idx].maxBitrate;
                            /* @ts-ignore */
                            encoding.maxFrameRate = this.encodings[idx].maxFrameRate;
                        }
                        else {
                            encoding.scaleResolutionDownBy = 4;
                            encoding.maxBitrate = 10;
                            /* @ts-ignore */
                            encoding.maxFrameRate = 2;
                        }
                    }
                }
            });
            if (hasChanged) {
                params.encodings = encodings;
                yield this.sender.setParameters(params);
            }
        });
    }
    checkAndUpdateSimulcast(statsMap) {
        var _a, _b;
        if (!this.sender || this.isMuted || !this.encodings) {
            return;
        }
        let bestEncoding;
        const { encodings } = this.sender.getParameters();
        encodings.forEach((encoding) => {
            // skip inactive encodings
            if (!encoding.active)
                return;
            if (bestEncoding === undefined) {
                bestEncoding = encoding;
            }
            else if (bestEncoding.rid
                && encoding.rid
                && ridOrder.indexOf(bestEncoding.rid) < ridOrder.indexOf(encoding.rid)) {
                bestEncoding = encoding;
            }
            else if (bestEncoding.maxBitrate !== undefined
                && encoding.maxBitrate !== undefined
                && bestEncoding.maxBitrate < encoding.maxBitrate) {
                bestEncoding = encoding;
            }
        });
        if (!bestEncoding) {
            return;
        }
        const rid = (_a = bestEncoding.rid) !== null && _a !== void 0 ? _a : '';
        const sendStats = statsMap.get(rid);
        const lastStats = (_b = this.prevStats) === null || _b === void 0 ? void 0 : _b.get(rid);
        if (!sendStats || !lastStats) {
            return;
        }
        const currentQuality = videoQualityForRid(rid);
        // adaptive simulcast algorithm notes (davidzhao)
        // Chrome (and other browsers) will automatically pause the highest layer
        // when it runs into bandwidth limitations. When that happens, it would not
        // be able to send any new frames between the two stats checks.
        //
        // We need to set that layer to inactive intentionally, because chrome tends
        // to flicker, meaning it will attempt to send that layer again shortly
        // afterwards, flip-flopping every few seconds. We want to avoid that.
        //
        // Note: even after bandwidth recovers, the flip-flopping behavior continues
        // this is possibly due to SFU-side PLI generation and imperfect bandwidth estimation
        if (sendStats.qualityLimitationResolutionChanges
            - lastStats.qualityLimitationResolutionChanges > 0) {
            this.lastQualityChange = new Date().getTime();
        }
        // log.debug('frameSent', sendStats.framesSent, 'lastSent', lastStats.framesSent,
        //   'elapsed', sendStats.timestamp - lastStats.timestamp);
        if (sendStats.framesSent - lastStats.framesSent > 0) {
            // frames have been sending ok, consider upgrading quality
            if (currentQuality === livekit_models_1.VideoQuality.HIGH || !this.lastQualityChange)
                return;
            const nextQuality = currentQuality + 1;
            if ((new Date()).getTime() - this.lastQualityChange < QUALITY_UPGRADE_DELAY) {
                return;
            }
            if (this.activeQualities
                && this.activeQualities.some((q) => q.quality === nextQuality && !q.enabled)) {
                // quality has been disabled by the server, so we should skip
                return;
            }
            // we are already at the highest layer
            let bestQuality = livekit_models_1.VideoQuality.LOW;
            encodings.forEach((encoding) => {
                var _a;
                const quality = videoQualityForRid((_a = encoding.rid) !== null && _a !== void 0 ? _a : '');
                if (quality > bestQuality) {
                    bestQuality = quality;
                }
            });
            if (nextQuality > bestQuality) {
                return;
            }
            logger_1.default.debug('upgrading video quality to', nextQuality);
            this.setPublishingQuality(nextQuality);
            return;
        }
        // if best layer has not sent anything, do not downgrade till the
        // best layer starts sending something. It is possible that the
        // browser has not started some layer(s) due to cpu/bandwidth
        // constraints
        if (sendStats.framesSent === 0)
            return;
        // if we've upgraded or downgraded recently, give it a bit of time before
        // downgrading again
        if (this.lastExplicitQualityChange
            && ((new Date()).getTime() - this.lastExplicitQualityChange) < QUALITY_DOWNGRADE_DELAY) {
            return;
        }
        if (currentQuality === livekit_models_1.VideoQuality.UNRECOGNIZED) {
            return;
        }
        if (currentQuality === livekit_models_1.VideoQuality.LOW) {
            // already the lowest quality, nothing we can do
            return;
        }
        logger_1.default.debug('downgrading video quality to', currentQuality - 1);
        this.setPublishingQuality(currentQuality - 1);
    }
}
exports["default"] = LocalVideoTrack;
function videoQualityForRid(rid) {
    switch (rid) {
        case 'f':
            return livekit_models_1.VideoQuality.HIGH;
        case 'h':
            return livekit_models_1.VideoQuality.MEDIUM;
        case 'q':
            return livekit_models_1.VideoQuality.LOW;
        default:
            return livekit_models_1.VideoQuality.UNRECOGNIZED;
    }
}
exports.videoQualityForRid = videoQualityForRid;
function videoLayersFromEncodings(width, height, encodings) {
    // default to a single layer, HQ
    if (!encodings) {
        return [{
                quality: livekit_models_1.VideoQuality.HIGH,
                width,
                height,
                bitrate: 0,
                ssrc: 0,
            }];
    }
    return encodings.map((encoding) => {
        var _a, _b, _c;
        const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;
        let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : '');
        if (quality === livekit_models_1.VideoQuality.UNRECOGNIZED && encodings.length === 1) {
            quality = livekit_models_1.VideoQuality.HIGH;
        }
        return {
            quality,
            width: width / scale,
            height: height / scale,
            bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,
            ssrc: 0,
        };
    });
}
exports.videoLayersFromEncodings = videoLayersFromEncodings;
//# sourceMappingURL=LocalVideoTrack.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/RemoteAudioTrack.js":
/*!*************************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/RemoteAudioTrack.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const stats_1 = __webpack_require__(/*! ../stats */ "./node_modules/livekit-client/dist/room/stats.js");
const RemoteTrack_1 = __importDefault(__webpack_require__(/*! ./RemoteTrack */ "./node_modules/livekit-client/dist/room/track/RemoteTrack.js"));
const Track_1 = __webpack_require__(/*! ./Track */ "./node_modules/livekit-client/dist/room/track/Track.js");
class RemoteAudioTrack extends RemoteTrack_1.default {
    constructor(mediaTrack, sid, receiver) {
        super(mediaTrack, sid, Track_1.Track.Kind.Audio, receiver);
        this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.receiver) {
                this._currentBitrate = 0;
                return;
            }
            const stats = yield this.getReceiverStats();
            if (stats && this.prevStats && this.receiver) {
                this._currentBitrate = stats_1.computeBitrate(stats, this.prevStats);
            }
            this.prevStats = stats;
            setTimeout(() => {
                this.monitorReceiver();
            }, stats_1.monitorFrequency);
        });
    }
    getReceiverStats() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.receiver) {
                return;
            }
            const stats = yield this.receiver.getStats();
            let receiverStats;
            stats.forEach((v) => {
                if (v.type === 'inbound-rtp') {
                    receiverStats = {
                        type: 'audio',
                        timestamp: v.timestamp,
                        jitter: v.jitter,
                        bytesReceived: v.bytesReceived,
                        concealedSamples: v.concealedSamples,
                        concealmentEvents: v.concealmentEvents,
                        silentConcealedSamples: v.silentConcealedSamples,
                        silentConcealmentEvents: v.silentConcealmentEvents,
                        totalAudioEnergy: v.totalAudioEnergy,
                        totalSamplesDuration: v.totalSamplesDuration,
                    };
                }
            });
            return receiverStats;
        });
    }
}
exports["default"] = RemoteAudioTrack;
//# sourceMappingURL=RemoteAudioTrack.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/RemoteTrack.js":
/*!********************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/RemoteTrack.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(/*! ../events */ "./node_modules/livekit-client/dist/room/events.js");
const stats_1 = __webpack_require__(/*! ../stats */ "./node_modules/livekit-client/dist/room/stats.js");
const Track_1 = __webpack_require__(/*! ./Track */ "./node_modules/livekit-client/dist/room/track/Track.js");
class RemoteTrack extends Track_1.Track {
    constructor(mediaTrack, sid, kind, receiver) {
        super(mediaTrack, kind);
        this.sid = sid;
        this.receiver = receiver;
    }
    /** @internal */
    setMuted(muted) {
        if (this.isMuted !== muted) {
            this.isMuted = muted;
            this.emit(muted ? events_1.TrackEvent.Muted : events_1.TrackEvent.Unmuted, this);
        }
    }
    /** @internal */
    setMediaStream(stream) {
        // this is needed to determine when the track is finished
        // we send each track down in its own MediaStream, so we can assume the
        // current track is the only one that can be removed.
        stream.onremovetrack = () => {
            this.receiver = undefined;
            this._currentBitrate = 0;
            this.emit(events_1.TrackEvent.Ended, this);
        };
    }
    start() {
        this.startMonitor();
        // use `enabled` of track to enable re-use of transceiver
        super.enable();
    }
    stop() {
        // use `enabled` of track to enable re-use of transceiver
        super.disable();
    }
    /* @internal */
    startMonitor() {
        setTimeout(() => {
            this.monitorReceiver();
        }, stats_1.monitorFrequency);
    }
}
exports["default"] = RemoteTrack;
//# sourceMappingURL=RemoteTrack.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/RemoteTrackPublication.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/RemoteTrackPublication.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ "./node_modules/livekit-client/dist/logger.js"));
const livekit_models_1 = __webpack_require__(/*! ../../proto/livekit_models */ "./node_modules/livekit-client/dist/proto/livekit_models.js");
const livekit_rtc_1 = __webpack_require__(/*! ../../proto/livekit_rtc */ "./node_modules/livekit-client/dist/proto/livekit_rtc.js");
const events_1 = __webpack_require__(/*! ../events */ "./node_modules/livekit-client/dist/room/events.js");
const RemoteVideoTrack_1 = __importDefault(__webpack_require__(/*! ./RemoteVideoTrack */ "./node_modules/livekit-client/dist/room/track/RemoteVideoTrack.js"));
const TrackPublication_1 = __webpack_require__(/*! ./TrackPublication */ "./node_modules/livekit-client/dist/room/track/TrackPublication.js");
class RemoteTrackPublication extends TrackPublication_1.TrackPublication {
    constructor() {
        super(...arguments);
        /** @internal */
        this._allowed = true;
        this.disabled = false;
        this.currentVideoQuality = livekit_models_1.VideoQuality.HIGH;
        this.handleEnded = (track) => {
            this.emit(events_1.TrackEvent.Ended, track);
        };
        this.handleVisibilityChange = (visible) => {
            logger_1.default.debug('adaptivestream video visibility', this.trackSid, `visible=${visible}`);
            this.disabled = !visible;
            this.emitTrackUpdate();
        };
        this.handleVideoDimensionsChange = (dimensions) => {
            logger_1.default.debug('adaptivestream video dimensions', this.trackSid, `${dimensions.width}x${dimensions.height}`);
            this.videoDimensions = dimensions;
            this.emitTrackUpdate();
        };
    }
    /**
     * Subscribe or unsubscribe to this remote track
     * @param subscribed true to subscribe to a track, false to unsubscribe
     */
    setSubscribed(subscribed) {
        this.subscribed = subscribed;
        const sub = {
            trackSids: [this.trackSid],
            subscribe: this.subscribed,
            participantTracks: [{
                    // sending an empty participant id since TrackPublication doesn't keep it
                    // this is filled in by the participant that receives this message
                    participantSid: '',
                    trackSids: [this.trackSid],
                }],
        };
        this.emit(events_1.TrackEvent.UpdateSubscription, sub);
    }
    get subscriptionStatus() {
        if (this.subscribed === false || !super.isSubscribed) {
            return TrackPublication_1.TrackPublication.SubscriptionStatus.Unsubscribed;
        }
        if (!this._allowed) {
            return TrackPublication_1.TrackPublication.SubscriptionStatus.NotAllowed;
        }
        return TrackPublication_1.TrackPublication.SubscriptionStatus.Subscribed;
    }
    /**
     * Returns true if track is subscribed, and ready for playback
     */
    get isSubscribed() {
        if (this.subscribed === false) {
            return false;
        }
        if (!this._allowed) {
            return false;
        }
        return super.isSubscribed;
    }
    get isEnabled() {
        return !this.disabled;
    }
    /**
     * disable server from sending down data for this track. this is useful when
     * the participant is off screen, you may disable streaming down their video
     * to reduce bandwidth requirements
     * @param enabled
     */
    setEnabled(enabled) {
        if (!this.isManualOperationAllowed() || this.disabled === !enabled) {
            return;
        }
        this.disabled = !enabled;
        this.emitTrackUpdate();
    }
    /**
     * for tracks that support simulcasting, adjust subscribed quality
     *
     * This indicates the highest quality the client can accept. if network
     * bandwidth does not allow, server will automatically reduce quality to
     * optimize for uninterrupted video
     */
    setVideoQuality(quality) {
        if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {
            return;
        }
        this.currentVideoQuality = quality;
        this.videoDimensions = undefined;
        this.emitTrackUpdate();
    }
    setVideoDimensions(dimensions) {
        var _a, _b;
        if (!this.isManualOperationAllowed()) {
            return;
        }
        if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width
            && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {
            return;
        }
        if (this.track instanceof RemoteVideoTrack_1.default) {
            this.videoDimensions = dimensions;
        }
        this.currentVideoQuality = undefined;
        this.emitTrackUpdate();
    }
    get videoQuality() {
        return this.currentVideoQuality;
    }
    setTrack(track) {
        if (this.track) {
            // unregister listener
            this.track.off(events_1.TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
            this.track.off(events_1.TrackEvent.VisibilityChanged, this.handleVisibilityChange);
            this.track.off(events_1.TrackEvent.Ended, this.handleEnded);
        }
        super.setTrack(track);
        if (track) {
            track.sid = this.trackSid;
            track.on(events_1.TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
            track.on(events_1.TrackEvent.VisibilityChanged, this.handleVisibilityChange);
            track.on(events_1.TrackEvent.Ended, this.handleEnded);
        }
    }
    /** @internal */
    updateInfo(info) {
        var _a;
        super.updateInfo(info);
        this.metadataMuted = info.muted;
        (_a = this.track) === null || _a === void 0 ? void 0 : _a.setMuted(info.muted);
    }
    isManualOperationAllowed() {
        if (this.isAdaptiveStream) {
            logger_1.default.warn('adaptive stream is enabled, cannot change track settings', this.trackSid);
            return false;
        }
        if (!this.isSubscribed) {
            logger_1.default.warn('cannot update track settings when not subscribed', this.trackSid);
            return false;
        }
        return true;
    }
    get isAdaptiveStream() {
        return this.track instanceof RemoteVideoTrack_1.default && this.track.isAdaptiveStream;
    }
    /* @internal */
    emitTrackUpdate() {
        const settings = livekit_rtc_1.UpdateTrackSettings.fromPartial({
            trackSids: [this.trackSid],
            disabled: this.disabled,
        });
        if (this.videoDimensions) {
            settings.width = this.videoDimensions.width;
            settings.height = this.videoDimensions.height;
        }
        else if (this.currentVideoQuality !== undefined) {
            settings.quality = this.currentVideoQuality;
        }
        else {
            // defaults to high quality
            settings.quality = livekit_models_1.VideoQuality.HIGH;
        }
        this.emit(events_1.TrackEvent.UpdateSettings, settings);
    }
}
exports["default"] = RemoteTrackPublication;
//# sourceMappingURL=RemoteTrackPublication.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/RemoteVideoTrack.js":
/*!*************************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/RemoteVideoTrack.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ts_debounce_1 = __webpack_require__(/*! ts-debounce */ "./node_modules/ts-debounce/dist/src/index.esm.js");
const events_1 = __webpack_require__(/*! ../events */ "./node_modules/livekit-client/dist/room/events.js");
const stats_1 = __webpack_require__(/*! ../stats */ "./node_modules/livekit-client/dist/room/stats.js");
const utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/livekit-client/dist/room/utils.js");
const RemoteTrack_1 = __importDefault(__webpack_require__(/*! ./RemoteTrack */ "./node_modules/livekit-client/dist/room/track/RemoteTrack.js"));
const Track_1 = __webpack_require__(/*! ./Track */ "./node_modules/livekit-client/dist/room/track/Track.js");
const REACTION_DELAY = 100;
class RemoteVideoTrack extends RemoteTrack_1.default {
    constructor(mediaTrack, sid, receiver, adaptiveStream) {
        super(mediaTrack, sid, Track_1.Track.Kind.Video, receiver);
        this.elementInfos = [];
        this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.receiver) {
                this._currentBitrate = 0;
                return;
            }
            const stats = yield this.getReceiverStats();
            if (stats && this.prevStats && this.receiver) {
                this._currentBitrate = stats_1.computeBitrate(stats, this.prevStats);
            }
            this.prevStats = stats;
            setTimeout(() => {
                this.monitorReceiver();
            }, stats_1.monitorFrequency);
        });
        this.handleVisibilityChanged = (entry) => {
            const { target, isIntersecting } = entry;
            const elementInfo = this.elementInfos.find((info) => info.element === target);
            if (elementInfo) {
                elementInfo.visible = isIntersecting;
                elementInfo.visibilityChangedAt = Date.now();
            }
            this.updateVisibility();
        };
        this.debouncedHandleResize = ts_debounce_1.debounce(() => {
            this.updateDimensions();
        }, REACTION_DELAY);
        this.adaptiveStream = adaptiveStream;
    }
    get isAdaptiveStream() {
        var _a;
        return (_a = this.adaptiveStream) !== null && _a !== void 0 ? _a : false;
    }
    /** @internal */
    setMuted(muted) {
        super.setMuted(muted);
        this.attachedElements.forEach((element) => {
            // detach or attach
            if (muted) {
                Track_1.detachTrack(this.mediaStreamTrack, element);
            }
            else {
                Track_1.attachToElement(this.mediaStreamTrack, element);
            }
        });
    }
    attach(element) {
        if (!element) {
            element = super.attach();
        }
        else {
            super.attach(element);
        }
        // It's possible attach is called multiple times on an element. When that's
        // the case, we'd want to avoid adding duplicate elementInfos
        if (this.adaptiveStream
            && this.elementInfos.find((info) => info.element === element) === undefined) {
            this.elementInfos.push({
                element,
                visible: true, // default visible
            });
            element
                .handleResize = this.debouncedHandleResize;
            element
                .handleVisibilityChanged = this.handleVisibilityChanged;
            utils_1.getIntersectionObserver().observe(element);
            utils_1.getResizeObserver().observe(element);
            // trigger the first resize update cycle
            // if the tab is backgrounded, the initial resize event does not fire until
            // the tab comes into focus for the first time.
            this.debouncedHandleResize();
        }
        return element;
    }
    detach(element) {
        let detachedElements = [];
        if (element) {
            this.stopObservingElement(element);
            return super.detach(element);
        }
        detachedElements = super.detach();
        for (const e of detachedElements) {
            this.stopObservingElement(e);
        }
        return detachedElements;
    }
    getReceiverStats() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.receiver) {
                return;
            }
            const stats = yield this.receiver.getStats();
            let receiverStats;
            stats.forEach((v) => {
                if (v.type === 'inbound-rtp') {
                    receiverStats = {
                        type: 'video',
                        framesDecoded: v.framesDecoded,
                        framesDropped: v.framesDropped,
                        framesReceived: v.framesReceived,
                        packetsReceived: v.packetsReceived,
                        packetsLost: v.packetsLost,
                        frameWidth: v.frameWidth,
                        frameHeight: v.frameHeight,
                        pliCount: v.pliCount,
                        firCount: v.firCount,
                        nackCount: v.nackCount,
                        jitter: v.jitter,
                        timestamp: v.timestamp,
                        bytesReceived: v.bytesReceived,
                    };
                }
            });
            return receiverStats;
        });
    }
    stopObservingElement(element) {
        var _a, _b;
        (_a = utils_1.getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(element);
        (_b = utils_1.getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(element);
        this.elementInfos = this.elementInfos.filter((info) => info.element !== element);
    }
    updateVisibility() {
        const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);
        const isVisible = this.elementInfos.some((info) => info.visible);
        if (this.lastVisible === isVisible) {
            return;
        }
        if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {
            // delay hidden events
            setTimeout(() => {
                this.updateVisibility();
            }, REACTION_DELAY);
            return;
        }
        this.lastVisible = isVisible;
        this.emit(events_1.TrackEvent.VisibilityChanged, isVisible, this);
    }
    updateDimensions() {
        var _a, _b;
        let maxWidth = 0;
        let maxHeight = 0;
        for (const info of this.elementInfos) {
            if (info.element.clientWidth + info.element.clientHeight > maxWidth + maxHeight) {
                maxWidth = info.element.clientWidth;
                maxHeight = info.element.clientHeight;
            }
        }
        if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {
            return;
        }
        this.lastDimensions = {
            width: maxWidth,
            height: maxHeight,
        };
        this.emit(events_1.TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);
    }
}
exports["default"] = RemoteVideoTrack;
//# sourceMappingURL=RemoteVideoTrack.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/Track.js":
/*!**************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/Track.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.detachTrack = exports.attachToElement = exports.Track = void 0;
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const livekit_models_1 = __webpack_require__(/*! ../../proto/livekit_models */ "./node_modules/livekit-client/dist/proto/livekit_models.js");
const livekit_rtc_1 = __webpack_require__(/*! ../../proto/livekit_rtc */ "./node_modules/livekit-client/dist/proto/livekit_rtc.js");
const events_2 = __webpack_require__(/*! ../events */ "./node_modules/livekit-client/dist/room/events.js");
const utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/livekit-client/dist/room/utils.js");
// keep old audio elements when detached, we would re-use them since on iOS
// Safari tracks which audio elements have been "blessed" by the user.
const recycledElements = [];
class Track extends events_1.EventEmitter {
    constructor(mediaTrack, kind) {
        super();
        this.attachedElements = [];
        this.isMuted = false;
        this.streamState = Track.StreamState.Active;
        this._currentBitrate = 0;
        this.kind = kind;
        this.mediaStreamTrack = mediaTrack;
        this.source = Track.Source.Unknown;
    }
    /** current receive bits per second */
    get currentBitrate() {
        return this._currentBitrate;
    }
    attach(element) {
        let elementType = 'audio';
        if (this.kind === Track.Kind.Video) {
            elementType = 'video';
        }
        if (!element) {
            if (elementType === 'audio') {
                recycledElements.forEach((e) => {
                    if (e.parentElement === null && !element) {
                        element = e;
                    }
                });
                if (element) {
                    // remove it from pool
                    recycledElements.splice(recycledElements.indexOf(element), 1);
                }
            }
            if (!element) {
                element = document.createElement(elementType);
            }
        }
        if (!this.attachedElements.includes(element)) {
            this.attachedElements.push(element);
        }
        // even if we believe it's already attached to the element, it's possible
        // the element's srcObject was set to something else out of band.
        // we'll want to re-attach it in that case
        attachToElement(this.mediaStreamTrack, element);
        if (element instanceof HTMLAudioElement) {
            // manually play audio to detect audio playback status
            element.play()
                .then(() => {
                this.emit(events_2.TrackEvent.AudioPlaybackStarted);
            })
                .catch((e) => {
                this.emit(events_2.TrackEvent.AudioPlaybackFailed, e);
            });
        }
        return element;
    }
    detach(element) {
        // detach from a single element
        if (element) {
            detachTrack(this.mediaStreamTrack, element);
            const idx = this.attachedElements.indexOf(element);
            if (idx >= 0) {
                this.attachedElements.splice(idx, 1);
                this.recycleElement(element);
            }
            return element;
        }
        const detached = [];
        this.attachedElements.forEach((elm) => {
            detachTrack(this.mediaStreamTrack, elm);
            detached.push(elm);
            this.recycleElement(elm);
        });
        // remove all tracks
        this.attachedElements = [];
        return detached;
    }
    stop() {
        this.mediaStreamTrack.stop();
    }
    enable() {
        this.mediaStreamTrack.enabled = true;
    }
    disable() {
        this.mediaStreamTrack.enabled = false;
    }
    recycleElement(element) {
        if (element instanceof HTMLAudioElement) {
            // we only need to re-use a single element
            let shouldCache = true;
            element.pause();
            recycledElements.forEach((e) => {
                if (!e.parentElement) {
                    shouldCache = false;
                }
            });
            if (shouldCache) {
                recycledElements.push(element);
            }
        }
    }
}
exports.Track = Track;
/** @internal */
function attachToElement(track, element) {
    let mediaStream;
    if (element.srcObject instanceof MediaStream) {
        mediaStream = element.srcObject;
    }
    else {
        mediaStream = new MediaStream();
    }
    // check if track matches existing track
    let existingTracks;
    if (track.kind === 'audio') {
        existingTracks = mediaStream.getAudioTracks();
    }
    else {
        existingTracks = mediaStream.getVideoTracks();
    }
    if (!existingTracks.includes(track)) {
        existingTracks.forEach((et) => {
            mediaStream.removeTrack(et);
        });
        mediaStream.addTrack(track);
    }
    // avoid flicker
    if (element.srcObject !== mediaStream) {
        element.srcObject = mediaStream;
        if (utils_1.isSafari() && element instanceof HTMLVideoElement) {
            // Safari 15 has a bug where in certain layouts, video element renders
            // black until the page is resized or other changes take place.
            // Resetting the src triggers it to render.
            // https://developer.apple.com/forums/thread/690523
            setTimeout(() => {
                element.srcObject = mediaStream;
            }, 0);
        }
    }
    element.autoplay = true;
    if (element instanceof HTMLVideoElement) {
        element.playsInline = true;
    }
}
exports.attachToElement = attachToElement;
/** @internal */
function detachTrack(track, element) {
    if (element.srcObject instanceof MediaStream) {
        const mediaStream = element.srcObject;
        mediaStream.removeTrack(track);
        element.srcObject = null;
    }
}
exports.detachTrack = detachTrack;
(function (Track) {
    let Kind;
    (function (Kind) {
        Kind["Audio"] = "audio";
        Kind["Video"] = "video";
        Kind["Unknown"] = "unknown";
    })(Kind = Track.Kind || (Track.Kind = {}));
    let Source;
    (function (Source) {
        Source["Camera"] = "camera";
        Source["Microphone"] = "microphone";
        Source["ScreenShare"] = "screen_share";
        Source["ScreenShareAudio"] = "screen_share_audio";
        Source["Unknown"] = "unknown";
    })(Source = Track.Source || (Track.Source = {}));
    let StreamState;
    (function (StreamState) {
        StreamState["Active"] = "active";
        StreamState["Paused"] = "paused";
        StreamState["Unknown"] = "unknown";
    })(StreamState = Track.StreamState || (Track.StreamState = {}));
    /** @internal */
    function kindToProto(k) {
        switch (k) {
            case Kind.Audio:
                return livekit_models_1.TrackType.AUDIO;
            case Kind.Video:
                return livekit_models_1.TrackType.VIDEO;
            default:
                return livekit_models_1.TrackType.UNRECOGNIZED;
        }
    }
    Track.kindToProto = kindToProto;
    /** @internal */
    function kindFromProto(t) {
        switch (t) {
            case livekit_models_1.TrackType.AUDIO:
                return Kind.Audio;
            case livekit_models_1.TrackType.VIDEO:
                return Kind.Video;
            default:
                return Kind.Unknown;
        }
    }
    Track.kindFromProto = kindFromProto;
    /** @internal */
    function sourceToProto(s) {
        switch (s) {
            case Source.Camera:
                return livekit_models_1.TrackSource.CAMERA;
            case Source.Microphone:
                return livekit_models_1.TrackSource.MICROPHONE;
            case Source.ScreenShare:
                return livekit_models_1.TrackSource.SCREEN_SHARE;
            case Source.ScreenShareAudio:
                return livekit_models_1.TrackSource.SCREEN_SHARE_AUDIO;
            default:
                return livekit_models_1.TrackSource.UNRECOGNIZED;
        }
    }
    Track.sourceToProto = sourceToProto;
    /** @internal */
    function sourceFromProto(s) {
        switch (s) {
            case livekit_models_1.TrackSource.CAMERA:
                return Source.Camera;
            case livekit_models_1.TrackSource.MICROPHONE:
                return Source.Microphone;
            case livekit_models_1.TrackSource.SCREEN_SHARE:
                return Source.ScreenShare;
            case livekit_models_1.TrackSource.SCREEN_SHARE_AUDIO:
                return Source.ScreenShareAudio;
            default:
                return Source.Unknown;
        }
    }
    Track.sourceFromProto = sourceFromProto;
    /** @internal */
    function streamStateFromProto(s) {
        switch (s) {
            case livekit_rtc_1.StreamState.ACTIVE:
                return StreamState.Active;
            case livekit_rtc_1.StreamState.PAUSED:
                return StreamState.Paused;
            default:
                return StreamState.Unknown;
        }
    }
    Track.streamStateFromProto = streamStateFromProto;
})(Track = exports.Track || (exports.Track = {}));
//# sourceMappingURL=Track.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/TrackPublication.js":
/*!*************************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/TrackPublication.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TrackPublication = void 0;
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const events_2 = __webpack_require__(/*! ../events */ "./node_modules/livekit-client/dist/room/events.js");
const LocalAudioTrack_1 = __importDefault(__webpack_require__(/*! ./LocalAudioTrack */ "./node_modules/livekit-client/dist/room/track/LocalAudioTrack.js"));
const LocalVideoTrack_1 = __importDefault(__webpack_require__(/*! ./LocalVideoTrack */ "./node_modules/livekit-client/dist/room/track/LocalVideoTrack.js"));
const RemoteAudioTrack_1 = __importDefault(__webpack_require__(/*! ./RemoteAudioTrack */ "./node_modules/livekit-client/dist/room/track/RemoteAudioTrack.js"));
const RemoteVideoTrack_1 = __importDefault(__webpack_require__(/*! ./RemoteVideoTrack */ "./node_modules/livekit-client/dist/room/track/RemoteVideoTrack.js"));
const Track_1 = __webpack_require__(/*! ./Track */ "./node_modules/livekit-client/dist/room/track/Track.js");
class TrackPublication extends events_1.EventEmitter {
    constructor(kind, id, name) {
        super();
        this.metadataMuted = false;
        this.handleMuted = () => {
            this.emit(events_2.TrackEvent.Muted);
        };
        this.handleUnmuted = () => {
            this.emit(events_2.TrackEvent.Unmuted);
        };
        this.kind = kind;
        this.trackSid = id;
        this.trackName = name;
        this.source = Track_1.Track.Source.Unknown;
    }
    /** @internal */
    setTrack(track) {
        if (this.track) {
            this.track.off(events_2.TrackEvent.Muted, this.handleMuted);
            this.track.off(events_2.TrackEvent.Unmuted, this.handleUnmuted);
        }
        this.track = track;
        if (track) {
            // forward events
            track.on(events_2.TrackEvent.Muted, this.handleMuted);
            track.on(events_2.TrackEvent.Unmuted, this.handleUnmuted);
        }
    }
    get isMuted() {
        return this.metadataMuted;
    }
    get isEnabled() {
        return true;
    }
    get isSubscribed() {
        return this.track !== undefined;
    }
    /**
     * an [AudioTrack] if this publication holds an audio track
     */
    get audioTrack() {
        if (this.track instanceof LocalAudioTrack_1.default || this.track instanceof RemoteAudioTrack_1.default) {
            return this.track;
        }
    }
    /**
     * an [VideoTrack] if this publication holds a video track
     */
    get videoTrack() {
        if (this.track instanceof LocalVideoTrack_1.default || this.track instanceof RemoteVideoTrack_1.default) {
            return this.track;
        }
    }
    /** @internal */
    updateInfo(info) {
        this.trackSid = info.sid;
        this.trackName = info.name;
        this.source = Track_1.Track.sourceFromProto(info.source);
        this.mimeType = info.mimeType;
        if (this.kind === Track_1.Track.Kind.Video && info.width > 0) {
            this.dimensions = {
                width: info.width,
                height: info.height,
            };
            this.simulcasted = info.simulcast;
        }
        this.trackInfo = info;
    }
}
exports.TrackPublication = TrackPublication;
(function (TrackPublication) {
    let SubscriptionStatus;
    (function (SubscriptionStatus) {
        SubscriptionStatus["Subscribed"] = "subscribed";
        SubscriptionStatus["NotAllowed"] = "not_allowed";
        SubscriptionStatus["Unsubscribed"] = "unsubscribed";
    })(SubscriptionStatus = TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));
})(TrackPublication = exports.TrackPublication || (exports.TrackPublication = {}));
//# sourceMappingURL=TrackPublication.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/create.js":
/*!***************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/create.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createLocalScreenTracks = exports.createLocalAudioTrack = exports.createLocalVideoTrack = exports.createLocalTracks = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/livekit-client/dist/room/errors.js");
const publishUtils_1 = __webpack_require__(/*! ../participant/publishUtils */ "./node_modules/livekit-client/dist/room/participant/publishUtils.js");
const defaults_1 = __webpack_require__(/*! ./defaults */ "./node_modules/livekit-client/dist/room/track/defaults.js");
const LocalAudioTrack_1 = __importDefault(__webpack_require__(/*! ./LocalAudioTrack */ "./node_modules/livekit-client/dist/room/track/LocalAudioTrack.js"));
const LocalVideoTrack_1 = __importDefault(__webpack_require__(/*! ./LocalVideoTrack */ "./node_modules/livekit-client/dist/room/track/LocalVideoTrack.js"));
const options_1 = __webpack_require__(/*! ./options */ "./node_modules/livekit-client/dist/room/track/options.js");
const Track_1 = __webpack_require__(/*! ./Track */ "./node_modules/livekit-client/dist/room/track/Track.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/livekit-client/dist/room/track/utils.js");
/**
 * Creates a local video and audio track at the same time. When acquiring both
 * audio and video tracks together, it'll display a single permission prompt to
 * the user instead of two separate ones.
 * @param options
 */
function createLocalTracks(options) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        // set default options to true
        options !== null && options !== void 0 ? options : (options = {});
        (_a = options.audio) !== null && _a !== void 0 ? _a : (options.audio = true);
        (_b = options.video) !== null && _b !== void 0 ? _b : (options.video = true);
        const opts = utils_1.mergeDefaultOptions(options, defaults_1.audioDefaults, defaults_1.videoDefaults);
        const constraints = utils_1.constraintsForOptions(opts);
        const stream = yield navigator.mediaDevices.getUserMedia(constraints);
        return stream.getTracks().map((mediaStreamTrack) => {
            const isAudio = mediaStreamTrack.kind === 'audio';
            let trackOptions = isAudio ? options.audio : options.video;
            if (typeof trackOptions === 'boolean' || !trackOptions) {
                trackOptions = {};
            }
            let trackConstraints;
            const conOrBool = isAudio ? constraints.audio : constraints.video;
            if (typeof conOrBool !== 'boolean') {
                trackConstraints = conOrBool;
            }
            const track = publishUtils_1.mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);
            if (track.kind === Track_1.Track.Kind.Video) {
                track.source = Track_1.Track.Source.Camera;
            }
            else if (track.kind === Track_1.Track.Kind.Audio) {
                track.source = Track_1.Track.Source.Microphone;
            }
            return track;
        });
    });
}
exports.createLocalTracks = createLocalTracks;
/**
 * Creates a [[LocalVideoTrack]] with getUserMedia()
 * @param options
 */
function createLocalVideoTrack(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const tracks = yield createLocalTracks({
            audio: false,
            video: options,
        });
        return tracks[0];
    });
}
exports.createLocalVideoTrack = createLocalVideoTrack;
function createLocalAudioTrack(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const tracks = yield createLocalTracks({
            audio: options,
            video: false,
        });
        return tracks[0];
    });
}
exports.createLocalAudioTrack = createLocalAudioTrack;
/**
 * Creates a screen capture tracks with getDisplayMedia().
 * A LocalVideoTrack is always created and returned.
 * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
 */
function createLocalScreenTracks(options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (options === undefined) {
            options = {};
        }
        if (options.resolution === undefined) {
            options.resolution = options_1.VideoPresets.fhd.resolution;
        }
        let videoConstraints = true;
        if (options.resolution) {
            videoConstraints = {
                width: options.resolution.width,
                height: options.resolution.height,
            };
        }
        // typescript definition is missing getDisplayMedia: https://github.com/microsoft/TypeScript/issues/33232
        // @ts-ignore
        const stream = yield navigator.mediaDevices.getDisplayMedia({
            audio: (_a = options.audio) !== null && _a !== void 0 ? _a : false,
            video: videoConstraints,
        });
        const tracks = stream.getVideoTracks();
        if (tracks.length === 0) {
            throw new errors_1.TrackInvalidError('no video track found');
        }
        const screenVideo = new LocalVideoTrack_1.default(tracks[0]);
        screenVideo.source = Track_1.Track.Source.ScreenShare;
        const localTracks = [screenVideo];
        if (stream.getAudioTracks().length > 0) {
            const screenAudio = new LocalAudioTrack_1.default(stream.getAudioTracks()[0]);
            screenAudio.source = Track_1.Track.Source.ScreenShareAudio;
            localTracks.push(screenAudio);
        }
        return localTracks;
    });
}
exports.createLocalScreenTracks = createLocalScreenTracks;
//# sourceMappingURL=create.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/defaults.js":
/*!*****************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/defaults.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.videoDefaults = exports.audioDefaults = exports.publishDefaults = void 0;
const options_1 = __webpack_require__(/*! ./options */ "./node_modules/livekit-client/dist/room/track/options.js");
exports.publishDefaults = {
    audioBitrate: options_1.AudioPresets.speech.maxBitrate,
    dtx: true,
    simulcast: true,
    screenShareEncoding: options_1.ScreenSharePresets.hd_15.encoding,
    stopMicTrackOnMute: false,
};
exports.audioDefaults = {
    autoGainControl: true,
    channelCount: 1,
    echoCancellation: true,
    noiseSuppression: true,
};
exports.videoDefaults = {
    resolution: options_1.VideoPresets.qhd.resolution,
};
//# sourceMappingURL=defaults.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/options.js":
/*!****************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/options.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScreenSharePresets = exports.VideoPresets43 = exports.VideoPresets = exports.AudioPresets = exports.VideoPreset = void 0;
class VideoPreset {
    constructor(width, height, maxBitrate, maxFramerate) {
        this.width = width;
        this.height = height;
        this.encoding = {
            maxBitrate,
            maxFramerate,
        };
    }
    get resolution() {
        return {
            width: this.width,
            height: this.height,
            frameRate: this.encoding.maxFramerate,
            aspectRatio: this.width / this.height,
        };
    }
}
exports.VideoPreset = VideoPreset;
var AudioPresets;
(function (AudioPresets) {
    AudioPresets.telephone = {
        maxBitrate: 12000,
    };
    AudioPresets.speech = {
        maxBitrate: 20000,
    };
    AudioPresets.music = {
        maxBitrate: 32000,
    };
})(AudioPresets = exports.AudioPresets || (exports.AudioPresets = {}));
/**
 * Sane presets for video resolution/encoding
 */
exports.VideoPresets = {
    qvga: new VideoPreset(320, 180, 120000, 10),
    vga: new VideoPreset(640, 360, 300000, 20),
    qhd: new VideoPreset(960, 540, 600000, 25),
    hd: new VideoPreset(1280, 720, 2000000, 30),
    fhd: new VideoPreset(1920, 1080, 3000000, 30),
};
/**
 * Four by three presets
 */
exports.VideoPresets43 = {
    qvga: new VideoPreset(240, 180, 90000, 10),
    vga: new VideoPreset(480, 360, 225000, 20),
    qhd: new VideoPreset(720, 540, 450000, 25),
    hd: new VideoPreset(960, 720, 1500000, 30),
    fhd: new VideoPreset(1440, 1080, 2800000, 30),
};
exports.ScreenSharePresets = {
    vga: new VideoPreset(640, 360, 200000, 3),
    hd_8: new VideoPreset(1280, 720, 400000, 5),
    hd_15: new VideoPreset(1280, 720, 1000000, 15),
    fhd_15: new VideoPreset(1920, 1080, 1500000, 15),
    fhd_30: new VideoPreset(1920, 1080, 3000000, 30),
};
//# sourceMappingURL=options.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/types.js":
/*!**************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/types.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/track/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/track/utils.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.constraintsForOptions = exports.mergeDefaultOptions = void 0;
function mergeDefaultOptions(options, audioDefaults, videoDefaults) {
    const opts = Object.assign({}, options);
    if (opts.audio === true)
        opts.audio = {};
    if (opts.video === true)
        opts.video = {};
    // use defaults
    if (opts.audio) {
        mergeObjectWithoutOverwriting(opts.audio, audioDefaults);
    }
    if (opts.video) {
        mergeObjectWithoutOverwriting(opts.video, videoDefaults);
    }
    return opts;
}
exports.mergeDefaultOptions = mergeDefaultOptions;
function mergeObjectWithoutOverwriting(mainObject, objectToMerge) {
    Object.keys(objectToMerge).forEach((key) => {
        if (mainObject[key] === undefined)
            mainObject[key] = objectToMerge[key];
    });
    return mainObject;
}
function constraintsForOptions(options) {
    const constraints = {};
    if (options.video) {
        // default video options
        if (typeof options.video === 'object') {
            const videoOptions = {};
            const target = videoOptions;
            const source = options.video;
            Object.keys(source).forEach((key) => {
                switch (key) {
                    case 'resolution':
                        // flatten VideoResolution fields
                        mergeObjectWithoutOverwriting(target, source.resolution);
                        break;
                    default:
                        target[key] = source[key];
                }
            });
            constraints.video = videoOptions;
        }
        else {
            constraints.video = options.video;
        }
    }
    else {
        constraints.video = false;
    }
    if (options.audio) {
        if (typeof options.audio === 'object') {
            constraints.audio = options.audio;
        }
        else {
            constraints.audio = true;
        }
    }
    else {
        constraints.audio = false;
    }
    return constraints;
}
exports.constraintsForOptions = constraintsForOptions;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/room/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/livekit-client/dist/room/utils.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getClientInfo = exports.getIntersectionObserver = exports.getResizeObserver = exports.isSafari = exports.isFireFox = exports.sleep = exports.unpackStreamId = void 0;
const livekit_models_1 = __webpack_require__(/*! ../proto/livekit_models */ "./node_modules/livekit-client/dist/proto/livekit_models.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/livekit-client/dist/version.js");
const separator = '|';
function unpackStreamId(packed) {
    const parts = packed.split(separator);
    if (parts.length > 1) {
        return [parts[0], packed.substr(parts[0].length + 1)];
    }
    return [packed, ''];
}
exports.unpackStreamId = unpackStreamId;
function sleep(duration) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => setTimeout(resolve, duration));
    });
}
exports.sleep = sleep;
function isFireFox() {
    return navigator.userAgent.indexOf('Firefox') !== -1;
}
exports.isFireFox = isFireFox;
function isSafari() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
exports.isSafari = isSafari;
function roDispatchCallback(entries) {
    for (const entry of entries) {
        entry.target.handleResize(entry);
    }
}
function ioDispatchCallback(entries) {
    for (const entry of entries) {
        entry.target.handleVisibilityChanged(entry);
    }
}
let resizeObserver = null;
const getResizeObserver = () => {
    if (!resizeObserver)
        resizeObserver = new ResizeObserver(roDispatchCallback);
    return resizeObserver;
};
exports.getResizeObserver = getResizeObserver;
let intersectionObserver = null;
const getIntersectionObserver = () => {
    if (!intersectionObserver)
        intersectionObserver = new IntersectionObserver(ioDispatchCallback);
    return intersectionObserver;
};
exports.getIntersectionObserver = getIntersectionObserver;
function getClientInfo() {
    const info = livekit_models_1.ClientInfo.fromPartial({
        sdk: livekit_models_1.ClientInfo_SDK.JS,
        protocol: version_1.protocolVersion,
        version: version_1.version,
    });
    return info;
}
exports.getClientInfo = getClientInfo;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/livekit-client/dist/version.js":
/*!*****************************************************!*\
  !*** ./node_modules/livekit-client/dist/version.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.protocolVersion = exports.version = void 0;
exports.version = '0.16.2';
exports.protocolVersion = 6;
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;

      var storageKey = "loglevel";
      if (typeof name === "string") {
        storageKey += ":" + name;
      } else if (typeof name === "symbol") {
        storageKey = undefined;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType || !storageKey) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage.removeItem(storageKey);
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {}
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          defaultLevel = level;
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.resetLevel = function () {
          self.setLevel(defaultLevel, false);
          clearPersistedLevel();
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    // ES6 default export, for compatibility
    defaultLogger['default'] = defaultLogger;

    return defaultLogger;
}));


/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/***/ (function(module) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(/*! ./src/index-minimal */ "./node_modules/protobufjs/src/index-minimal.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
protobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ "./node_modules/protobufjs/src/writer_buffer.js");
protobuf.Reader       = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
protobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ "./node_modules/protobufjs/src/reader_buffer.js");

// Utility
protobuf.util         = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");
protobuf.rpc          = __webpack_require__(/*! ./rpc */ "./node_modules/protobufjs/src/rpc.js");
protobuf.roots        = __webpack_require__(/*! ./roots */ "./node_modules/protobufjs/src/roots.js");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/***/ (function(module) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(/*! ./rpc/service */ "./node_modules/protobufjs/src/rpc/service.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = Service;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ "./node_modules/@protobufjs/aspromise/index.js");

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(/*! @protobufjs/base64 */ "./node_modules/@protobufjs/base64/index.js");

// base class of rpc.Service
util.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ "./node_modules/@protobufjs/eventemitter/index.js");

// float handling accross browsers
util.float = __webpack_require__(/*! @protobufjs/float */ "./node_modules/@protobufjs/float/index.js");

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(/*! @protobufjs/inquire */ "./node_modules/@protobufjs/inquire/index.js");

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ "./node_modules/@protobufjs/utf8/index.js");

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(/*! @protobufjs/pool */ "./node_modules/@protobufjs/pool/index.js");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(/*! ./longbits */ "./node_modules/protobufjs/src/util/longbits.js");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof __webpack_require__.g !== "undefined"
                   && __webpack_require__.g
                   && __webpack_require__.g.process
                   && __webpack_require__.g.process.versions
                   && __webpack_require__.g.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && __webpack_require__.g
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ "./node_modules/sdp/sdp.js":
/*!*********************************!*\
  !*** ./node_modules/sdp/sdp.js ***!
  \*********************************/
/***/ (function(module) {

"use strict";
/* eslint-env node */


// SDP helpers.
const SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(line => line.trim());
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  const parts = blob.split('\nm=');
  return parts.map((part, index) => (index > 0 ?
    'm=' + part : part).trim() + '\r\n');
};

// Returns the session description.
SDPUtils.getDescription = function(blob) {
  const sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// Returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  const sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
// Input can be prefixed with a=.
SDPUtils.parseCandidate = function(line) {
  let parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  const candidate = {
    foundation: parts[0],
    component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    address: parts[4], // address is an alias for ip.
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7],
  };

  for (let i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compatibility.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag. Don't overwrite.
        if (candidate[parts[i]] === undefined) {
          candidate[parts[i]] = parts[i + 1];
        }
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
// This does not include the a= prefix!
SDPUtils.writeCandidate = function(candidate) {
  const sdp = [];
  sdp.push(candidate.foundation);

  const component = candidate.component;
  if (component === 'rtp') {
    sdp.push(1);
  } else if (component === 'rtcp') {
    sdp.push(2);
  } else {
    sdp.push(component);
  }
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.address || candidate.ip);
  sdp.push(candidate.port);

  const type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// Sample input:
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
};

// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  let parts = line.substr(9).split(' ');
  const parsed = {
    payloadType: parseInt(parts.shift(), 10), // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generates a rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  const channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses a extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  const parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1],
  };
};

// Generates an extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
        ? '/' + headerExtension.direction
        : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses a fmtp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  const parsed = {};
  let kv;
  const parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (let j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  let line = '';
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    const params = [];
    Object.keys(codec.parameters).forEach(param => {
      if (codec.parameters[param] !== undefined) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  const parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' '),
  };
};

// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  let lines = '';
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(fb => {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses a RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  const sp = line.indexOf(' ');
  const parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10),
  };
  const colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

// Parse a ssrc-group line (see RFC 5576). Sample input:
// a=ssrc-group:semantics 12 34
SDPUtils.parseSsrcGroup = function(line) {
  const parts = line.substr(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),
  };
};

// Extracts the MID (RFC 5888) from a media section.
// Returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
};

// Parses a fingerprint line for DTLS-SRTP.
SDPUtils.parseFingerprint = function(line) {
  const parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint),
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  let sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(fp => {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};

// Parses a=crypto lines into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
SDPUtils.parseCryptoLine = function(line) {
  const parts = line.substr(9).split(' ');
  return {
    tag: parseInt(parts[0], 10),
    cryptoSuite: parts[1],
    keyParams: parts[2],
    sessionParams: parts.slice(3),
  };
};

SDPUtils.writeCryptoLine = function(parameters) {
  return 'a=crypto:' + parameters.tag + ' ' +
    parameters.cryptoSuite + ' ' +
    (typeof parameters.keyParams === 'object'
      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
      : parameters.keyParams) +
    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +
    '\r\n';
};

// Parses the crypto key parameters into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
SDPUtils.parseCryptoKeyParams = function(keyParams) {
  if (keyParams.indexOf('inline:') !== 0) {
    return null;
  }
  const parts = keyParams.substr(7).split('|');
  return {
    keyMethod: 'inline',
    keySalt: parts[0],
    lifeTime: parts[1],
    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
  };
};

SDPUtils.writeCryptoKeyParams = function(keyParams) {
  return keyParams.keyMethod + ':'
    + keyParams.keySalt +
    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +
    (keyParams.mkiValue && keyParams.mkiLength
      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength
      : '');
};

// Extracts all SDES parameters.
SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {
  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=crypto:');
  return lines.map(SDPUtils.parseCryptoLine);
};

// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-ufrag:')[0];
  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-pwd:')[0];
  if (!(ufrag && pwd)) {
    return null;
  }
  return {
    usernameFragment: ufrag.substr(12),
    password: pwd.substr(10),
  };
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
  if (params.iceLite) {
    sdp += 'a=ice-lite\r\n';
  }
  return sdp;
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  const description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: [],
  };
  const lines = SDPUtils.splitLines(mediaSection);
  const mline = lines[0].split(' ');
  for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    const pt = mline[i];
    const rtpmapline = SDPUtils.matchPrefix(
      mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      const codec = SDPUtils.parseRtpMap(rtpmapline);
      const fmtps = SDPUtils.matchPrefix(
        mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
        mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  let sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(codec => {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(codec => {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  let maxptime = 0;
  caps.codecs.forEach(codec => {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(extension => {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  const encodingParameters = [];
  const description = SDPUtils.parseRtpParameters(mediaSection);
  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(parts => parts.attribute === 'cname');
  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  let secondarySsrc;

  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
    .map(line => {
      const parts = line.substr(17).split(' ');
      return parts.map(part => parseInt(part, 10));
    });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(codec => {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      let encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: primarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red',
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc,
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(params => {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  const rtcpParameters = {};

  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(obj => obj.attribute === 'cname')[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrіbute.
  // Note that Edge does not support unmuxed RTCP.
  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

SDPUtils.writeRtcpParameters = function(rtcpParameters) {
  let sdp = '';
  if (rtcpParameters.reducedSize) {
    sdp += 'a=rtcp-rsize\r\n';
  }
  if (rtcpParameters.mux) {
    sdp += 'a=rtcp-mux\r\n';
  }
  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {
    sdp += 'a=ssrc:' + rtcpParameters.ssrc +
      ' cname:' + rtcpParameters.cname + '\r\n';
  }
  return sdp;
};


// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  let parts;
  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(msidParts => msidParts.attribute === 'msid');
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// SCTP
// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
// to draft-ietf-mmusic-sctp-sdp-05
SDPUtils.parseSctpDescription = function(mediaSection) {
  const mline = SDPUtils.parseMLine(mediaSection);
  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
  let maxMessageSize;
  if (maxSizeLine.length > 0) {
    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
  }
  if (isNaN(maxMessageSize)) {
    maxMessageSize = 65536;
  }
  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
  if (sctpPort.length > 0) {
    return {
      port: parseInt(sctpPort[0].substr(12), 10),
      protocol: mline.fmt,
      maxMessageSize,
    };
  }
  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
  if (sctpMapLines.length > 0) {
    const parts = sctpMapLines[0]
      .substr(10)
      .split(' ');
    return {
      port: parseInt(parts[0], 10),
      protocol: parts[1],
      maxMessageSize,
    };
  }
};

// SCTP
// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
// support by now receiving in this format, unless we originally parsed
// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
// protocol of DTLS/SCTP -- without UDP/ or TCP/)
SDPUtils.writeSctpDescription = function(media, sctp) {
  let output = [];
  if (media.protocol !== 'DTLS/SCTP') {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctp-port:' + sctp.port + '\r\n',
    ];
  } else {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n',
    ];
  }
  if (sctp.maxMessageSize !== undefined) {
    output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
  }
  return output.join('');
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boiler plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  let sessionId;
  const version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  const user = sessUser || 'thisisadapterortc';
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=' + user + ' ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  const lines = SDPUtils.splitLines(mediaSection);
  for (let i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  const lines = SDPUtils.splitLines(mediaSection);
  const mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  const lines = SDPUtils.splitLines(mediaSection);
  const parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' '),
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  const parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5],
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  const lines = SDPUtils.splitLines(blob);
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (true) {
  module.exports = SDPUtils;
}


/***/ }),

/***/ "./node_modules/ts-debounce/dist/src/index.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/ts-debounce/dist/src/index.esm.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debounce": function() { return /* binding */ r; }
/* harmony export */ });
function r(r,e,n){var i,t,o;void 0===e&&(e=50),void 0===n&&(n={});var a=null!=(i=n.isImmediate)&&i,u=null!=(t=n.callback)&&t,c=n.maxWait,v=Date.now(),l=[];function f(){if(void 0!==c){var r=Date.now()-v;if(r+e>=c)return c-r}return e}var d=function(){var e=[].slice.call(arguments),n=this;return new Promise(function(i,t){var c=a&&void 0===o;if(void 0!==o&&clearTimeout(o),o=setTimeout(function(){if(o=void 0,v=Date.now(),!a){var i=r.apply(n,e);u&&u(i),l.forEach(function(r){return(0,r.resolve)(i)}),l=[]}},f()),c){var d=r.apply(n,e);return u&&u(d),i(d)}l.push({resolve:i,reject:t})})};return d.cancel=function(r){void 0!==o&&clearTimeout(o),l.forEach(function(e){return(0,e.reject)(r)}),l=[]},d}
//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/adapter_core.js":
/*!************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_core.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter_factory.js */ "./node_modules/webrtc-adapter/src/js/adapter_factory.js");
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */





const adapter =
  (0,_adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__.adapterFactory)({window: typeof window === 'undefined' ? undefined : window});
/* harmony default export */ __webpack_exports__["default"] = (adapter);


/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/adapter_factory.js":
/*!***************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_factory.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "adapterFactory": function() { return /* binding */ adapterFactory; }
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/webrtc-adapter/src/js/utils.js");
/* harmony import */ var _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chrome/chrome_shim */ "./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js");
/* harmony import */ var _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./firefox/firefox_shim */ "./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js");
/* harmony import */ var _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./safari/safari_shim */ "./node_modules/webrtc-adapter/src/js/safari/safari_shim.js");
/* harmony import */ var _common_shim__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common_shim */ "./node_modules/webrtc-adapter/src/js/common_shim.js");
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! sdp */ "./node_modules/sdp/sdp.js");
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_5__);
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */


  // Browser shims.






// Shimming starts here.
function adapterFactory({window} = {}, options = {
  shimChrome: true,
  shimFirefox: true,
  shimSafari: true,
}) {
  // Utils.
  const logging = _utils__WEBPACK_IMPORTED_MODULE_0__.log;
  const browserDetails = _utils__WEBPACK_IMPORTED_MODULE_0__.detectBrowser(window);

  const adapter = {
    browserDetails,
    commonShim: _common_shim__WEBPACK_IMPORTED_MODULE_4__,
    extractVersion: _utils__WEBPACK_IMPORTED_MODULE_0__.extractVersion,
    disableLog: _utils__WEBPACK_IMPORTED_MODULE_0__.disableLog,
    disableWarnings: _utils__WEBPACK_IMPORTED_MODULE_0__.disableWarnings,
    // Expose sdp as a convenience. For production apps include directly.
    sdp: sdp__WEBPACK_IMPORTED_MODULE_5__,
  };

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ || !_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimPeerConnection ||
          !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      if (browserDetails.version === null) {
        logging('Chrome shim can not determine version, not shimming.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__;

      // Must be called before shimPeerConnection.
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);

      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimMediaStream(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimPeerConnection(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimOnTrack(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimAddTrackRemoveTrack(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetSendersWithDtmf(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetStats(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimSenderReceiverGetStats(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.fixNegotiationNeeded(window, browserDetails);

      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimConnectionState(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.removeExtmapAllowMixed(window, browserDetails);
      break;
    case 'firefox':
      if (!_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__ || !_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimPeerConnection ||
          !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__;

      // Must be called before shimPeerConnection.
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);

      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimGetUserMedia(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimPeerConnection(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimOnTrack(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimRemoveStream(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimSenderGetStats(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimReceiverGetStats(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimRTCDataChannel(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimAddTransceiver(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimGetParameters(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimCreateOffer(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimCreateAnswer(window, browserDetails);

      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimConnectionState(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);
      break;
    case 'safari':
      if (!_safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__ || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__;

      // Must be called before shimCallbackAPI.
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);

      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimRTCIceServerUrls(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimCreateOfferLegacy(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimCallbacksAPI(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimLocalStreamsAPI(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimRemoteStreamsAPI(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimTrackEventTransceiver(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimGetUserMedia(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimAudioContext(window, browserDetails);

      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.removeExtmapAllowMixed(window, browserDetails);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
}


/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimGetUserMedia": function() { return /* reexport safe */ _getusermedia__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia; },
/* harmony export */   "shimGetDisplayMedia": function() { return /* reexport safe */ _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__.shimGetDisplayMedia; },
/* harmony export */   "shimMediaStream": function() { return /* binding */ shimMediaStream; },
/* harmony export */   "shimOnTrack": function() { return /* binding */ shimOnTrack; },
/* harmony export */   "shimGetSendersWithDtmf": function() { return /* binding */ shimGetSendersWithDtmf; },
/* harmony export */   "shimGetStats": function() { return /* binding */ shimGetStats; },
/* harmony export */   "shimSenderReceiverGetStats": function() { return /* binding */ shimSenderReceiverGetStats; },
/* harmony export */   "shimAddTrackRemoveTrackWithNative": function() { return /* binding */ shimAddTrackRemoveTrackWithNative; },
/* harmony export */   "shimAddTrackRemoveTrack": function() { return /* binding */ shimAddTrackRemoveTrack; },
/* harmony export */   "shimPeerConnection": function() { return /* binding */ shimPeerConnection; },
/* harmony export */   "fixNegotiationNeeded": function() { return /* binding */ fixNegotiationNeeded; }
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/webrtc-adapter/src/js/utils.js");
/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getusermedia */ "./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js");
/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getdisplaymedia */ "./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js");
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */






function shimMediaStream(window) {
  window.MediaStream = window.MediaStream || window.webkitMediaStream;
}

function shimOnTrack(window) {
  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
      window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
      get() {
        return this._ontrack;
      },
      set(f) {
        if (this._ontrack) {
          this.removeEventListener('track', this._ontrack);
        }
        this.addEventListener('track', this._ontrack = f);
      },
      enumerable: true,
      configurable: true
    });
    const origSetRemoteDescription =
        window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription =
      function setRemoteDescription() {
        if (!this._ontrackpoly) {
          this._ontrackpoly = (e) => {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', te => {
              let receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers()
                  .find(r => r.track && r.track.id === te.track.id);
              } else {
                receiver = {track: te.track};
              }

              const event = new Event('track');
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = {receiver};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(track => {
              let receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers()
                  .find(r => r.track && r.track.id === track.id);
              } else {
                receiver = {track};
              }
              const event = new Event('track');
              event.track = track;
              event.receiver = receiver;
              event.transceiver = {receiver};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            });
          };
          this.addEventListener('addstream', this._ontrackpoly);
        }
        return origSetRemoteDescription.apply(this, arguments);
      };
  } else {
    // even if RTCRtpTransceiver is in window, it is only used and
    // emitted in unified-plan. Unfortunately this means we need
    // to unconditionally wrap the event.
    _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {
      if (!e.transceiver) {
        Object.defineProperty(e, 'transceiver',
          {value: {receiver: e.receiver}});
      }
      return e;
    });
  }
}

function shimGetSendersWithDtmf(window) {
  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
  if (typeof window === 'object' && window.RTCPeerConnection &&
      !('getSenders' in window.RTCPeerConnection.prototype) &&
      'createDTMFSender' in window.RTCPeerConnection.prototype) {
    const shimSenderWithDtmf = function(pc, track) {
      return {
        track,
        get dtmf() {
          if (this._dtmf === undefined) {
            if (track.kind === 'audio') {
              this._dtmf = pc.createDTMFSender(track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
        _pc: pc
      };
    };

    // augment addTrack when getSenders is not available.
    if (!window.RTCPeerConnection.prototype.getSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice(); // return a copy of the internal state.
      };
      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addTrack =
        function addTrack(track, stream) {
          let sender = origAddTrack.apply(this, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(this, track);
            this._senders.push(sender);
          }
          return sender;
        };

      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
      window.RTCPeerConnection.prototype.removeTrack =
        function removeTrack(sender) {
          origRemoveTrack.apply(this, arguments);
          const idx = this._senders.indexOf(sender);
          if (idx !== -1) {
            this._senders.splice(idx, 1);
          }
        };
    }
    const origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach(track => {
        this._senders.push(shimSenderWithDtmf(this, track));
      });
    };

    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream =
      function removeStream(stream) {
        this._senders = this._senders || [];
        origRemoveStream.apply(this, [stream]);

        stream.getTracks().forEach(track => {
          const sender = this._senders.find(s => s.track === track);
          if (sender) { // remove sender
            this._senders.splice(this._senders.indexOf(sender), 1);
          }
        });
      };
  } else if (typeof window === 'object' && window.RTCPeerConnection &&
             'getSenders' in window.RTCPeerConnection.prototype &&
             'createDTMFSender' in window.RTCPeerConnection.prototype &&
             window.RTCRtpSender &&
             !('dtmf' in window.RTCRtpSender.prototype)) {
    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach(sender => sender._pc = this);
      return senders;
    };

    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
      get() {
        if (this._dtmf === undefined) {
          if (this.track.kind === 'audio') {
            this._dtmf = this._pc.createDTMFSender(this.track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
}

function shimGetStats(window) {
  if (!window.RTCPeerConnection) {
    return;
  }

  const origGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;

    // If selector is a function then we are in the old style stats so just
    // pass back the original getStats format to avoid breaking old users.
    if (arguments.length > 0 && typeof selector === 'function') {
      return origGetStats.apply(this, arguments);
    }

    // When spec-style getStats is supported, return those when called with
    // either no arguments or the selector argument is null.
    if (origGetStats.length === 0 && (arguments.length === 0 ||
        typeof selector !== 'function')) {
      return origGetStats.apply(this, []);
    }

    const fixChromeStats_ = function(response) {
      const standardReport = {};
      const reports = response.result();
      reports.forEach(report => {
        const standardStats = {
          id: report.id,
          timestamp: report.timestamp,
          type: {
            localcandidate: 'local-candidate',
            remotecandidate: 'remote-candidate'
          }[report.type] || report.type
        };
        report.names().forEach(name => {
          standardStats[name] = report.stat(name);
        });
        standardReport[standardStats.id] = standardStats;
      });

      return standardReport;
    };

    // shim getStats with maplike support
    const makeMapStats = function(stats) {
      return new Map(Object.keys(stats).map(key => [key, stats[key]]));
    };

    if (arguments.length >= 2) {
      const successCallbackWrapper_ = function(response) {
        onSucc(makeMapStats(fixChromeStats_(response)));
      };

      return origGetStats.apply(this, [successCallbackWrapper_,
        selector]);
    }

    // promise-support
    return new Promise((resolve, reject) => {
      origGetStats.apply(this, [
        function(response) {
          resolve(makeMapStats(fixChromeStats_(response)));
        }, reject]);
    }).then(onSucc, onErr);
  };
}

function shimSenderReceiverGetStats(window) {
  if (!(typeof window === 'object' && window.RTCPeerConnection &&
      window.RTCRtpSender && window.RTCRtpReceiver)) {
    return;
  }

  // shim sender stats.
  if (!('getStats' in window.RTCRtpSender.prototype)) {
    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach(sender => sender._pc = this);
        return senders;
      };
    }

    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function getStats() {
      const sender = this;
      return this._pc.getStats().then(result =>
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        _utils_js__WEBPACK_IMPORTED_MODULE_0__.filterStats(result, sender.track, true));
    };
  }

  // shim receiver stats.
  if (!('getStats' in window.RTCRtpReceiver.prototype)) {
    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers =
        function getReceivers() {
          const receivers = origGetReceivers.apply(this, []);
          receivers.forEach(receiver => receiver._pc = this);
          return receivers;
        };
    }
    _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function getStats() {
      const receiver = this;
      return this._pc.getStats().then(result =>
        _utils_js__WEBPACK_IMPORTED_MODULE_0__.filterStats(result, receiver.track, false));
    };
  }

  if (!('getStats' in window.RTCRtpSender.prototype &&
      'getStats' in window.RTCRtpReceiver.prototype)) {
    return;
  }

  // shim RTCPeerConnection.getStats(track).
  const origGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    if (arguments.length > 0 &&
        arguments[0] instanceof window.MediaStreamTrack) {
      const track = arguments[0];
      let sender;
      let receiver;
      let err;
      this.getSenders().forEach(s => {
        if (s.track === track) {
          if (sender) {
            err = true;
          } else {
            sender = s;
          }
        }
      });
      this.getReceivers().forEach(r => {
        if (r.track === track) {
          if (receiver) {
            err = true;
          } else {
            receiver = r;
          }
        }
        return r.track === track;
      });
      if (err || (sender && receiver)) {
        return Promise.reject(new DOMException(
          'There are more than one sender or receiver for the track.',
          'InvalidAccessError'));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException(
        'There is no sender or receiver for the track.',
        'InvalidAccessError'));
    }
    return origGetStats.apply(this, arguments);
  };
}

function shimAddTrackRemoveTrackWithNative(window) {
  // shim addTrack/removeTrack with native variants in order to make
  // the interactions with legacy getLocalStreams behave as in other browsers.
  // Keeps a mapping stream.id => [stream, rtpsenders...]
  window.RTCPeerConnection.prototype.getLocalStreams =
    function getLocalStreams() {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams)
        .map(streamId => this._shimmedLocalStreams[streamId][0]);
    };

  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
  window.RTCPeerConnection.prototype.addTrack =
    function addTrack(track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      const sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };

  const origAddStream = window.RTCPeerConnection.prototype.addStream;
  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

    stream.getTracks().forEach(track => {
      const alreadyExists = this.getSenders().find(s => s.track === track);
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }
    });
    const existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    const newSenders = this.getSenders()
      .filter(newSender => existingSenders.indexOf(newSender) === -1);
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  };

  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
  window.RTCPeerConnection.prototype.removeStream =
    function removeStream(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };

  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
  window.RTCPeerConnection.prototype.removeTrack =
    function removeTrack(sender) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach(streamId => {
          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            this._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (this._shimmedLocalStreams[streamId].length === 1) {
            delete this._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
}

function shimAddTrackRemoveTrack(window, browserDetails) {
  if (!window.RTCPeerConnection) {
    return;
  }
  // shim addTrack and removeTrack.
  if (window.RTCPeerConnection.prototype.addTrack &&
      browserDetails.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window);
  }

  // also shim pc.getLocalStreams when addTrack is shimmed
  // to return the original streams.
  const origGetLocalStreams = window.RTCPeerConnection.prototype
      .getLocalStreams;
  window.RTCPeerConnection.prototype.getLocalStreams =
    function getLocalStreams() {
      const nativeStreams = origGetLocalStreams.apply(this);
      this._reverseStreams = this._reverseStreams || {};
      return nativeStreams.map(stream => this._reverseStreams[stream.id]);
    };

  const origAddStream = window.RTCPeerConnection.prototype.addStream;
  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};

    stream.getTracks().forEach(track => {
      const alreadyExists = this.getSenders().find(s => s.track === track);
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }
    });
    // Add identity mapping for consistency with addTrack.
    // Unless this is being used with a stream from addTrack.
    if (!this._reverseStreams[stream.id]) {
      const newStream = new window.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  };

  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
  window.RTCPeerConnection.prototype.removeStream =
    function removeStream(stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};

      origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);
      delete this._reverseStreams[(this._streams[stream.id] ?
          this._streams[stream.id].id : stream.id)];
      delete this._streams[stream.id];
    };

  window.RTCPeerConnection.prototype.addTrack =
    function addTrack(track, stream) {
      if (this.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      const streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 ||
          !streams[0].getTracks().find(t => t === track)) {
        // this is not fully correct but all we can manage without
        // [[associated MediaStreams]] internal slot.
        throw new DOMException(
          'The adapter.js addTrack polyfill only supports a single ' +
          ' stream which is associated with the specified track.',
          'NotSupportedError');
      }

      const alreadyExists = this.getSenders().find(s => s.track === track);
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }

      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      const oldStream = this._streams[stream.id];
      if (oldStream) {
        // this is using odd Chrome behaviour, use with caution:
        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
        // Note: we rely on the high-level addTrack/dtmf shim to
        // create the sender with a dtmf sender.
        oldStream.addTrack(track);

        // Trigger ONN async.
        Promise.resolve().then(() => {
          this.dispatchEvent(new Event('negotiationneeded'));
        });
      } else {
        const newStream = new window.MediaStream([track]);
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        this.addStream(newStream);
      }
      return this.getSenders().find(s => s.track === track);
    };

  // replace the internal stream id with the external one and
  // vice versa.
  function replaceInternalStreamId(pc, description) {
    let sdp = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(internalId => {
      const externalStream = pc._reverseStreams[internalId];
      const internalStream = pc._streams[externalStream.id];
      sdp = sdp.replace(new RegExp(internalStream.id, 'g'),
          externalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp
    });
  }
  function replaceExternalStreamId(pc, description) {
    let sdp = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(internalId => {
      const externalStream = pc._reverseStreams[internalId];
      const internalStream = pc._streams[externalStream.id];
      sdp = sdp.replace(new RegExp(externalStream.id, 'g'),
          internalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp
    });
  }
  ['createOffer', 'createAnswer'].forEach(function(method) {
    const nativeMethod = window.RTCPeerConnection.prototype[method];
    const methodObj = {[method]() {
      const args = arguments;
      const isLegacyCall = arguments.length &&
          typeof arguments[0] === 'function';
      if (isLegacyCall) {
        return nativeMethod.apply(this, [
          (description) => {
            const desc = replaceInternalStreamId(this, description);
            args[0].apply(null, [desc]);
          },
          (err) => {
            if (args[1]) {
              args[1].apply(null, err);
            }
          }, arguments[2]
        ]);
      }
      return nativeMethod.apply(this, arguments)
      .then(description => replaceInternalStreamId(this, description));
    }};
    window.RTCPeerConnection.prototype[method] = methodObj[method];
  });

  const origSetLocalDescription =
      window.RTCPeerConnection.prototype.setLocalDescription;
  window.RTCPeerConnection.prototype.setLocalDescription =
    function setLocalDescription() {
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(this, arguments);
      }
      arguments[0] = replaceExternalStreamId(this, arguments[0]);
      return origSetLocalDescription.apply(this, arguments);
    };

  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

  const origLocalDescription = Object.getOwnPropertyDescriptor(
      window.RTCPeerConnection.prototype, 'localDescription');
  Object.defineProperty(window.RTCPeerConnection.prototype,
      'localDescription', {
        get() {
          const description = origLocalDescription.get.apply(this);
          if (description.type === '') {
            return description;
          }
          return replaceInternalStreamId(this, description);
        }
      });

  window.RTCPeerConnection.prototype.removeTrack =
    function removeTrack(sender) {
      if (this.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      // We can not yet check for sender instanceof RTCRtpSender
      // since we shim RTPSender. So we check if sender._pc is set.
      if (!sender._pc) {
        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +
            'does not implement interface RTCRtpSender.', 'TypeError');
      }
      const isLocal = sender._pc === this;
      if (!isLocal) {
        throw new DOMException('Sender was not created by this connection.',
            'InvalidAccessError');
      }

      // Search for the native stream the senders track belongs to.
      this._streams = this._streams || {};
      let stream;
      Object.keys(this._streams).forEach(streamid => {
        const hasTrack = this._streams[streamid].getTracks()
          .find(track => sender.track === track);
        if (hasTrack) {
          stream = this._streams[streamid];
        }
      });

      if (stream) {
        if (stream.getTracks().length === 1) {
          // if this is the last track of the stream, remove the stream. This
          // takes care of any shimmed _senders.
          this.removeStream(this._reverseStreams[stream.id]);
        } else {
          // relying on the same odd chrome behaviour as above.
          stream.removeTrack(sender.track);
        }
        this.dispatchEvent(new Event('negotiationneeded'));
      }
    };
}

function shimPeerConnection(window, browserDetails) {
  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
    // very basic support for old versions.
    window.RTCPeerConnection = window.webkitRTCPeerConnection;
  }
  if (!window.RTCPeerConnection) {
    return;
  }

  // shim implicit creation of RTCSessionDescription/RTCIceCandidate
  if (browserDetails.version < 53) {
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          const nativeMethod = window.RTCPeerConnection.prototype[method];
          const methodObj = {[method]() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }};
          window.RTCPeerConnection.prototype[method] = methodObj[method];
        });
  }
}

// Attempt to fix ONN in plan-b mode.
function fixNegotiationNeeded(window, browserDetails) {
  _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {
    const pc = e.target;
    if (browserDetails.version < 72 || (pc.getConfiguration &&
        pc.getConfiguration().sdpSemantics === 'plan-b')) {
      if (pc.signalingState !== 'stable') {
        return;
      }
    }
    return e;
  });
}


/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js":
/*!**********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimGetDisplayMedia": function() { return /* binding */ shimGetDisplayMedia; }
/* harmony export */ });
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */

function shimGetDisplayMedia(window, getSourceId) {
  if (window.navigator.mediaDevices &&
    'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  if (!(window.navigator.mediaDevices)) {
    return;
  }
  // getSourceId is a function that returns a promise resolving with
  // the sourceId of the screen/window/tab to be shared.
  if (typeof getSourceId !== 'function') {
    console.error('shimGetDisplayMedia: getSourceId argument is not ' +
        'a function');
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia =
    function getDisplayMedia(constraints) {
      return getSourceId(constraints)
        .then(sourceId => {
          const widthSpecified = constraints.video && constraints.video.width;
          const heightSpecified = constraints.video &&
            constraints.video.height;
          const frameRateSpecified = constraints.video &&
            constraints.video.frameRate;
          constraints.video = {
            mandatory: {
              chromeMediaSource: 'desktop',
              chromeMediaSourceId: sourceId,
              maxFrameRate: frameRateSpecified || 3
            }
          };
          if (widthSpecified) {
            constraints.video.mandatory.maxWidth = widthSpecified;
          }
          if (heightSpecified) {
            constraints.video.mandatory.maxHeight = heightSpecified;
          }
          return window.navigator.mediaDevices.getUserMedia(constraints);
        });
    };
}


/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimGetUserMedia": function() { return /* binding */ shimGetUserMedia; }
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/webrtc-adapter/src/js/utils.js");
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */


const logging = _utils_js__WEBPACK_IMPORTED_MODULE_0__.log;

function shimGetUserMedia(window, browserDetails) {
  const navigator = window && window.navigator;

  if (!navigator.mediaDevices) {
    return;
  }

  const constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    const cc = {};
    Object.keys(c).forEach(key => {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      const r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      const oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        let oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(mix => {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  const shimConstraints_ = function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === 'object') {
      const remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile & surface pro.
      let face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});
      const getSupportedFacingModeLies = browserDetails.version < 66;

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode &&
            !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        let matches;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices()
          .then(devices => {
            devices = devices.filter(d => d.kind === 'videoinput');
            let dev = devices.find(d => matches.some(match =>
              d.label.toLowerCase().includes(match)));
            if (!dev && devices.length && matches.includes('back')) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :
                                                        {ideal: dev.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  const shimError_ = function(e) {
    if (browserDetails.version >= 64) {
      return e;
    }
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        PermissionDismissedError: 'NotAllowedError',
        InvalidStateError: 'NotAllowedError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
        MediaDeviceKillSwitchOn: 'NotAllowedError',
        TabCaptureError: 'AbortError',
        ScreenCaptureError: 'AbortError',
        DeviceCaptureError: 'AbortError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint || e.constraintName,
      toString() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  const getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, c => {
      navigator.webkitGetUserMedia(c, onSuccess, e => {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };
  navigator.getUserMedia = getUserMedia_.bind(navigator);

  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
  // function which returns a Promise, it does not accept spec-style
  // constraints.
  if (navigator.mediaDevices.getUserMedia) {
    const origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(track => {
            track.stop();
          });
          throw new DOMException('', 'NotFoundError');
        }
        return stream;
      }, e => Promise.reject(shimError_(e))));
    };
  }
}


/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/common_shim.js":
/*!***********************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/common_shim.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimRTCIceCandidate": function() { return /* binding */ shimRTCIceCandidate; },
/* harmony export */   "shimMaxMessageSize": function() { return /* binding */ shimMaxMessageSize; },
/* harmony export */   "shimSendThrowTypeError": function() { return /* binding */ shimSendThrowTypeError; },
/* harmony export */   "shimConnectionState": function() { return /* binding */ shimConnectionState; },
/* harmony export */   "removeExtmapAllowMixed": function() { return /* binding */ removeExtmapAllowMixed; },
/* harmony export */   "shimAddIceCandidateNullOrEmpty": function() { return /* binding */ shimAddIceCandidateNullOrEmpty; },
/* harmony export */   "shimParameterlessSetLocalDescription": function() { return /* binding */ shimParameterlessSetLocalDescription; }
/* harmony export */ });
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sdp */ "./node_modules/sdp/sdp.js");
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./node_modules/webrtc-adapter/src/js/utils.js");
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */





function shimRTCIceCandidate(window) {
  // foundation is arbitrarily chosen as an indicator for full support for
  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
  if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in
      window.RTCIceCandidate.prototype)) {
    return;
  }

  const NativeRTCIceCandidate = window.RTCIceCandidate;
  window.RTCIceCandidate = function RTCIceCandidate(args) {
    // Remove the a= which shouldn't be part of the candidate string.
    if (typeof args === 'object' && args.candidate &&
        args.candidate.indexOf('a=') === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substr(2);
    }

    if (args.candidate && args.candidate.length) {
      // Augment the native candidate with the parsed fields.
      const nativeCandidate = new NativeRTCIceCandidate(args);
      const parsedCandidate = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseCandidate(args.candidate);
      const augmentedCandidate = Object.assign(nativeCandidate,
          parsedCandidate);

      // Add a serializer that does not serialize the extra attributes.
      augmentedCandidate.toJSON = function toJSON() {
        return {
          candidate: augmentedCandidate.candidate,
          sdpMid: augmentedCandidate.sdpMid,
          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
          usernameFragment: augmentedCandidate.usernameFragment,
        };
      };
      return augmentedCandidate;
    }
    return new NativeRTCIceCandidate(args);
  };
  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

  // Hook up the augmented candidate in onicecandidate and
  // addEventListener('icecandidate', ...)
  _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'icecandidate', e => {
    if (e.candidate) {
      Object.defineProperty(e, 'candidate', {
        value: new window.RTCIceCandidate(e.candidate),
        writable: 'false'
      });
    }
    return e;
  });
}

function shimMaxMessageSize(window, browserDetails) {
  if (!window.RTCPeerConnection) {
    return;
  }

  if (!('sctp' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
      get() {
        return typeof this._sctp === 'undefined' ? null : this._sctp;
      }
    });
  }

  const sctpInDescription = function(description) {
    if (!description || !description.sdp) {
      return false;
    }
    const sections = sdp__WEBPACK_IMPORTED_MODULE_0___default().splitSections(description.sdp);
    sections.shift();
    return sections.some(mediaSection => {
      const mLine = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseMLine(mediaSection);
      return mLine && mLine.kind === 'application'
          && mLine.protocol.indexOf('SCTP') !== -1;
    });
  };

  const getRemoteFirefoxVersion = function(description) {
    // TODO: Is there a better solution for detecting Firefox?
    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    const version = parseInt(match[1], 10);
    // Test for NaN (yes, this is ugly)
    return version !== version ? -1 : version;
  };

  const getCanSendMaxMessageSize = function(remoteIsFirefox) {
    // Every implementation we know can send at least 64 KiB.
    // Note: Although Chrome is technically able to send up to 256 KiB, the
    //       data does not reach the other peer reliably.
    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
    let canSendMaxMessageSize = 65536;
    if (browserDetails.browser === 'firefox') {
      if (browserDetails.version < 57) {
        if (remoteIsFirefox === -1) {
          // FF < 57 will send in 16 KiB chunks using the deprecated PPID
          // fragmentation.
          canSendMaxMessageSize = 16384;
        } else {
          // However, other FF (and RAWRTC) can reassemble PPID-fragmented
          // messages. Thus, supporting ~2 GiB when sending.
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails.version < 60) {
        // Currently, all FF >= 57 will reset the remote maximum message size
        // to the default value when a data channel is created at a later
        // stage. :(
        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
        canSendMaxMessageSize =
          browserDetails.version === 57 ? 65535 : 65536;
      } else {
        // FF >= 60 supports sending ~2 GiB
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  };

  const getMaxMessageSize = function(description, remoteIsFirefox) {
    // Note: 65536 bytes is the default value from the SDP spec. Also,
    //       every implementation we know supports receiving 65536 bytes.
    let maxMessageSize = 65536;

    // FF 57 has a slightly incorrect default remote max message size, so
    // we need to adjust it here to avoid a failure when sending.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
    if (browserDetails.browser === 'firefox'
         && browserDetails.version === 57) {
      maxMessageSize = 65535;
    }

    const match = sdp__WEBPACK_IMPORTED_MODULE_0___default().matchPrefix(description.sdp,
      'a=max-message-size:');
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substr(19), 10);
    } else if (browserDetails.browser === 'firefox' &&
                remoteIsFirefox !== -1) {
      // If the maximum message size is not present in the remote SDP and
      // both local and remote are Firefox, the remote peer can receive
      // ~2 GiB.
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  };

  const origSetRemoteDescription =
      window.RTCPeerConnection.prototype.setRemoteDescription;
  window.RTCPeerConnection.prototype.setRemoteDescription =
    function setRemoteDescription() {
      this._sctp = null;
      // Chrome decided to not expose .sctp in plan-b mode.
      // As usual, adapter.js has to do an 'ugly worakaround'
      // to cover up the mess.
      if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
        const {sdpSemantics} = this.getConfiguration();
        if (sdpSemantics === 'plan-b') {
          Object.defineProperty(this, 'sctp', {
            get() {
              return typeof this._sctp === 'undefined' ? null : this._sctp;
            },
            enumerable: true,
            configurable: true,
          });
        }
      }

      if (sctpInDescription(arguments[0])) {
        // Check if the remote is FF.
        const isFirefox = getRemoteFirefoxVersion(arguments[0]);

        // Get the maximum message size the local peer is capable of sending
        const canSendMMS = getCanSendMaxMessageSize(isFirefox);

        // Get the maximum message size of the remote peer.
        const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

        // Determine final maximum message size
        let maxMessageSize;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }

        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
        // attribute.
        const sctp = {};
        Object.defineProperty(sctp, 'maxMessageSize', {
          get() {
            return maxMessageSize;
          }
        });
        this._sctp = sctp;
      }

      return origSetRemoteDescription.apply(this, arguments);
    };
}

function shimSendThrowTypeError(window) {
  if (!(window.RTCPeerConnection &&
      'createDataChannel' in window.RTCPeerConnection.prototype)) {
    return;
  }

  // Note: Although Firefox >= 57 has a native implementation, the maximum
  //       message size can be reset for all data channels at a later stage.
  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

  function wrapDcSend(dc, pc) {
    const origDataChannelSend = dc.send;
    dc.send = function send() {
      const data = arguments[0];
      const length = data.length || data.size || data.byteLength;
      if (dc.readyState === 'open' &&
          pc.sctp && length > pc.sctp.maxMessageSize) {
        throw new TypeError('Message too large (can send a maximum of ' +
          pc.sctp.maxMessageSize + ' bytes)');
      }
      return origDataChannelSend.apply(dc, arguments);
    };
  }
  const origCreateDataChannel =
    window.RTCPeerConnection.prototype.createDataChannel;
  window.RTCPeerConnection.prototype.createDataChannel =
    function createDataChannel() {
      const dataChannel = origCreateDataChannel.apply(this, arguments);
      wrapDcSend(dataChannel, this);
      return dataChannel;
    };
  _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'datachannel', e => {
    wrapDcSend(e.channel, e.target);
    return e;
  });
}


/* shims RTCConnectionState by pretending it is the same as iceConnectionState.
 * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
 * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
 * since DTLS failures would be hidden. See
 * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
 * for the Firefox tracking bug.
 */
function shimConnectionState(window) {
  if (!window.RTCPeerConnection ||
      'connectionState' in window.RTCPeerConnection.prototype) {
    return;
  }
  const proto = window.RTCPeerConnection.prototype;
  Object.defineProperty(proto, 'connectionState', {
    get() {
      return {
        completed: 'connected',
        checking: 'connecting'
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(proto, 'onconnectionstatechange', {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(cb) {
      if (this._onconnectionstatechange) {
        this.removeEventListener('connectionstatechange',
            this._onconnectionstatechange);
        delete this._onconnectionstatechange;
      }
      if (cb) {
        this.addEventListener('connectionstatechange',
            this._onconnectionstatechange = cb);
      }
    },
    enumerable: true,
    configurable: true
  });

  ['setLocalDescription', 'setRemoteDescription'].forEach((method) => {
    const origMethod = proto[method];
    proto[method] = function() {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = e => {
          const pc = e.target;
          if (pc._lastConnectionState !== pc.connectionState) {
            pc._lastConnectionState = pc.connectionState;
            const newEvent = new Event('connectionstatechange', e);
            pc.dispatchEvent(newEvent);
          }
          return e;
        };
        this.addEventListener('iceconnectionstatechange',
          this._connectionstatechangepoly);
      }
      return origMethod.apply(this, arguments);
    };
  });
}

function removeExtmapAllowMixed(window, browserDetails) {
  /* remove a=extmap-allow-mixed for webrtc.org < M71 */
  if (!window.RTCPeerConnection) {
    return;
  }
  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
    return;
  }
  if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {
    return;
  }
  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
  window.RTCPeerConnection.prototype.setRemoteDescription =
  function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
      const sdp = desc.sdp.split('\n').filter((line) => {
        return line.trim() !== 'a=extmap-allow-mixed';
      }).join('\n');
      // Safari enforces read-only-ness of RTCSessionDescription fields.
      if (window.RTCSessionDescription &&
          desc instanceof window.RTCSessionDescription) {
        arguments[0] = new window.RTCSessionDescription({
          type: desc.type,
          sdp,
        });
      } else {
        desc.sdp = sdp;
      }
    }
    return nativeSRD.apply(this, arguments);
  };
}

function shimAddIceCandidateNullOrEmpty(window, browserDetails) {
  // Support for addIceCandidate(null or undefined)
  // as well as addIceCandidate({candidate: "", ...})
  // https://bugs.chromium.org/p/chromium/issues/detail?id=978582
  // Note: must be called before other polyfills which change the signature.
  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeAddIceCandidate =
      window.RTCPeerConnection.prototype.addIceCandidate;
  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
    return;
  }
  window.RTCPeerConnection.prototype.addIceCandidate =
    function addIceCandidate() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      // Firefox 68+ emits and processes {candidate: "", ...}, ignore
      // in older versions.
      // Native support for ignoring exists for Chrome M77+.
      // Safari ignores as well, exact version unknown but works in the same
      // version that also ignores addIceCandidate(null).
      if (((browserDetails.browser === 'chrome' && browserDetails.version < 78)
           || (browserDetails.browser === 'firefox'
               && browserDetails.version < 68)
           || (browserDetails.browser === 'safari'))
          && arguments[0] && arguments[0].candidate === '') {
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
}

// Note: Make sure to call this ahead of APIs that modify
// setLocalDescription.length
function shimParameterlessSetLocalDescription(window, browserDetails) {
  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeSetLocalDescription =
      window.RTCPeerConnection.prototype.setLocalDescription;
  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
    return;
  }
  window.RTCPeerConnection.prototype.setLocalDescription =
    function setLocalDescription() {
      let desc = arguments[0] || {};
      if (typeof desc !== 'object' || (desc.type && desc.sdp)) {
        return nativeSetLocalDescription.apply(this, arguments);
      }
      // The remaining steps should technically happen when SLD comes off the
      // RTCPeerConnection's operations chain (not ahead of going on it), but
      // this is too difficult to shim. Instead, this shim only covers the
      // common case where the operations chain is empty. This is imperfect, but
      // should cover many cases. Rationale: Even if we can't reduce the glare
      // window to zero on imperfect implementations, there's value in tapping
      // into the perfect negotiation pattern that several browsers support.
      desc = {type: desc.type, sdp: desc.sdp};
      if (!desc.type) {
        switch (this.signalingState) {
          case 'stable':
          case 'have-local-offer':
          case 'have-remote-pranswer':
            desc.type = 'offer';
            break;
          default:
            desc.type = 'answer';
            break;
        }
      }
      if (desc.sdp || (desc.type !== 'offer' && desc.type !== 'answer')) {
        return nativeSetLocalDescription.apply(this, [desc]);
      }
      const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;
      return func.apply(this)
        .then(d => nativeSetLocalDescription.apply(this, [d]));
    };
}


/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimGetUserMedia": function() { return /* reexport safe */ _getusermedia__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia; },
/* harmony export */   "shimGetDisplayMedia": function() { return /* reexport safe */ _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__.shimGetDisplayMedia; },
/* harmony export */   "shimOnTrack": function() { return /* binding */ shimOnTrack; },
/* harmony export */   "shimPeerConnection": function() { return /* binding */ shimPeerConnection; },
/* harmony export */   "shimSenderGetStats": function() { return /* binding */ shimSenderGetStats; },
/* harmony export */   "shimReceiverGetStats": function() { return /* binding */ shimReceiverGetStats; },
/* harmony export */   "shimRemoveStream": function() { return /* binding */ shimRemoveStream; },
/* harmony export */   "shimRTCDataChannel": function() { return /* binding */ shimRTCDataChannel; },
/* harmony export */   "shimAddTransceiver": function() { return /* binding */ shimAddTransceiver; },
/* harmony export */   "shimGetParameters": function() { return /* binding */ shimGetParameters; },
/* harmony export */   "shimCreateOffer": function() { return /* binding */ shimCreateOffer; },
/* harmony export */   "shimCreateAnswer": function() { return /* binding */ shimCreateAnswer; }
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/webrtc-adapter/src/js/utils.js");
/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getusermedia */ "./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js");
/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getdisplaymedia */ "./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js");
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */






function shimOnTrack(window) {
  if (typeof window === 'object' && window.RTCTrackEvent &&
      ('receiver' in window.RTCTrackEvent.prototype) &&
      !('transceiver' in window.RTCTrackEvent.prototype)) {
    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
      get() {
        return {receiver: this.receiver};
      }
    });
  }
}

function shimPeerConnection(window, browserDetails) {
  if (typeof window !== 'object' ||
      !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
    return; // probably media.peerconnection.enabled=false in about:config
  }
  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
    // very basic support for old versions.
    window.RTCPeerConnection = window.mozRTCPeerConnection;
  }

  if (browserDetails.version < 53) {
    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          const nativeMethod = window.RTCPeerConnection.prototype[method];
          const methodObj = {[method]() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }};
          window.RTCPeerConnection.prototype[method] = methodObj[method];
        });
  }

  const modernStatsTypes = {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  };

  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;
    return nativeGetStats.apply(this, [selector || null])
      .then(stats => {
        if (browserDetails.version < 53 && !onSucc) {
          // Shim only promise getStats with spec-hyphens in type names
          // Leave callback version alone; misc old uses of forEach before Map
          try {
            stats.forEach(stat => {
              stat.type = modernStatsTypes[stat.type] || stat.type;
            });
          } catch (e) {
            if (e.name !== 'TypeError') {
              throw e;
            }
            // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
            stats.forEach((stat, i) => {
              stats.set(i, Object.assign({}, stat, {
                type: modernStatsTypes[stat.type] || stat.type
              }));
            });
          }
        }
        return stats;
      })
      .then(onSucc, onErr);
  };
}

function shimSenderGetStats(window) {
  if (!(typeof window === 'object' && window.RTCPeerConnection &&
      window.RTCRtpSender)) {
    return;
  }
  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
    return;
  }
  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach(sender => sender._pc = this);
      return senders;
    };
  }

  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window.RTCPeerConnection.prototype.addTrack = function addTrack() {
      const sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    };
  }
  window.RTCRtpSender.prototype.getStats = function getStats() {
    return this.track ? this._pc.getStats(this.track) :
        Promise.resolve(new Map());
  };
}

function shimReceiverGetStats(window) {
  if (!(typeof window === 'object' && window.RTCPeerConnection &&
      window.RTCRtpSender)) {
    return;
  }
  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
    return;
  }
  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
      const receivers = origGetReceivers.apply(this, []);
      receivers.forEach(receiver => receiver._pc = this);
      return receivers;
    };
  }
  _utils__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {
    e.receiver._pc = e.srcElement;
    return e;
  });
  window.RTCRtpReceiver.prototype.getStats = function getStats() {
    return this._pc.getStats(this.track);
  };
}

function shimRemoveStream(window) {
  if (!window.RTCPeerConnection ||
      'removeStream' in window.RTCPeerConnection.prototype) {
    return;
  }
  window.RTCPeerConnection.prototype.removeStream =
    function removeStream(stream) {
      _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('removeStream', 'removeTrack');
      this.getSenders().forEach(sender => {
        if (sender.track && stream.getTracks().includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    };
}

function shimRTCDataChannel(window) {
  // rename DataChannel to RTCDataChannel (native fix in FF60):
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
  if (window.DataChannel && !window.RTCDataChannel) {
    window.RTCDataChannel = window.DataChannel;
  }
}

function shimAddTransceiver(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!(typeof window === 'object' && window.RTCPeerConnection)) {
    return;
  }
  const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;
  if (origAddTransceiver) {
    window.RTCPeerConnection.prototype.addTransceiver =
      function addTransceiver() {
        this.setParametersPromises = [];
        const initParameters = arguments[1];
        const shouldPerformCheck = initParameters &&
                                  'sendEncodings' in initParameters;
        if (shouldPerformCheck) {
          // If sendEncodings params are provided, validate grammar
          initParameters.sendEncodings.forEach((encodingParam) => {
            if ('rid' in encodingParam) {
              const ridRegex = /^[a-z0-9]{0,16}$/i;
              if (!ridRegex.test(encodingParam.rid)) {
                throw new TypeError('Invalid RID value provided.');
              }
            }
            if ('scaleResolutionDownBy' in encodingParam) {
              if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {
                throw new RangeError('scale_resolution_down_by must be >= 1.0');
              }
            }
            if ('maxFramerate' in encodingParam) {
              if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                throw new RangeError('max_framerate must be >= 0.0');
              }
            }
          });
        }
        const transceiver = origAddTransceiver.apply(this, arguments);
        if (shouldPerformCheck) {
          // Check if the init options were applied. If not we do this in an
          // asynchronous way and save the promise reference in a global object.
          // This is an ugly hack, but at the same time is way more robust than
          // checking the sender parameters before and after the createOffer
          // Also note that after the createoffer we are not 100% sure that
          // the params were asynchronously applied so we might miss the
          // opportunity to recreate offer.
          const {sender} = transceiver;
          const params = sender.getParameters();
          if (!('encodings' in params) ||
              // Avoid being fooled by patched getParameters() below.
              (params.encodings.length === 1 &&
               Object.keys(params.encodings[0]).length === 0)) {
            params.encodings = initParameters.sendEncodings;
            sender.sendEncodings = initParameters.sendEncodings;
            this.setParametersPromises.push(sender.setParameters(params)
              .then(() => {
                delete sender.sendEncodings;
              }).catch(() => {
                delete sender.sendEncodings;
              })
            );
          }
        }
        return transceiver;
      };
  }
}

function shimGetParameters(window) {
  if (!(typeof window === 'object' && window.RTCRtpSender)) {
    return;
  }
  const origGetParameters = window.RTCRtpSender.prototype.getParameters;
  if (origGetParameters) {
    window.RTCRtpSender.prototype.getParameters =
      function getParameters() {
        const params = origGetParameters.apply(this, arguments);
        if (!('encodings' in params)) {
          params.encodings = [].concat(this.sendEncodings || [{}]);
        }
        return params;
      };
  }
}

function shimCreateOffer(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!(typeof window === 'object' && window.RTCPeerConnection)) {
    return;
  }
  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
  window.RTCPeerConnection.prototype.createOffer = function createOffer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises)
      .then(() => {
        return origCreateOffer.apply(this, arguments);
      })
      .finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateOffer.apply(this, arguments);
  };
}

function shimCreateAnswer(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!(typeof window === 'object' && window.RTCPeerConnection)) {
    return;
  }
  const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;
  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises)
      .then(() => {
        return origCreateAnswer.apply(this, arguments);
      })
      .finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateAnswer.apply(this, arguments);
  };
}


/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js":
/*!***********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimGetDisplayMedia": function() { return /* binding */ shimGetDisplayMedia; }
/* harmony export */ });
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */


function shimGetDisplayMedia(window, preferredMediaSource) {
  if (window.navigator.mediaDevices &&
    'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  if (!(window.navigator.mediaDevices)) {
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia =
    function getDisplayMedia(constraints) {
      if (!(constraints && constraints.video)) {
        const err = new DOMException('getDisplayMedia without video ' +
            'constraints is undefined');
        err.name = 'NotFoundError';
        // from https://heycam.github.io/webidl/#idl-DOMException-error-names
        err.code = 8;
        return Promise.reject(err);
      }
      if (constraints.video === true) {
        constraints.video = {mediaSource: preferredMediaSource};
      } else {
        constraints.video.mediaSource = preferredMediaSource;
      }
      return window.navigator.mediaDevices.getUserMedia(constraints);
    };
}


/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimGetUserMedia": function() { return /* binding */ shimGetUserMedia; }
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/webrtc-adapter/src/js/utils.js");
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */




function shimGetUserMedia(window, browserDetails) {
  const navigator = window && window.navigator;
  const MediaStreamTrack = window && window.MediaStreamTrack;

  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('navigator.getUserMedia',
        'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };

  if (!(browserDetails.version > 55 &&
      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    const remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      if (typeof c === 'object' && typeof c.audio === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        const obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      const nativeApplyConstraints =
        MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c) {
        if (this.kind === 'audio' && typeof c === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
}


/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/safari/safari_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/safari/safari_shim.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimLocalStreamsAPI": function() { return /* binding */ shimLocalStreamsAPI; },
/* harmony export */   "shimRemoteStreamsAPI": function() { return /* binding */ shimRemoteStreamsAPI; },
/* harmony export */   "shimCallbacksAPI": function() { return /* binding */ shimCallbacksAPI; },
/* harmony export */   "shimGetUserMedia": function() { return /* binding */ shimGetUserMedia; },
/* harmony export */   "shimConstraints": function() { return /* binding */ shimConstraints; },
/* harmony export */   "shimRTCIceServerUrls": function() { return /* binding */ shimRTCIceServerUrls; },
/* harmony export */   "shimTrackEventTransceiver": function() { return /* binding */ shimTrackEventTransceiver; },
/* harmony export */   "shimCreateOfferLegacy": function() { return /* binding */ shimCreateOfferLegacy; },
/* harmony export */   "shimAudioContext": function() { return /* binding */ shimAudioContext; }
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/webrtc-adapter/src/js/utils.js");
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */



function shimLocalStreamsAPI(window) {
  if (typeof window !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.getLocalStreams =
      function getLocalStreams() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
  }
  if (!('addStream' in window.RTCPeerConnection.prototype)) {
    const _addTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      // Try to emulate Chrome's behaviour of adding in audio-video order.
      // Safari orders by track id.
      stream.getAudioTracks().forEach(track => _addTrack.call(this, track,
        stream));
      stream.getVideoTracks().forEach(track => _addTrack.call(this, track,
        stream));
    };

    window.RTCPeerConnection.prototype.addTrack =
      function addTrack(track, ...streams) {
        if (streams) {
          streams.forEach((stream) => {
            if (!this._localStreams) {
              this._localStreams = [stream];
            } else if (!this._localStreams.includes(stream)) {
              this._localStreams.push(stream);
            }
          });
        }
        return _addTrack.apply(this, arguments);
      };
  }
  if (!('removeStream' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.removeStream =
      function removeStream(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        const index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        const tracks = stream.getTracks();
        this.getSenders().forEach(sender => {
          if (tracks.includes(sender.track)) {
            this.removeTrack(sender);
          }
        });
      };
  }
}

function shimRemoteStreamsAPI(window) {
  if (typeof window !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.getRemoteStreams =
      function getRemoteStreams() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
  }
  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
      get() {
        return this._onaddstream;
      },
      set(f) {
        if (this._onaddstream) {
          this.removeEventListener('addstream', this._onaddstream);
          this.removeEventListener('track', this._onaddstreampoly);
        }
        this.addEventListener('addstream', this._onaddstream = f);
        this.addEventListener('track', this._onaddstreampoly = (e) => {
          e.streams.forEach(stream => {
            if (!this._remoteStreams) {
              this._remoteStreams = [];
            }
            if (this._remoteStreams.includes(stream)) {
              return;
            }
            this._remoteStreams.push(stream);
            const event = new Event('addstream');
            event.stream = stream;
            this.dispatchEvent(event);
          });
        });
      }
    });
    const origSetRemoteDescription =
      window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription =
      function setRemoteDescription() {
        const pc = this;
        if (!this._onaddstreampoly) {
          this.addEventListener('track', this._onaddstreampoly = function(e) {
            e.streams.forEach(stream => {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream);
              const event = new Event('addstream');
              event.stream = stream;
              pc.dispatchEvent(event);
            });
          });
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
  }
}

function shimCallbacksAPI(window) {
  if (typeof window !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  const prototype = window.RTCPeerConnection.prototype;
  const origCreateOffer = prototype.createOffer;
  const origCreateAnswer = prototype.createAnswer;
  const setLocalDescription = prototype.setLocalDescription;
  const setRemoteDescription = prototype.setRemoteDescription;
  const addIceCandidate = prototype.addIceCandidate;

  prototype.createOffer =
    function createOffer(successCallback, failureCallback) {
      const options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      const promise = origCreateOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

  prototype.createAnswer =
    function createAnswer(successCallback, failureCallback) {
      const options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      const promise = origCreateAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

  let withCallback = function(description, successCallback, failureCallback) {
    const promise = setLocalDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setLocalDescription = withCallback;

  withCallback = function(description, successCallback, failureCallback) {
    const promise = setRemoteDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setRemoteDescription = withCallback;

  withCallback = function(candidate, successCallback, failureCallback) {
    const promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.addIceCandidate = withCallback;
}

function shimGetUserMedia(window) {
  const navigator = window && window.navigator;

  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    // shim not needed in Safari 12.1
    const mediaDevices = navigator.mediaDevices;
    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator.mediaDevices.getUserMedia = (constraints) => {
      return _getUserMedia(shimConstraints(constraints));
    };
  }

  if (!navigator.getUserMedia && navigator.mediaDevices &&
    navigator.mediaDevices.getUserMedia) {
    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
      navigator.mediaDevices.getUserMedia(constraints)
      .then(cb, errcb);
    }.bind(navigator);
  }
}

function shimConstraints(constraints) {
  if (constraints && constraints.video !== undefined) {
    return Object.assign({},
      constraints,
      {video: _utils__WEBPACK_IMPORTED_MODULE_0__.compactObject(constraints.video)}
    );
  }

  return constraints;
}

function shimRTCIceServerUrls(window) {
  if (!window.RTCPeerConnection) {
    return;
  }
  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
  const OrigPeerConnection = window.RTCPeerConnection;
  window.RTCPeerConnection =
    function RTCPeerConnection(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        const newIceServers = [];
        for (let i = 0; i < pcConfig.iceServers.length; i++) {
          let server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty('urls') &&
              server.hasOwnProperty('url')) {
            _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  // wrap static methods. Currently just generateCertificate.
  if ('generateCertificate' in OrigPeerConnection) {
    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
      get() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
}

function shimTrackEventTransceiver(window) {
  // Add event.transceiver member over deprecated event.receiver
  if (typeof window === 'object' && window.RTCTrackEvent &&
      'receiver' in window.RTCTrackEvent.prototype &&
      !('transceiver' in window.RTCTrackEvent.prototype)) {
    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
      get() {
        return {receiver: this.receiver};
      }
    });
  }
}

function shimCreateOfferLegacy(window) {
  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
  window.RTCPeerConnection.prototype.createOffer =
    function createOffer(offerOptions) {
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveAudio =
            !!offerOptions.offerToReceiveAudio;
        }
        const audioTransceiver = this.getTransceivers().find(transceiver =>
          transceiver.receiver.track.kind === 'audio');
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === 'sendrecv') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('sendonly');
            } else {
              audioTransceiver.direction = 'sendonly';
            }
          } else if (audioTransceiver.direction === 'recvonly') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('inactive');
            } else {
              audioTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true &&
            !audioTransceiver) {
          this.addTransceiver('audio', {direction: 'recvonly'});
        }

        if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveVideo =
            !!offerOptions.offerToReceiveVideo;
        }
        const videoTransceiver = this.getTransceivers().find(transceiver =>
          transceiver.receiver.track.kind === 'video');
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === 'sendrecv') {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection('sendonly');
            } else {
              videoTransceiver.direction = 'sendonly';
            }
          } else if (videoTransceiver.direction === 'recvonly') {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection('inactive');
            } else {
              videoTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveVideo === true &&
            !videoTransceiver) {
          this.addTransceiver('video', {direction: 'recvonly'});
        }
      }
      return origCreateOffer.apply(this, arguments);
    };
}

function shimAudioContext(window) {
  if (typeof window !== 'object' || window.AudioContext) {
    return;
  }
  window.AudioContext = window.webkitAudioContext;
}



/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/utils.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "extractVersion": function() { return /* binding */ extractVersion; },
/* harmony export */   "wrapPeerConnectionEvent": function() { return /* binding */ wrapPeerConnectionEvent; },
/* harmony export */   "disableLog": function() { return /* binding */ disableLog; },
/* harmony export */   "disableWarnings": function() { return /* binding */ disableWarnings; },
/* harmony export */   "log": function() { return /* binding */ log; },
/* harmony export */   "deprecated": function() { return /* binding */ deprecated; },
/* harmony export */   "detectBrowser": function() { return /* binding */ detectBrowser; },
/* harmony export */   "compactObject": function() { return /* binding */ compactObject; },
/* harmony export */   "walkStats": function() { return /* binding */ walkStats; },
/* harmony export */   "filterStats": function() { return /* binding */ filterStats; }
/* harmony export */ });
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


let logDisabled_ = true;
let deprecationWarnings_ = true;

/**
 * Extract browser version out of the provided user agent string.
 *
 * @param {!string} uastring userAgent string.
 * @param {!string} expr Regular expression used as match criteria.
 * @param {!number} pos position in the version string to be returned.
 * @return {!number} browser version.
 */
function extractVersion(uastring, expr, pos) {
  const match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}

// Wraps the peerconnection event eventNameToWrap in a function
// which returns the modified event object (or false to prevent
// the event).
function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
  if (!window.RTCPeerConnection) {
    return;
  }
  const proto = window.RTCPeerConnection.prototype;
  const nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    const wrappedCallback = (e) => {
      const modifiedEvent = wrapper(e);
      if (modifiedEvent) {
        if (cb.handleEvent) {
          cb.handleEvent(modifiedEvent);
        } else {
          cb(modifiedEvent);
        }
      }
    };
    this._eventMap = this._eventMap || {};
    if (!this._eventMap[eventNameToWrap]) {
      this._eventMap[eventNameToWrap] = new Map();
    }
    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
    return nativeAddEventListener.apply(this, [nativeEventName,
      wrappedCallback]);
  };

  const nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap
        || !this._eventMap[eventNameToWrap]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    if (!this._eventMap[eventNameToWrap].has(cb)) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
    this._eventMap[eventNameToWrap].delete(cb);
    if (this._eventMap[eventNameToWrap].size === 0) {
      delete this._eventMap[eventNameToWrap];
    }
    if (Object.keys(this._eventMap).length === 0) {
      delete this._eventMap;
    }
    return nativeRemoveEventListener.apply(this, [nativeEventName,
      unwrappedCb]);
  };

  Object.defineProperty(proto, 'on' + eventNameToWrap, {
    get() {
      return this['_on' + eventNameToWrap];
    },
    set(cb) {
      if (this['_on' + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap]);
        delete this['_on' + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap] = cb);
      }
    },
    enumerable: true,
    configurable: true
  });
}

function disableLog(bool) {
  if (typeof bool !== 'boolean') {
    return new Error('Argument type: ' + typeof bool +
        '. Please use a boolean.');
  }
  logDisabled_ = bool;
  return (bool) ? 'adapter.js logging disabled' :
      'adapter.js logging enabled';
}

/**
 * Disable or enable deprecation warnings
 * @param {!boolean} bool set to true to disable warnings.
 */
function disableWarnings(bool) {
  if (typeof bool !== 'boolean') {
    return new Error('Argument type: ' + typeof bool +
        '. Please use a boolean.');
  }
  deprecationWarnings_ = !bool;
  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
}

function log() {
  if (typeof window === 'object') {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== 'undefined' && typeof console.log === 'function') {
      console.log.apply(console, arguments);
    }
  }
}

/**
 * Shows a deprecation warning suggesting the modern and spec-compatible API.
 */
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + ' is deprecated, please use ' + newMethod +
      ' instead.');
}

/**
 * Browser detector.
 *
 * @return {object} result containing browser and version
 *     properties.
 */
function detectBrowser(window) {
  // Returned result object.
  const result = {browser: null, version: null};

  // Fail early if it's not a browser
  if (typeof window === 'undefined' || !window.navigator) {
    result.browser = 'Not a browser.';
    return result;
  }

  const {navigator} = window;

  if (navigator.mozGetUserMedia) { // Firefox.
    result.browser = 'firefox';
    result.version = extractVersion(navigator.userAgent,
        /Firefox\/(\d+)\./, 1);
  } else if (navigator.webkitGetUserMedia ||
      (window.isSecureContext === false && window.webkitRTCPeerConnection &&
       !window.RTCIceGatherer)) {
    // Chrome, Chromium, Webview, Opera.
    // Version matches Chrome/WebRTC version.
    // Chrome 74 removed webkitGetUserMedia on http as well so we need the
    // more complicated fallback to webkitRTCPeerConnection.
    result.browser = 'chrome';
    result.version = extractVersion(navigator.userAgent,
        /Chrom(e|ium)\/(\d+)\./, 2);
  } else if (window.RTCPeerConnection &&
      navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) { // Safari.
    result.browser = 'safari';
    result.version = extractVersion(navigator.userAgent,
        /AppleWebKit\/(\d+)\./, 1);
    result.supportsUnifiedPlan = window.RTCRtpTransceiver &&
        'currentDirection' in window.RTCRtpTransceiver.prototype;
  } else { // Default fallthrough: not supported.
    result.browser = 'Not a supported browser.';
    return result;
  }

  return result;
}

/**
 * Checks if something is an object.
 *
 * @param {*} val The something you want to check.
 * @return true if val is an object, false otherwise.
 */
function isObject(val) {
  return Object.prototype.toString.call(val) === '[object Object]';
}

/**
 * Remove all empty objects and undefined values
 * from a nested object -- an enhanced and vanilla version
 * of Lodash's `compact`.
 */
function compactObject(data) {
  if (!isObject(data)) {
    return data;
  }

  return Object.keys(data).reduce(function(accumulator, key) {
    const isObj = isObject(data[key]);
    const value = isObj ? compactObject(data[key]) : data[key];
    const isEmptyObject = isObj && !Object.keys(value).length;
    if (value === undefined || isEmptyObject) {
      return accumulator;
    }
    return Object.assign(accumulator, {[key]: value});
  }, {});
}

/* iterates the stats graph recursively. */
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach(name => {
    if (name.endsWith('Id')) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith('Ids')) {
      base[name].forEach(id => {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}

/* filter getStats for a sender/receiver track. */
function filterStats(result, track, outbound) {
  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
  const filteredResult = new Map();
  if (track === null) {
    return filteredResult;
  }
  const trackStats = [];
  result.forEach(value => {
    if (value.type === 'track' &&
        value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach(trackStat => {
    result.forEach(stats => {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./node_modules/livekit-client/dist/index.js");
/******/ 	livekit = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2ViR0xUZW1wbGF0ZXMvRXhhbXBsZVRlbXBsYXRlL2xpdmVraXQtY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0EsVUFBVTtBQUNWLFdBQVcsWUFBWTtBQUN2QixXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLEdBQUc7QUFDZCxXQUFXLE1BQU07QUFDakIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7Ozs7OztBQ25EYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxLQUFLO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUs7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjLDBDQUEwQztBQUN4RDtBQUNBO0FBQ0Es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QzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUVBQW1FLFdBQVc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0I7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlCQUF5QjtBQUN6QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCO0FBQzFCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5QkFBeUI7QUFDekIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0M7QUFDaEMseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFNO0FBQ3JCLGVBQWUscUJBQU07QUFDckI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pwRGE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxpQkFBaUIsR0FBRyxvQ0FBb0MsR0FBRyw4QkFBOEIsR0FBRyx1QkFBdUIsR0FBRywrQkFBK0IsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyx1QkFBdUIsR0FBRywrQkFBK0IsR0FBRyw2QkFBNkIsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRywyQkFBMkIsR0FBRywwQkFBMEIsR0FBRyx5QkFBeUIsR0FBRywwQkFBMEIsR0FBRyw4QkFBOEIsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0IsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRywyQkFBMkIsR0FBRyxtQkFBbUIsR0FBRywwQkFBMEIsR0FBRyw0QkFBNEIsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUI7QUFDbDZCO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsNkNBQU07QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsZ0VBQW9CO0FBQzlELHlCQUF5QixtQkFBTyxDQUFDLG9GQUFrQjtBQUNuRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDLG9CQUFvQixLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDLG1CQUFtQixLQUFLO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QjtBQUM3QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0JBQStCO0FBQy9CLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFDQUFxQztBQUNyQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUM7QUFDakMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUNBQWlDO0FBQ2pDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQjtBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDO0FBQ2hDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0I7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdDQUFnQztBQUNoQyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQztBQUN0QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUNBQXFDO0FBQ3JDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrQkFBa0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxvRkFBb0Y7QUFDdEwsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFLDBFQUEwRTtBQUMxRSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNELDBCQUEwQixLQUFLO0FBQ3RGOzs7Ozs7Ozs7OztBQ25FYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyx3QkFBd0IsR0FBRyxpQkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DLGlCQUFpQixLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLFdBQVc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMkJBQTJCLEtBQUsseUNBQXlDO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDdkQsaUJBQWlCLG1CQUFPLENBQUMsb0VBQVc7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtB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QUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0IsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7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Ozs7Ozs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUVOO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRXFCOztBQUUzQjtBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksOENBQWdCO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDcUI7O0FBRTNCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRCxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOzs7Ozs7OztVQ3JRQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQSxlQUFlLDRCQUE0QjtXQUMzQyxlQUFlO1dBQ2YsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BELDhDQUE4Qzs7Ozs7V0NBOUM7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztVRU5BO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9hc3Byb21pc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9iYXNlNjQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9ldmVudGVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9mbG9hdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2lucXVpcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9wb29sL2luZGV4LmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvdXRmOC9pbmRleC5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L2FwaS9TaWduYWxDbGllbnQuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9sb2dnZXIuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L29wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L3Byb3RvL2xpdmVraXRfbW9kZWxzLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9wcm90by9saXZla2l0X3J0Yy5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3Qvcm9vbS9EZXZpY2VNYW5hZ2VyLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9yb29tL1BDVHJhbnNwb3J0LmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9yb29tL1JUQ0VuZ2luZS5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3Qvcm9vbS9Sb29tLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9yb29tL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3Qvcm9vbS9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L3Jvb20vcGFydGljaXBhbnQvTG9jYWxQYXJ0aWNpcGFudC5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3Qvcm9vbS9wYXJ0aWNpcGFudC9QYXJ0aWNpcGFudC5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3Qvcm9vbS9wYXJ0aWNpcGFudC9QYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbi5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3Qvcm9vbS9wYXJ0aWNpcGFudC9SZW1vdGVQYXJ0aWNpcGFudC5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3Qvcm9vbS9wYXJ0aWNpcGFudC9wdWJsaXNoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L3Jvb20vc3RhdHMuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L3Jvb20vdHJhY2svTG9jYWxBdWRpb1RyYWNrLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9yb29tL3RyYWNrL0xvY2FsVHJhY2suanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L3Jvb20vdHJhY2svTG9jYWxUcmFja1B1YmxpY2F0aW9uLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9yb29tL3RyYWNrL0xvY2FsVmlkZW9UcmFjay5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3Qvcm9vbS90cmFjay9SZW1vdGVBdWRpb1RyYWNrLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9yb29tL3RyYWNrL1JlbW90ZVRyYWNrLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9yb29tL3RyYWNrL1JlbW90ZVRyYWNrUHVibGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L3Jvb20vdHJhY2svUmVtb3RlVmlkZW9UcmFjay5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3Qvcm9vbS90cmFjay9UcmFjay5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3Qvcm9vbS90cmFjay9UcmFja1B1YmxpY2F0aW9uLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9yb29tL3RyYWNrL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3Qvcm9vbS90cmFjay9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3Qvcm9vbS90cmFjay9vcHRpb25zLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9yb29tL3RyYWNrL3R5cGVzLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9yb29tL3RyYWNrL3V0aWxzLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9yb29tL3V0aWxzLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC92ZXJzaW9uLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbWluaW1hbC5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LW1pbmltYWwuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXJfYnVmZmVyLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXIuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXJfYnVmZmVyLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvc2RwL3NkcC5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL3RzLWRlYm91bmNlL2Rpc3Qvc3JjL2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9hZGFwdGVyX2NvcmUuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvYWRhcHRlcl9mYWN0b3J5LmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2Nocm9tZS9jaHJvbWVfc2hpbS5qcyIsIndlYnBhY2s6Ly9saXZla2l0Ly4vbm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9jaHJvbWUvZ2V0ZGlzcGxheW1lZGlhLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2Nocm9tZS9nZXR1c2VybWVkaWEuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvY29tbW9uX3NoaW0uanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZmlyZWZveC9maXJlZm94X3NoaW0uanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZmlyZWZveC9nZXRkaXNwbGF5bWVkaWEuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZmlyZWZveC9nZXR1c2VybWVkaWEuanMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvc2FmYXJpL3NhZmFyaV9zaGltLmpzIiwid2VicGFjazovL2xpdmVraXQvLi9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL3V0aWxzLmpzIiwid2VicGFjazovL2xpdmVraXQvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9saXZla2l0L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9saXZla2l0L3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2xpdmVraXQvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9saXZla2l0L3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gYXNQcm9taXNlO1xyXG5cclxuLyoqXHJcbiAqIENhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwuYXNQcm9taXNlfS5cclxuICogQHR5cGVkZWYgYXNQcm9taXNlQ2FsbGJhY2tcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgQWRkaXRpb25hbCBhcmd1bWVudHNcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHByb21pc2UgZnJvbSBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7YXNQcm9taXNlQ2FsbGJhY2t9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIHsqfSBjdHggRnVuY3Rpb24gY29udGV4dFxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBGdW5jdGlvbiBhcmd1bWVudHNcclxuICogQHJldHVybnMge1Byb21pc2U8Kj59IFByb21pc2lmaWVkIGZ1bmN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBhc1Byb21pc2UoZm4sIGN0eC8qLCB2YXJhcmdzICovKSB7XHJcbiAgICB2YXIgcGFyYW1zICA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgb2Zmc2V0ICA9IDAsXHJcbiAgICAgICAgaW5kZXggICA9IDIsXHJcbiAgICAgICAgcGVuZGluZyA9IHRydWU7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbaW5kZXgrK107XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgcGFyYW1zW29mZnNldF0gPSBmdW5jdGlvbiBjYWxsYmFjayhlcnIvKiwgdmFyYXJncyAqLykge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycilcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBwYXJhbXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW29mZnNldF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZS5hcHBseShudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmbi5hcHBseShjdHggfHwgbnVsbCwgcGFyYW1zKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIGJhc2U2NCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG5iYXNlNjQubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIHAgPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgaWYgKCFwKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIG4gPSAwO1xyXG4gICAgd2hpbGUgKC0tcCAlIDQgPiAxICYmIHN0cmluZy5jaGFyQXQocCkgPT09IFwiPVwiKVxyXG4gICAgICAgICsrbjtcclxuICAgIHJldHVybiBNYXRoLmNlaWwoc3RyaW5nLmxlbmd0aCAqIDMpIC8gNCAtIG47XHJcbn07XHJcblxyXG4vLyBCYXNlNjQgZW5jb2RpbmcgdGFibGVcclxudmFyIGI2NCA9IG5ldyBBcnJheSg2NCk7XHJcblxyXG4vLyBCYXNlNjQgZGVjb2RpbmcgdGFibGVcclxudmFyIHM2NCA9IG5ldyBBcnJheSgxMjMpO1xyXG5cclxuLy8gNjUuLjkwLCA5Ny4uMTIyLCA0OC4uNTcsIDQzLCA0N1xyXG5mb3IgKHZhciBpID0gMDsgaSA8IDY0OylcclxuICAgIHM2NFtiNjRbaV0gPSBpIDwgMjYgPyBpICsgNjUgOiBpIDwgNTIgPyBpICsgNzEgOiBpIDwgNjIgPyBpIC0gNCA6IGkgLSA1OSB8IDQzXSA9IGkrKztcclxuXHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgYnVmZmVyIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuYmFzZTY0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXTtcclxuICAgIHZhciBpID0gMCwgLy8gb3V0cHV0IGluZGV4XHJcbiAgICAgICAgaiA9IDAsIC8vIGdvdG8gaW5kZXhcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB2YXIgYiA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiID4+IDJdO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiICYgMykgPDwgNDtcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNF07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAxNSkgPDwgMjtcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNl07XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgJiA2M107XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGopIHtcclxuICAgICAgICBjaHVua1tpKytdID0gYjY0W3RdO1xyXG4gICAgICAgIGNodW5rW2krK10gPSA2MTtcclxuICAgICAgICBpZiAoaiA9PT0gMSlcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbnZhciBpbnZhbGlkRW5jb2RpbmcgPSBcImludmFsaWQgZW5jb2RpbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBlbmNvZGluZyBpcyBpbnZhbGlkXHJcbiAqL1xyXG5iYXNlNjQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgIHZhciBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDspIHtcclxuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgaWYgKGMgPT09IDYxICYmIGogPiAxKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBpZiAoKGMgPSBzNjRbY10pID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICAgICAgc3dpdGNoIChqKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IHQgPDwgMiB8IChjICYgNDgpID4+IDQ7XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDE1KSA8PCA0IHwgKGMgJiA2MCkgPj4gMjtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMykgPDwgNiB8IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBzdHJpbmcgYXBwZWFycyB0byBiZSBiYXNlNjQgZW5jb2RlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHByb2JhYmx5IGJhc2U2NCBlbmNvZGVkLCBvdGhlcndpc2UgZmFsc2VcclxuICovXHJcbmJhc2U2NC50ZXN0ID0gZnVuY3Rpb24gdGVzdChzdHJpbmcpIHtcclxuICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzdHJpbmcpO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBldmVudCBlbWl0dGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEEgbWluaW1hbCBldmVudCBlbWl0dGVyLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBMaXN0ZW5lclxyXG4gKiBAcGFyYW0geyp9IFtjdHhdIExpc3RlbmVyIGNvbnRleHRcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldnQsIGZuLCBjdHgpIHtcclxuICAgICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSB8fCAodGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXSkpLnB1c2goe1xyXG4gICAgICAgIGZuICA6IGZuLFxyXG4gICAgICAgIGN0eCA6IGN0eCB8fCB0aGlzXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgb3IgYW55IG1hdGNoaW5nIGxpc3RlbmVycyBpZiBhcmd1bWVudHMgYXJlIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZ0XSBFdmVudCBuYW1lLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgaWYgb21pdHRlZC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZuXSBMaXN0ZW5lciB0byByZW1vdmUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBvZiBgZXZ0YCBpZiBvbWl0dGVkLlxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYoZXZ0LCBmbikge1xyXG4gICAgaWYgKGV2dCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGZuID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW107XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuKVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXRzIGFuIGV2ZW50IGJ5IGNhbGxpbmcgaXRzIGxpc3RlbmVycyB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcclxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdLFxyXG4gICAgICAgICAgICBpID0gMTtcclxuICAgICAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpKytdLmN0eCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZmFjdG9yeSk7XHJcblxyXG4vKipcclxuICogUmVhZHMgLyB3cml0ZXMgZmxvYXRzIC8gZG91YmxlcyBmcm9tIC8gdG8gYnVmZmVycy5cclxuICogQG5hbWUgdXRpbC5mbG9hdFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8vIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRoZSBwdXJwb3NlIG9mIG5vZGUtYmFzZWQgdGVzdGluZyBpbiBtb2RpZmllZCBnbG9iYWwgZW52aXJvbm1lbnRzXHJcbmZ1bmN0aW9uIGZhY3RvcnkoZXhwb3J0cykge1xyXG5cclxuICAgIC8vIGZsb2F0OiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoWyAtMCBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjMyLmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4YlszXSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfY3B5IDogd3JpdGVGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX3JldiA6IHdyaXRlRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gbGUgPyByZWFkRmxvYXRfZjMyX2NweSA6IHJlYWRGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9yZXYgOiByZWFkRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAvLyBmbG9hdDogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfaWVlZTc1NCh3cml0ZVVpbnQsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4odmFsKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQzMjg5MzQ0LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA+IDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpIC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxMzkwOTUwNDApID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IDEuMTc1NDk0MzUwODIyMjg3NWUtMzgpIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBNYXRoLnJvdW5kKHZhbCAvIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSkpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gTWF0aC5yb3VuZCh2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpICogODM4ODYwOCkgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMjcgPDwgMjMgfCBtYW50aXNzYSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9pZWVlNzU0KHJlYWRVaW50LCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgdWludCA9IHJlYWRVaW50KGJ1ZiwgcG9zKSxcclxuICAgICAgICAgICAgICAgIHNpZ24gPSAodWludCA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gdWludCA+Pj4gMjMgJiAyNTUsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHVpbnQgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDI1NVxyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxNTApICogKG1hbnRpc3NhICsgODM4ODYwOCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFKTtcclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIC8vIGRvdWJsZTogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmNjQgPSBuZXcgRmxvYXQ2NEFycmF5KFstMF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmNjQuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzddID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzddO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzddO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X2NweSA6IHdyaXRlRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9yZXYgOiB3cml0ZURvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9jcHkgOiByZWFkRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfcmV2IDogcmVhZERvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgIC8vIGRvdWJsZTogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2llZWU3NTQod3JpdGVVaW50LCBvZmYwLCBvZmYxLCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQ2OTU5MzYwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KSB7IC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjE0NjQzNTA3MikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFudGlzc2E7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsIDwgMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHsgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAvIDVlLTMyNDtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgbWFudGlzc2EgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gMTAyNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSAxMDIzO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgKiA0NTAzNTk5NjI3MzcwNDk2ID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTAyMyA8PCAyMCB8IG1hbnRpc3NhICogMTA0ODU3NiAmIDEwNDg1NzUpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfaWVlZTc1NChyZWFkVWludCwgb2ZmMCwgb2ZmMSwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIGxvID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYwKSxcclxuICAgICAgICAgICAgICAgIGhpID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSAoaGkgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IGhpID4+PiAyMCAmIDIwNDcsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IDQyOTQ5NjcyOTYgKiAoaGkgJiAxMDQ4NTc1KSArIGxvO1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDIwNDdcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogNWUtMzI0ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTA3NSkgKiAobWFudGlzc2EgKyA0NTAzNTk5NjI3MzcwNDk2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzO1xyXG59XHJcblxyXG4vLyB1aW50IGhlbHBlcnNcclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludExFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRCRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsID4+PiAyNDtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsICAgICAgICAmIDI1NTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRMRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF1cclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSA8PCAyNCkgPj4+IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50QkUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdIDw8IDI0XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10pID4+PiAwO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGlucXVpcmU7XHJcblxyXG4vKipcclxuICogUmVxdWlyZXMgYSBtb2R1bGUgb25seSBpZiBhdmFpbGFibGUuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIE1vZHVsZSB0byByZXF1aXJlXHJcbiAqIEByZXR1cm5zIHs/T2JqZWN0fSBSZXF1aXJlZCBtb2R1bGUgaWYgYXZhaWxhYmxlIGFuZCBub3QgZW1wdHksIG90aGVyd2lzZSBgbnVsbGBcclxuICovXHJcbmZ1bmN0aW9uIGlucXVpcmUobW9kdWxlTmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgbW9kID0gZXZhbChcInF1aXJlXCIucmVwbGFjZSgvXi8sXCJyZVwiKSkobW9kdWxlTmFtZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxyXG4gICAgICAgIGlmIChtb2QgJiYgKG1vZC5sZW5ndGggfHwgT2JqZWN0LmtleXMobW9kKS5sZW5ndGgpKVxyXG4gICAgICAgICAgICByZXR1cm4gbW9kO1xyXG4gICAgfSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gcG9vbDtcclxuXHJcbi8qKlxyXG4gKiBBbiBhbGxvY2F0b3IgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbEFsbG9jYXRvclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcclxuICovXHJcblxyXG4vKipcclxuICogQSBzbGljZXIgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbFNsaWNlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBvZmZzZXRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXIgc2xpY2VcclxuICogQHRoaXMge1VpbnQ4QXJyYXl9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgZ2VuZXJhbCBwdXJwb3NlIGJ1ZmZlciBwb29sLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtQb29sQWxsb2NhdG9yfSBhbGxvYyBBbGxvY2F0b3JcclxuICogQHBhcmFtIHtQb29sU2xpY2VyfSBzbGljZSBTbGljZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTgxOTJdIFNsYWIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7UG9vbEFsbG9jYXRvcn0gUG9vbGVkIGFsbG9jYXRvclxyXG4gKi9cclxuZnVuY3Rpb24gcG9vbChhbGxvYywgc2xpY2UsIHNpemUpIHtcclxuICAgIHZhciBTSVpFICAgPSBzaXplIHx8IDgxOTI7XHJcbiAgICB2YXIgTUFYICAgID0gU0laRSA+Pj4gMTtcclxuICAgIHZhciBzbGFiICAgPSBudWxsO1xyXG4gICAgdmFyIG9mZnNldCA9IFNJWkU7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcG9vbF9hbGxvYyhzaXplKSB7XHJcbiAgICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiBNQVgpXHJcbiAgICAgICAgICAgIHJldHVybiBhbGxvYyhzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICsgc2l6ZSA+IFNJWkUpIHtcclxuICAgICAgICAgICAgc2xhYiA9IGFsbG9jKFNJWkUpO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmID0gc2xpY2UuY2FsbChzbGFiLCBvZmZzZXQsIG9mZnNldCArPSBzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICYgNykgLy8gYWxpZ24gdG8gMzIgYml0XHJcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgfCA3KSArIDE7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZjtcclxuICAgIH07XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIFVURjggaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciB1dGY4ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBVVEY4IGJ5dGUgbGVuZ3RoIG9mIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxudXRmOC5sZW5ndGggPSBmdW5jdGlvbiB1dGY4X2xlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBsZW4gPSAwLFxyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpXHJcbiAgICAgICAgICAgIGxlbiArPSAxO1xyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMjtcclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgbGVuICs9IDQ7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGxlbiArPSAzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBVVEY4IGJ5dGVzIGFzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZWFkXHJcbiAqL1xyXG51dGY4LnJlYWQgPSBmdW5jdGlvbiB1dGY4X3JlYWQoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XHJcbiAgICBpZiAobGVuIDwgMSlcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXSxcclxuICAgICAgICBpID0gMCwgLy8gY2hhciBvZmZzZXRcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB0ID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIGlmICh0IDwgMTI4KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gdDtcclxuICAgICAgICBlbHNlIGlmICh0ID4gMTkxICYmIHQgPCAyMjQpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDMxKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDIzOSAmJiB0IDwgMzY1KSB7XHJcbiAgICAgICAgICAgIHQgPSAoKHQgJiA3KSA8PCAxOCB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MykgLSAweDEwMDAwO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEODAwICsgKHQgPj4gMTApO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEQzAwICsgKHQgJiAxMDIzKTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMTUpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc3RyaW5nIGFzIFVURjggYnl0ZXMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZXMgd3JpdHRlblxyXG4gKi9cclxudXRmOC53cml0ZSA9IGZ1bmN0aW9uIHV0Zjhfd3JpdGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgIGMxLCAvLyBjaGFyYWN0ZXIgMVxyXG4gICAgICAgIGMyOyAvLyBjaGFyYWN0ZXIgMlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjMSA8IDIwNDgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICAgICAgfCAxOTI7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKGMxICYgMHhGQzAwKSA9PT0gMHhEODAwICYmICgoYzIgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSkpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgIGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzRkYpIDw8IDEwKSArIChjMiAmIDB4MDNGRik7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDE4ICAgICAgfCAyNDA7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICAgICAgfCAyMjQ7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uID0gZXhwb3J0cy5TaWduYWxDbGllbnQgPSB2b2lkIDA7XG5yZXF1aXJlKFwid2VicnRjLWFkYXB0ZXJcIik7XG5jb25zdCBsb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbG9nZ2VyXCIpKTtcbmNvbnN0IGxpdmVraXRfcnRjXzEgPSByZXF1aXJlKFwiLi4vcHJvdG8vbGl2ZWtpdF9ydGNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9yb29tL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vcm9vbS91dGlsc1wiKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIFNpZ25hbENsaWVudCB7XG4gICAgY29uc3RydWN0b3IodXNlSlNPTiA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51c2VKU09OID0gdXNlSlNPTjtcbiAgICB9XG4gICAgam9pbih1cmwsIHRva2VuLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBkdXJpbmcgYSBmdWxsIHJlY29ubmVjdCwgd2UnZCB3YW50IHRvIHN0YXJ0IHRoZSBzZXF1ZW5jZSBldmVuIGlmIGN1cnJlbnRseVxuICAgICAgICAgICAgLy8gY29ubmVjdGVkXG4gICAgICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB5aWVsZCB0aGlzLmNvbm5lY3QodXJsLCB0b2tlbiwge1xuICAgICAgICAgICAgICAgIGF1dG9TdWJzY3JpYmU6IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5hdXRvU3Vic2NyaWJlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVjb25uZWN0KHVybCwgdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCh1cmwsIHRva2VuLCB7XG4gICAgICAgICAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KHVybCwgdG9rZW4sIG9wdHMpIHtcbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCdodHRwJywgJ3dzJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgICAgIHVybCArPSAnL3J0Yyc7XG4gICAgICAgIGNvbnN0IGNsaWVudEluZm8gPSB1dGlsc18xLmdldENsaWVudEluZm8oKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gY3JlYXRlQ29ubmVjdGlvblBhcmFtcyh0b2tlbiwgY2xpZW50SW5mbywgb3B0cyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCdjb25uZWN0aW5nIHRvJywgdXJsICsgcGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMud3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQodXJsICsgcGFyYW1zKTtcbiAgICAgICAgICAgIHdzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgd3Mub25lcnJvciA9IChldikgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy53cykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHlpZWxkIGZldGNoKGBodHRwJHt1cmwuc3Vic3RyaW5nKDIpfS92YWxpZGF0ZSR7cGFyYW1zfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0geWllbGQgcmVzcC50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcnNfMS5Db25uZWN0aW9uRXJyb3IobXNnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGVycm9yc18xLkNvbm5lY3Rpb25FcnJvcignSW50ZXJuYWwgZXJyb3InKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXJyb3JzXzEuQ29ubmVjdGlvbkVycm9yKCdzZXJ2ZXIgd2FzIG5vdCByZWFjaGFibGUnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvdGhlciBlcnJvcnMsIGhhbmRsZVxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlV1NFcnJvcihldik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndzID0gd3M7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMucmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwb24gcmVjb25uZWN0aW9uLCB0aGVyZSB3aWxsIG5vdCBiZSBhZGRpdGlvbmFsIGhhbmRzaGFrZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3cy5vbm1lc3NhZ2UgPSAoZXYpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgY29uc2lkZXJlZCBjb25uZWN0ZWQgdW50aWwgSm9pblJlc3BvbnNlIGlzIHJlY2VpdmVkXG4gICAgICAgICAgICAgICAgbGV0IG1zZztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV2LmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGV2LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSBsaXZla2l0X3J0Y18xLlNpZ25hbFJlc3BvbnNlLmZyb21KU09OKGpzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldi5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gbGl2ZWtpdF9ydGNfMS5TaWduYWxSZXNwb25zZS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoZXYuZGF0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5lcnJvcignY291bGQgbm90IGRlY29kZSB3ZWJzb2NrZXQgbWVzc2FnZScsIHR5cGVvZiBldi5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIGpvaW4gbWVzc2FnZSBvbmx5XG4gICAgICAgICAgICAgICAgICAgIGlmIChtc2cuam9pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1zZy5qb2luKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXJyb3JzXzEuQ29ubmVjdGlvbkVycm9yKCdkaWQgbm90IHJlY2VpdmUgam9pbiByZXNwb25zZScpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNpZ25hbExhdGVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdXRpbHNfMS5zbGVlcCh0aGlzLnNpZ25hbExhdGVuY3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNpZ25hbFJlc3BvbnNlKG1zZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdzLm9uY2xvc2UgPSAoZXYpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQgfHwgdGhpcy53cyAhPT0gd3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCd3ZWJzb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQnLCBldi5yZWFzb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkNsb3NlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoZXYucmVhc29uKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53cyA9PT0gd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy53cylcbiAgICAgICAgICAgIHRoaXMud3Mub25jbG9zZSA9IG51bGw7XG4gICAgICAgIChfYSA9IHRoaXMud3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgICB0aGlzLndzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBpbml0aWFsIG9mZmVyIGFmdGVyIGpvaW5pbmdcbiAgICBzZW5kT2ZmZXIob2ZmZXIpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZWJ1Zygnc2VuZGluZyBvZmZlcicsIG9mZmVyKTtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICAgICAgICBvZmZlcjogdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihvZmZlciksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBhbnN3ZXIgYSBzZXJ2ZXItaW5pdGlhdGVkIG9mZmVyXG4gICAgc2VuZEFuc3dlcihhbnN3ZXIpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZWJ1Zygnc2VuZGluZyBhbnN3ZXInKTtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICAgICAgICBhbnN3ZXI6IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oYW5zd2VyKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlLCB0YXJnZXQpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC50cmFjZSgnc2VuZGluZyBpY2UgY2FuZGlkYXRlJywgY2FuZGlkYXRlKTtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICAgICAgICB0cmlja2xlOiB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlSW5pdDogSlNPTi5zdHJpbmdpZnkoY2FuZGlkYXRlKSxcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZE11dGVUcmFjayh0cmFja1NpZCwgbXV0ZWQpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICAgICAgICBtdXRlOiB7XG4gICAgICAgICAgICAgICAgc2lkOiB0cmFja1NpZCxcbiAgICAgICAgICAgICAgICBtdXRlZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kQWRkVHJhY2socmVxKSB7XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgICAgICAgYWRkVHJhY2s6IGxpdmVraXRfcnRjXzEuQWRkVHJhY2tSZXF1ZXN0LmZyb21QYXJ0aWFsKHJlcSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KHsgdHJhY2tTZXR0aW5nOiBzZXR0aW5ncyB9KTtcbiAgICB9XG4gICAgc2VuZFVwZGF0ZVN1YnNjcmlwdGlvbihzdWIpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCh7IHN1YnNjcmlwdGlvbjogc3ViIH0pO1xuICAgIH1cbiAgICBzZW5kU3luY1N0YXRlKHN5bmMpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCh7IHN5bmNTdGF0ZTogc3luYyB9KTtcbiAgICB9XG4gICAgc2VuZFVwZGF0ZVZpZGVvTGF5ZXJzKHRyYWNrU2lkLCBsYXllcnMpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICAgICAgICB1cGRhdGVMYXllcnM6IHtcbiAgICAgICAgICAgICAgICB0cmFja1NpZCxcbiAgICAgICAgICAgICAgICBsYXllcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zKGFsbFBhcnRpY2lwYW50cywgdHJhY2tQZXJtaXNzaW9ucykge1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvblBlcm1pc3Npb246IHtcbiAgICAgICAgICAgICAgICBhbGxQYXJ0aWNpcGFudHMsXG4gICAgICAgICAgICAgICAgdHJhY2tQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kU2ltdWxhdGVTY2VuYXJpbyhzY2VuYXJpbykge1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgICAgICAgIHNpbXVsYXRlOiBzY2VuYXJpbyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChsaXZla2l0X3J0Y18xLlNpZ25hbFJlcXVlc3QuZnJvbVBhcnRpYWwoeyBsZWF2ZToge30gfSkpO1xuICAgIH1cbiAgICBzZW5kUmVxdWVzdChyZXEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpZ25hbExhdGVuY3kpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB1dGlsc18xLnNsZWVwKHRoaXMuc2lnbmFsTGF0ZW5jeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMud3MpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmVycm9yKCdjYW5ub3Qgc2VuZCBzaWduYWwgcmVxdWVzdCBiZWZvcmUgY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VKU09OKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3Muc2VuZChKU09OLnN0cmluZ2lmeShsaXZla2l0X3J0Y18xLlNpZ25hbFJlcXVlc3QudG9KU09OKHJlcSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3Muc2VuZChsaXZla2l0X3J0Y18xLlNpZ25hbFJlcXVlc3QuZW5jb2RlKHJlcSkuZmluaXNoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5lcnJvcignZXJyb3Igc2VuZGluZyBzaWduYWwgbWVzc2FnZScsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlU2lnbmFsUmVzcG9uc2UobXNnKSB7XG4gICAgICAgIGlmIChtc2cuYW5zd2VyKSB7XG4gICAgICAgICAgICBjb25zdCBzZCA9IGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihtc2cuYW5zd2VyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFuc3dlcihzZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXNnLm9mZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBzZCA9IGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihtc2cub2ZmZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMub25PZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMub25PZmZlcihzZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXNnLnRyaWNrbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IEpTT04ucGFyc2UobXNnLnRyaWNrbGUuY2FuZGlkYXRlSW5pdCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vblRyaWNrbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJpY2tsZShjYW5kaWRhdGUsIG1zZy50cmlja2xlLnRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXNnLnVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub25QYXJ0aWNpcGFudFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25QYXJ0aWNpcGFudFVwZGF0ZShtc2cudXBkYXRlLnBhcnRpY2lwYW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXNnLnRyYWNrUHVibGlzaGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZChtc2cudHJhY2tQdWJsaXNoZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zZy5zcGVha2Vyc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uU3BlYWtlcnNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblNwZWFrZXJzQ2hhbmdlZChtc2cuc3BlYWtlcnNDaGFuZ2VkLnNwZWFrZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cubGVhdmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uTGVhdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTGVhdmUobXNnLmxlYXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cubXV0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub25SZW1vdGVNdXRlQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25SZW1vdGVNdXRlQ2hhbmdlZChtc2cubXV0ZS5zaWQsIG1zZy5tdXRlLm11dGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cucm9vbVVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub25Sb29tVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblJvb21VcGRhdGUobXNnLnJvb21VcGRhdGUucm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXNnLmNvbm5lY3Rpb25RdWFsaXR5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vbkNvbm5lY3Rpb25RdWFsaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25RdWFsaXR5KG1zZy5jb25uZWN0aW9uUXVhbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXNnLnN0cmVhbVN0YXRlVXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vblN0cmVhbVN0YXRlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN0cmVhbVN0YXRlVXBkYXRlKG1zZy5zdHJlYW1TdGF0ZVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXNnLnN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKG1zZy5zdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXNnLnN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKG1zZy5zdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cucmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vblRva2VuUmVmcmVzaCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Ub2tlblJlZnJlc2gobXNnLnJlZnJlc2hUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCd1bnN1cHBvcnRlZCBtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVXU0Vycm9yKGV2KSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGV2KTtcbiAgICB9XG59XG5leHBvcnRzLlNpZ25hbENsaWVudCA9IFNpZ25hbENsaWVudDtcbmZ1bmN0aW9uIGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihzZCkge1xuICAgIGNvbnN0IHJzZCA9IHtcbiAgICAgICAgdHlwZTogJ29mZmVyJyxcbiAgICAgICAgc2RwOiBzZC5zZHAsXG4gICAgfTtcbiAgICBzd2l0Y2ggKHNkLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYW5zd2VyJzpcbiAgICAgICAgY2FzZSAnb2ZmZXInOlxuICAgICAgICBjYXNlICdwcmFuc3dlcic6XG4gICAgICAgIGNhc2UgJ3JvbGxiYWNrJzpcbiAgICAgICAgICAgIHJzZC50eXBlID0gc2QudHlwZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByc2Q7XG59XG5mdW5jdGlvbiB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHJzZCkge1xuICAgIGNvbnN0IHNkID0ge1xuICAgICAgICBzZHA6IHJzZC5zZHAsXG4gICAgICAgIHR5cGU6IHJzZC50eXBlLFxuICAgIH07XG4gICAgcmV0dXJuIHNkO1xufVxuZXhwb3J0cy50b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uID0gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbjtcbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25QYXJhbXModG9rZW4sIGluZm8sIG9wdHMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgcGFyYW1zLnNldCgnYWNjZXNzX3Rva2VuJywgdG9rZW4pO1xuICAgIC8vIG9wdHNcbiAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnJlY29ubmVjdCkge1xuICAgICAgICBwYXJhbXMuc2V0KCdyZWNvbm5lY3QnLCAnMScpO1xuICAgIH1cbiAgICBpZiAoKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5hdXRvU3Vic2NyaWJlKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoJ2F1dG9fc3Vic2NyaWJlJywgb3B0cy5hdXRvU3Vic2NyaWJlID8gJzEnIDogJzAnKTtcbiAgICB9XG4gICAgLy8gQ2xpZW50SW5mb1xuICAgIHBhcmFtcy5zZXQoJ3NkaycsICdqcycpO1xuICAgIHBhcmFtcy5zZXQoJ3ZlcnNpb24nLCBpbmZvLnZlcnNpb24pO1xuICAgIHBhcmFtcy5zZXQoJ3Byb3RvY29sJywgaW5mby5wcm90b2NvbC50b1N0cmluZygpKTtcbiAgICBpZiAoaW5mby5kZXZpY2VNb2RlbCkge1xuICAgICAgICBwYXJhbXMuc2V0KCdkZXZpY2VfbW9kZWwnLCBpbmZvLmRldmljZU1vZGVsKTtcbiAgICB9XG4gICAgaWYgKGluZm8ub3MpIHtcbiAgICAgICAgcGFyYW1zLnNldCgnb3MnLCBpbmZvLm9zKTtcbiAgICB9XG4gICAgaWYgKGluZm8ub3NWZXJzaW9uKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoJ29zX3ZlcnNpb24nLCBpbmZvLm9zVmVyc2lvbik7XG4gICAgfVxuICAgIGlmIChpbmZvLmJyb3dzZXIpIHtcbiAgICAgICAgcGFyYW1zLnNldCgnYnJvd3NlcicsIGluZm8uYnJvd3Nlcik7XG4gICAgfVxuICAgIGlmIChpbmZvLmJyb3dzZXJWZXJzaW9uKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoJ2Jyb3dzZXJfdmVyc2lvbicsIGluZm8uYnJvd3NlclZlcnNpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYD8ke3BhcmFtcy50b1N0cmluZygpfWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaWduYWxDbGllbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25uZWN0ID0gZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuY29uc3QgbG9nZ2VyXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbG9nZ2VyXCIpKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vcm9vbS9lcnJvcnNcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCIuL3Jvb20vZXZlbnRzXCIpO1xuY29uc3QgUm9vbV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Jvb20vUm9vbVwiKSk7XG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcnNpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZlcnNpb25fMS52ZXJzaW9uOyB9IH0pO1xuLyoqXG4gKiBDb25uZWN0cyB0byBhIExpdmVLaXQgcm9vbSwgc2hvcnRoYW5kIGZvciBgbmV3IFJvb20oKWAgYW5kIFtbUm9vbS5jb25uZWN0XV1cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25uZWN0KCd3c3M6Ly9teWhvc3QubGl2ZWtpdC5pbycsIHRva2VuLCB7XG4gKiAgIC8vIHB1Ymxpc2ggYXVkaW8gYW5kIHZpZGVvIHRyYWNrcyBvbiBqb2luaW5nXG4gKiAgIGF1ZGlvOiB0cnVlLFxuICogICB2aWRlbzogdHJ1ZSxcbiAqICAgY2FwdHVyZURlZmF1bHRzOiB7XG4gKiAgICBmYWNpbmdNb2RlOiAndXNlcicsXG4gKiAgIH0sXG4gKiB9KVxuICogYGBgXG4gKiBAcGFyYW0gdXJsIFVSTCB0byBMaXZlS2l0IHNlcnZlclxuICogQHBhcmFtIHRva2VuIEFjY2Vzc1Rva2VuLCBhIEpXVCB0b2tlbiB0aGF0IGluY2x1ZGVzIGF1dGhlbnRpY2F0aW9uIGFuZCByb29tIGRldGFpbHNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3QodXJsLCB0b2tlbiwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWRhcHRpdmVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5hZGFwdGl2ZVN0cmVhbSA9IG9wdGlvbnMuYXV0b01hbmFnZVZpZGVvO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLnNldExvZ0xldmVsKChfYSA9IG9wdGlvbnMubG9nTGV2ZWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGxvZ2dlcl8xLkxvZ0xldmVsLndhcm4pO1xuICAgICAgICBjb25zdCBjb25maWcgPSAoX2IgPSBvcHRpb25zLnJ0Y0NvbmZpZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gICAgICAgIGlmIChvcHRpb25zLmljZVNlcnZlcnMpIHtcbiAgICAgICAgICAgIGNvbmZpZy5pY2VTZXJ2ZXJzID0gb3B0aW9ucy5pY2VTZXJ2ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb20gPSBuZXcgUm9vbV8xLmRlZmF1bHQob3B0aW9ucyk7XG4gICAgICAgIC8vIGNvbm5lY3QgdG8gcm9vbVxuICAgICAgICB5aWVsZCByb29tLmNvbm5lY3QodXJsLCB0b2tlbiwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHB1Ymxpc2hBdWRpbyA9IChfYyA9IG9wdGlvbnMuYXVkaW8pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlO1xuICAgICAgICBjb25zdCBwdWJsaXNoVmlkZW8gPSAoX2QgPSBvcHRpb25zLnZpZGVvKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZTtcbiAgICAgICAgaWYgKHB1Ymxpc2hBdWRpbyB8fCBwdWJsaXNoVmlkZW8pIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHB1Ymxpc2hpbmcgYm90aFxuICAgICAgICAgICAgICAgIGxldCBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKHB1Ymxpc2hBdWRpbyAmJiBwdWJsaXNoVmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5lbmFibGVDYW1lcmFBbmRNaWNyb3Bob25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycktpbmQgPSBlcnJvcnNfMS5NZWRpYURldmljZUZhaWx1cmUuZ2V0RmFpbHVyZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQud2FybigncmVjZWl2ZWQgZXJyb3Igd2hpbGUgY3JlYXRpbmcgbWVkaWEnLCBlcnJLaW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0Lndhcm4oZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gaXQncyBhIGRldmljZSBpc3N1ZSwgdHJ5IHRvIHB1Ymxpc2ggdGhlIG90aGVyIGtpbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJLaW5kID09PSBlcnJvcnNfMS5NZWRpYURldmljZUZhaWx1cmUuTm90Rm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBlcnJLaW5kID09PSBlcnJvcnNfMS5NZWRpYURldmljZUZhaWx1cmUuRGV2aWNlSW5Vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCByb29tLmxvY2FsUGFydGljaXBhbnQuc2V0TWljcm9waG9uZUVuYWJsZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChhdWRpb0Vycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBhdWRpb0VycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHB1Ymxpc2hBdWRpbykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgcm9vbS5sb2NhbFBhcnRpY2lwYW50LnNldE1pY3JvcGhvbmVFbmFibGVkKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHB1Ymxpc2hWaWRlbykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgcm9vbS5sb2NhbFBhcnRpY2lwYW50LnNldENhbWVyYUVuYWJsZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByb29tLmVtaXQoZXZlbnRzXzEuUm9vbUV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmVycm9yKCdjb3VsZCBub3QgY3JlYXRlIG1lZGlhJywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb207XG4gICAgfSk7XG59XG5leHBvcnRzLmNvbm5lY3QgPSBjb25uZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmlkZW9RdWFsaXR5ID0gZXhwb3J0cy5UcmFja1B1YmxpY2F0aW9uID0gZXhwb3J0cy5SZW1vdGVUcmFja1B1YmxpY2F0aW9uID0gZXhwb3J0cy5SZW1vdGVWaWRlb1RyYWNrID0gZXhwb3J0cy5SZW1vdGVBdWRpb1RyYWNrID0gZXhwb3J0cy5SZW1vdGVUcmFjayA9IGV4cG9ydHMuTG9jYWxUcmFja1B1YmxpY2F0aW9uID0gZXhwb3J0cy5Mb2NhbFRyYWNrID0gZXhwb3J0cy5Mb2NhbFZpZGVvVHJhY2sgPSBleHBvcnRzLkxvY2FsQXVkaW9UcmFjayA9IGV4cG9ydHMuTG9jYWxQYXJ0aWNpcGFudCA9IGV4cG9ydHMuUmVtb3RlUGFydGljaXBhbnQgPSBleHBvcnRzLlBhcnRpY2lwYW50ID0gZXhwb3J0cy5Db25uZWN0aW9uUXVhbGl0eSA9IGV4cG9ydHMuRGF0YVBhY2tldF9LaW5kID0gZXhwb3J0cy5Sb29tU3RhdGUgPSBleHBvcnRzLlJvb20gPSBleHBvcnRzLnNldExvZ0xldmVsID0gdm9pZCAwO1xuY29uc3QgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXRMb2dMZXZlbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2VyXzEuc2V0TG9nTGV2ZWw7IH0gfSk7XG5jb25zdCBsaXZla2l0X21vZGVsc18xID0gcmVxdWlyZShcIi4vcHJvdG8vbGl2ZWtpdF9tb2RlbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRhUGFja2V0X0tpbmRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpdmVraXRfbW9kZWxzXzEuRGF0YVBhY2tldF9LaW5kOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmlkZW9RdWFsaXR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaXZla2l0X21vZGVsc18xLlZpZGVvUXVhbGl0eTsgfSB9KTtcbmNvbnN0IExvY2FsUGFydGljaXBhbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yb29tL3BhcnRpY2lwYW50L0xvY2FsUGFydGljaXBhbnRcIikpO1xuZXhwb3J0cy5Mb2NhbFBhcnRpY2lwYW50ID0gTG9jYWxQYXJ0aWNpcGFudF8xLmRlZmF1bHQ7XG5jb25zdCBQYXJ0aWNpcGFudF8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3Jvb20vcGFydGljaXBhbnQvUGFydGljaXBhbnRcIikpO1xuZXhwb3J0cy5QYXJ0aWNpcGFudCA9IFBhcnRpY2lwYW50XzEuZGVmYXVsdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25RdWFsaXR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQYXJ0aWNpcGFudF8xLkNvbm5lY3Rpb25RdWFsaXR5OyB9IH0pO1xuY29uc3QgUmVtb3RlUGFydGljaXBhbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yb29tL3BhcnRpY2lwYW50L1JlbW90ZVBhcnRpY2lwYW50XCIpKTtcbmV4cG9ydHMuUmVtb3RlUGFydGljaXBhbnQgPSBSZW1vdGVQYXJ0aWNpcGFudF8xLmRlZmF1bHQ7XG5jb25zdCBSb29tXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcm9vbS9Sb29tXCIpKTtcbmV4cG9ydHMuUm9vbSA9IFJvb21fMS5kZWZhdWx0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUm9vbVN0YXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSb29tXzEuUm9vbVN0YXRlOyB9IH0pO1xuY29uc3QgTG9jYWxBdWRpb1RyYWNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcm9vbS90cmFjay9Mb2NhbEF1ZGlvVHJhY2tcIikpO1xuZXhwb3J0cy5Mb2NhbEF1ZGlvVHJhY2sgPSBMb2NhbEF1ZGlvVHJhY2tfMS5kZWZhdWx0O1xuY29uc3QgTG9jYWxUcmFja18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Jvb20vdHJhY2svTG9jYWxUcmFja1wiKSk7XG5leHBvcnRzLkxvY2FsVHJhY2sgPSBMb2NhbFRyYWNrXzEuZGVmYXVsdDtcbmNvbnN0IExvY2FsVHJhY2tQdWJsaWNhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Jvb20vdHJhY2svTG9jYWxUcmFja1B1YmxpY2F0aW9uXCIpKTtcbmV4cG9ydHMuTG9jYWxUcmFja1B1YmxpY2F0aW9uID0gTG9jYWxUcmFja1B1YmxpY2F0aW9uXzEuZGVmYXVsdDtcbmNvbnN0IExvY2FsVmlkZW9UcmFja18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Jvb20vdHJhY2svTG9jYWxWaWRlb1RyYWNrXCIpKTtcbmV4cG9ydHMuTG9jYWxWaWRlb1RyYWNrID0gTG9jYWxWaWRlb1RyYWNrXzEuZGVmYXVsdDtcbmNvbnN0IFJlbW90ZUF1ZGlvVHJhY2tfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yb29tL3RyYWNrL1JlbW90ZUF1ZGlvVHJhY2tcIikpO1xuZXhwb3J0cy5SZW1vdGVBdWRpb1RyYWNrID0gUmVtb3RlQXVkaW9UcmFja18xLmRlZmF1bHQ7XG5jb25zdCBSZW1vdGVUcmFja18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Jvb20vdHJhY2svUmVtb3RlVHJhY2tcIikpO1xuZXhwb3J0cy5SZW1vdGVUcmFjayA9IFJlbW90ZVRyYWNrXzEuZGVmYXVsdDtcbmNvbnN0IFJlbW90ZVRyYWNrUHVibGljYXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yb29tL3RyYWNrL1JlbW90ZVRyYWNrUHVibGljYXRpb25cIikpO1xuZXhwb3J0cy5SZW1vdGVUcmFja1B1YmxpY2F0aW9uID0gUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl8xLmRlZmF1bHQ7XG5jb25zdCBSZW1vdGVWaWRlb1RyYWNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcm9vbS90cmFjay9SZW1vdGVWaWRlb1RyYWNrXCIpKTtcbmV4cG9ydHMuUmVtb3RlVmlkZW9UcmFjayA9IFJlbW90ZVZpZGVvVHJhY2tfMS5kZWZhdWx0O1xuY29uc3QgVHJhY2tQdWJsaWNhdGlvbl8xID0gcmVxdWlyZShcIi4vcm9vbS90cmFjay9UcmFja1B1YmxpY2F0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2tQdWJsaWNhdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVHJhY2tQdWJsaWNhdGlvbl8xLlRyYWNrUHVibGljYXRpb247IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29ubmVjdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcm9vbS9lcnJvcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Jvb20vZXZlbnRzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yb29tL3RyYWNrL2NyZWF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcm9vbS90cmFjay9vcHRpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yb29tL3RyYWNrL1RyYWNrXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yb29tL3RyYWNrL3R5cGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92ZXJzaW9uXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGV4cG9ydHMuTG9nTGV2ZWwgPSB2b2lkIDA7XG5jb25zdCBsb2dsZXZlbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2dsZXZlbFwiKSk7XG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbXCJ0cmFjZVwiXSA9IFwidHJhY2VcIjtcbiAgICBMb2dMZXZlbFtcImRlYnVnXCJdID0gXCJkZWJ1Z1wiO1xuICAgIExvZ0xldmVsW1wiaW5mb1wiXSA9IFwiaW5mb1wiO1xuICAgIExvZ0xldmVsW1wid2FyblwiXSA9IFwid2FyblwiO1xuICAgIExvZ0xldmVsW1wiZXJyb3JcIl0gPSBcImVycm9yXCI7XG4gICAgTG9nTGV2ZWxbXCJzaWxlbnRcIl0gPSBcInNpbGVudFwiO1xufSkoTG9nTGV2ZWwgPSBleHBvcnRzLkxvZ0xldmVsIHx8IChleHBvcnRzLkxvZ0xldmVsID0ge30pKTtcbmNvbnN0IGxpdmVraXRMb2dnZXIgPSBsb2dsZXZlbF8xLmRlZmF1bHQuZ2V0TG9nZ2VyKCdsaXZla2l0Jyk7XG5saXZla2l0TG9nZ2VyLnNldExldmVsKExvZ0xldmVsLmluZm8pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbGl2ZWtpdExvZ2dlcjtcbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gICAgbGl2ZWtpdExvZ2dlci5zZXRMZXZlbChsZXZlbCk7XG59XG5leHBvcnRzLnNldExvZ0xldmVsID0gc2V0TG9nTGV2ZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGllbnRJbmZvID0gZXhwb3J0cy5QYXJ0aWNpcGFudFRyYWNrcyA9IGV4cG9ydHMuVXNlclBhY2tldCA9IGV4cG9ydHMuU3BlYWtlckluZm8gPSBleHBvcnRzLkFjdGl2ZVNwZWFrZXJVcGRhdGUgPSBleHBvcnRzLkRhdGFQYWNrZXQgPSBleHBvcnRzLlZpZGVvTGF5ZXIgPSBleHBvcnRzLlRyYWNrSW5mbyA9IGV4cG9ydHMuUGFydGljaXBhbnRJbmZvID0gZXhwb3J0cy5Db2RlYyA9IGV4cG9ydHMuUm9vbSA9IGV4cG9ydHMuY2xpZW50SW5mb19TREtUb0pTT04gPSBleHBvcnRzLmNsaWVudEluZm9fU0RLRnJvbUpTT04gPSBleHBvcnRzLkNsaWVudEluZm9fU0RLID0gZXhwb3J0cy5kYXRhUGFja2V0X0tpbmRUb0pTT04gPSBleHBvcnRzLmRhdGFQYWNrZXRfS2luZEZyb21KU09OID0gZXhwb3J0cy5EYXRhUGFja2V0X0tpbmQgPSBleHBvcnRzLnBhcnRpY2lwYW50SW5mb19TdGF0ZVRvSlNPTiA9IGV4cG9ydHMucGFydGljaXBhbnRJbmZvX1N0YXRlRnJvbUpTT04gPSBleHBvcnRzLlBhcnRpY2lwYW50SW5mb19TdGF0ZSA9IGV4cG9ydHMuY29ubmVjdGlvblF1YWxpdHlUb0pTT04gPSBleHBvcnRzLmNvbm5lY3Rpb25RdWFsaXR5RnJvbUpTT04gPSBleHBvcnRzLkNvbm5lY3Rpb25RdWFsaXR5ID0gZXhwb3J0cy52aWRlb1F1YWxpdHlUb0pTT04gPSBleHBvcnRzLnZpZGVvUXVhbGl0eUZyb21KU09OID0gZXhwb3J0cy5WaWRlb1F1YWxpdHkgPSBleHBvcnRzLnRyYWNrU291cmNlVG9KU09OID0gZXhwb3J0cy50cmFja1NvdXJjZUZyb21KU09OID0gZXhwb3J0cy5UcmFja1NvdXJjZSA9IGV4cG9ydHMudHJhY2tUeXBlVG9KU09OID0gZXhwb3J0cy50cmFja1R5cGVGcm9tSlNPTiA9IGV4cG9ydHMuVHJhY2tUeXBlID0gZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY29uc3QgbG9uZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb25nXCIpKTtcbmNvbnN0IG1pbmltYWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicHJvdG9idWZqcy9taW5pbWFsXCIpKTtcbmV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gXCJsaXZla2l0XCI7XG52YXIgVHJhY2tUeXBlO1xuKGZ1bmN0aW9uIChUcmFja1R5cGUpIHtcbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiQVVESU9cIl0gPSAwXSA9IFwiQVVESU9cIjtcbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiVklERU9cIl0gPSAxXSA9IFwiVklERU9cIjtcbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiREFUQVwiXSA9IDJdID0gXCJEQVRBXCI7XG4gICAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShUcmFja1R5cGUgPSBleHBvcnRzLlRyYWNrVHlwZSB8fCAoZXhwb3J0cy5UcmFja1R5cGUgPSB7fSkpO1xuZnVuY3Rpb24gdHJhY2tUeXBlRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiQVVESU9cIjpcbiAgICAgICAgICAgIHJldHVybiBUcmFja1R5cGUuQVVESU87XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIlZJREVPXCI6XG4gICAgICAgICAgICByZXR1cm4gVHJhY2tUeXBlLlZJREVPO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgXCJEQVRBXCI6XG4gICAgICAgICAgICByZXR1cm4gVHJhY2tUeXBlLkRBVEE7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgXCJVTlJFQ09HTklaRURcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBUcmFja1R5cGUuVU5SRUNPR05JWkVEO1xuICAgIH1cbn1cbmV4cG9ydHMudHJhY2tUeXBlRnJvbUpTT04gPSB0cmFja1R5cGVGcm9tSlNPTjtcbmZ1bmN0aW9uIHRyYWNrVHlwZVRvSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIFRyYWNrVHlwZS5BVURJTzpcbiAgICAgICAgICAgIHJldHVybiBcIkFVRElPXCI7XG4gICAgICAgIGNhc2UgVHJhY2tUeXBlLlZJREVPOlxuICAgICAgICAgICAgcmV0dXJuIFwiVklERU9cIjtcbiAgICAgICAgY2FzZSBUcmFja1R5cGUuREFUQTpcbiAgICAgICAgICAgIHJldHVybiBcIkRBVEFcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOS05PV05cIjtcbiAgICB9XG59XG5leHBvcnRzLnRyYWNrVHlwZVRvSlNPTiA9IHRyYWNrVHlwZVRvSlNPTjtcbnZhciBUcmFja1NvdXJjZTtcbihmdW5jdGlvbiAoVHJhY2tTb3VyY2UpIHtcbiAgICBUcmFja1NvdXJjZVtUcmFja1NvdXJjZVtcIlVOS05PV05cIl0gPSAwXSA9IFwiVU5LTk9XTlwiO1xuICAgIFRyYWNrU291cmNlW1RyYWNrU291cmNlW1wiQ0FNRVJBXCJdID0gMV0gPSBcIkNBTUVSQVwiO1xuICAgIFRyYWNrU291cmNlW1RyYWNrU291cmNlW1wiTUlDUk9QSE9ORVwiXSA9IDJdID0gXCJNSUNST1BIT05FXCI7XG4gICAgVHJhY2tTb3VyY2VbVHJhY2tTb3VyY2VbXCJTQ1JFRU5fU0hBUkVcIl0gPSAzXSA9IFwiU0NSRUVOX1NIQVJFXCI7XG4gICAgVHJhY2tTb3VyY2VbVHJhY2tTb3VyY2VbXCJTQ1JFRU5fU0hBUkVfQVVESU9cIl0gPSA0XSA9IFwiU0NSRUVOX1NIQVJFX0FVRElPXCI7XG4gICAgVHJhY2tTb3VyY2VbVHJhY2tTb3VyY2VbXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoVHJhY2tTb3VyY2UgPSBleHBvcnRzLlRyYWNrU291cmNlIHx8IChleHBvcnRzLlRyYWNrU291cmNlID0ge30pKTtcbmZ1bmN0aW9uIHRyYWNrU291cmNlRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiVU5LTk9XTlwiOlxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlVOS05PV047XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIkNBTUVSQVwiOlxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLkNBTUVSQTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIFwiTUlDUk9QSE9ORVwiOlxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSBcIlNDUkVFTl9TSEFSRVwiOlxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIFwiU0NSRUVOX1NIQVJFX0FVRElPXCI6XG4gICAgICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFX0FVRElPO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuVU5SRUNPR05JWkVEO1xuICAgIH1cbn1cbmV4cG9ydHMudHJhY2tTb3VyY2VGcm9tSlNPTiA9IHRyYWNrU291cmNlRnJvbUpTT047XG5mdW5jdGlvbiB0cmFja1NvdXJjZVRvSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIFRyYWNrU291cmNlLlVOS05PV046XG4gICAgICAgICAgICByZXR1cm4gXCJVTktOT1dOXCI7XG4gICAgICAgIGNhc2UgVHJhY2tTb3VyY2UuQ0FNRVJBOlxuICAgICAgICAgICAgcmV0dXJuIFwiQ0FNRVJBXCI7XG4gICAgICAgIGNhc2UgVHJhY2tTb3VyY2UuTUlDUk9QSE9ORTpcbiAgICAgICAgICAgIHJldHVybiBcIk1JQ1JPUEhPTkVcIjtcbiAgICAgICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkU6XG4gICAgICAgICAgICByZXR1cm4gXCJTQ1JFRU5fU0hBUkVcIjtcbiAgICAgICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkVfQVVESU86XG4gICAgICAgICAgICByZXR1cm4gXCJTQ1JFRU5fU0hBUkVfQVVESU9cIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOS05PV05cIjtcbiAgICB9XG59XG5leHBvcnRzLnRyYWNrU291cmNlVG9KU09OID0gdHJhY2tTb3VyY2VUb0pTT047XG52YXIgVmlkZW9RdWFsaXR5O1xuKGZ1bmN0aW9uIChWaWRlb1F1YWxpdHkpIHtcbiAgICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiTE9XXCJdID0gMF0gPSBcIkxPV1wiO1xuICAgIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJNRURJVU1cIl0gPSAxXSA9IFwiTUVESVVNXCI7XG4gICAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIkhJR0hcIl0gPSAyXSA9IFwiSElHSFwiO1xuICAgIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJPRkZcIl0gPSAzXSA9IFwiT0ZGXCI7XG4gICAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShWaWRlb1F1YWxpdHkgPSBleHBvcnRzLlZpZGVvUXVhbGl0eSB8fCAoZXhwb3J0cy5WaWRlb1F1YWxpdHkgPSB7fSkpO1xuZnVuY3Rpb24gdmlkZW9RdWFsaXR5RnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiTE9XXCI6XG4gICAgICAgICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkxPVztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIFwiTUVESVVNXCI6XG4gICAgICAgICAgICByZXR1cm4gVmlkZW9RdWFsaXR5Lk1FRElVTTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIFwiSElHSFwiOlxuICAgICAgICAgICAgcmV0dXJuIFZpZGVvUXVhbGl0eS5ISUdIO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgXCJPRkZcIjpcbiAgICAgICAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuT0ZGO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnRzLnZpZGVvUXVhbGl0eUZyb21KU09OID0gdmlkZW9RdWFsaXR5RnJvbUpTT047XG5mdW5jdGlvbiB2aWRlb1F1YWxpdHlUb0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBWaWRlb1F1YWxpdHkuTE9XOlxuICAgICAgICAgICAgcmV0dXJuIFwiTE9XXCI7XG4gICAgICAgIGNhc2UgVmlkZW9RdWFsaXR5Lk1FRElVTTpcbiAgICAgICAgICAgIHJldHVybiBcIk1FRElVTVwiO1xuICAgICAgICBjYXNlIFZpZGVvUXVhbGl0eS5ISUdIOlxuICAgICAgICAgICAgcmV0dXJuIFwiSElHSFwiO1xuICAgICAgICBjYXNlIFZpZGVvUXVhbGl0eS5PRkY6XG4gICAgICAgICAgICByZXR1cm4gXCJPRkZcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOS05PV05cIjtcbiAgICB9XG59XG5leHBvcnRzLnZpZGVvUXVhbGl0eVRvSlNPTiA9IHZpZGVvUXVhbGl0eVRvSlNPTjtcbnZhciBDb25uZWN0aW9uUXVhbGl0eTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICBDb25uZWN0aW9uUXVhbGl0eVtDb25uZWN0aW9uUXVhbGl0eVtcIlBPT1JcIl0gPSAwXSA9IFwiUE9PUlwiO1xuICAgIENvbm5lY3Rpb25RdWFsaXR5W0Nvbm5lY3Rpb25RdWFsaXR5W1wiR09PRFwiXSA9IDFdID0gXCJHT09EXCI7XG4gICAgQ29ubmVjdGlvblF1YWxpdHlbQ29ubmVjdGlvblF1YWxpdHlbXCJFWENFTExFTlRcIl0gPSAyXSA9IFwiRVhDRUxMRU5UXCI7XG4gICAgQ29ubmVjdGlvblF1YWxpdHlbQ29ubmVjdGlvblF1YWxpdHlbXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoQ29ubmVjdGlvblF1YWxpdHkgPSBleHBvcnRzLkNvbm5lY3Rpb25RdWFsaXR5IHx8IChleHBvcnRzLkNvbm5lY3Rpb25RdWFsaXR5ID0ge30pKTtcbmZ1bmN0aW9uIGNvbm5lY3Rpb25RdWFsaXR5RnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiUE9PUlwiOlxuICAgICAgICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LlBPT1I7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIkdPT0RcIjpcbiAgICAgICAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5HT09EO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgXCJFWENFTExFTlRcIjpcbiAgICAgICAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5FWENFTExFTlQ7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgXCJVTlJFQ09HTklaRURcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0cy5jb25uZWN0aW9uUXVhbGl0eUZyb21KU09OID0gY29ubmVjdGlvblF1YWxpdHlGcm9tSlNPTjtcbmZ1bmN0aW9uIGNvbm5lY3Rpb25RdWFsaXR5VG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvblF1YWxpdHkuUE9PUjpcbiAgICAgICAgICAgIHJldHVybiBcIlBPT1JcIjtcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eS5HT09EOlxuICAgICAgICAgICAgcmV0dXJuIFwiR09PRFwiO1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25RdWFsaXR5LkVYQ0VMTEVOVDpcbiAgICAgICAgICAgIHJldHVybiBcIkVYQ0VMTEVOVFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5LTk9XTlwiO1xuICAgIH1cbn1cbmV4cG9ydHMuY29ubmVjdGlvblF1YWxpdHlUb0pTT04gPSBjb25uZWN0aW9uUXVhbGl0eVRvSlNPTjtcbnZhciBQYXJ0aWNpcGFudEluZm9fU3RhdGU7XG4oZnVuY3Rpb24gKFBhcnRpY2lwYW50SW5mb19TdGF0ZSkge1xuICAgIC8qKiBKT0lOSU5HIC0gd2Vic29ja2V0JyBjb25uZWN0ZWQsIGJ1dCBub3Qgb2ZmZXJlZCB5ZXQgKi9cbiAgICBQYXJ0aWNpcGFudEluZm9fU3RhdGVbUGFydGljaXBhbnRJbmZvX1N0YXRlW1wiSk9JTklOR1wiXSA9IDBdID0gXCJKT0lOSU5HXCI7XG4gICAgLyoqIEpPSU5FRCAtIHNlcnZlciByZWNlaXZlZCBjbGllbnQgb2ZmZXIgKi9cbiAgICBQYXJ0aWNpcGFudEluZm9fU3RhdGVbUGFydGljaXBhbnRJbmZvX1N0YXRlW1wiSk9JTkVEXCJdID0gMV0gPSBcIkpPSU5FRFwiO1xuICAgIC8qKiBBQ1RJVkUgLSBJQ0UgY29ubmVjdGl2aXR5IGVzdGFibGlzaGVkICovXG4gICAgUGFydGljaXBhbnRJbmZvX1N0YXRlW1BhcnRpY2lwYW50SW5mb19TdGF0ZVtcIkFDVElWRVwiXSA9IDJdID0gXCJBQ1RJVkVcIjtcbiAgICAvKiogRElTQ09OTkVDVEVEIC0gV1MgZGlzY29ubmVjdGVkICovXG4gICAgUGFydGljaXBhbnRJbmZvX1N0YXRlW1BhcnRpY2lwYW50SW5mb19TdGF0ZVtcIkRJU0NPTk5FQ1RFRFwiXSA9IDNdID0gXCJESVNDT05ORUNURURcIjtcbiAgICBQYXJ0aWNpcGFudEluZm9fU3RhdGVbUGFydGljaXBhbnRJbmZvX1N0YXRlW1wiVU5SRUNPR05JWkVEXCJdID0gLTFdID0gXCJVTlJFQ09HTklaRURcIjtcbn0pKFBhcnRpY2lwYW50SW5mb19TdGF0ZSA9IGV4cG9ydHMuUGFydGljaXBhbnRJbmZvX1N0YXRlIHx8IChleHBvcnRzLlBhcnRpY2lwYW50SW5mb19TdGF0ZSA9IHt9KSk7XG5mdW5jdGlvbiBwYXJ0aWNpcGFudEluZm9fU3RhdGVGcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgXCJKT0lOSU5HXCI6XG4gICAgICAgICAgICByZXR1cm4gUGFydGljaXBhbnRJbmZvX1N0YXRlLkpPSU5JTkc7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIkpPSU5FRFwiOlxuICAgICAgICAgICAgcmV0dXJuIFBhcnRpY2lwYW50SW5mb19TdGF0ZS5KT0lORUQ7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSBcIkFDVElWRVwiOlxuICAgICAgICAgICAgcmV0dXJuIFBhcnRpY2lwYW50SW5mb19TdGF0ZS5BQ1RJVkU7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSBcIkRJU0NPTk5FQ1RFRFwiOlxuICAgICAgICAgICAgcmV0dXJuIFBhcnRpY2lwYW50SW5mb19TdGF0ZS5ESVNDT05ORUNURUQ7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgXCJVTlJFQ09HTklaRURcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBQYXJ0aWNpcGFudEluZm9fU3RhdGUuVU5SRUNPR05JWkVEO1xuICAgIH1cbn1cbmV4cG9ydHMucGFydGljaXBhbnRJbmZvX1N0YXRlRnJvbUpTT04gPSBwYXJ0aWNpcGFudEluZm9fU3RhdGVGcm9tSlNPTjtcbmZ1bmN0aW9uIHBhcnRpY2lwYW50SW5mb19TdGF0ZVRvSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIFBhcnRpY2lwYW50SW5mb19TdGF0ZS5KT0lOSU5HOlxuICAgICAgICAgICAgcmV0dXJuIFwiSk9JTklOR1wiO1xuICAgICAgICBjYXNlIFBhcnRpY2lwYW50SW5mb19TdGF0ZS5KT0lORUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJKT0lORURcIjtcbiAgICAgICAgY2FzZSBQYXJ0aWNpcGFudEluZm9fU3RhdGUuQUNUSVZFOlxuICAgICAgICAgICAgcmV0dXJuIFwiQUNUSVZFXCI7XG4gICAgICAgIGNhc2UgUGFydGljaXBhbnRJbmZvX1N0YXRlLkRJU0NPTk5FQ1RFRDpcbiAgICAgICAgICAgIHJldHVybiBcIkRJU0NPTk5FQ1RFRFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5LTk9XTlwiO1xuICAgIH1cbn1cbmV4cG9ydHMucGFydGljaXBhbnRJbmZvX1N0YXRlVG9KU09OID0gcGFydGljaXBhbnRJbmZvX1N0YXRlVG9KU09OO1xudmFyIERhdGFQYWNrZXRfS2luZDtcbihmdW5jdGlvbiAoRGF0YVBhY2tldF9LaW5kKSB7XG4gICAgRGF0YVBhY2tldF9LaW5kW0RhdGFQYWNrZXRfS2luZFtcIlJFTElBQkxFXCJdID0gMF0gPSBcIlJFTElBQkxFXCI7XG4gICAgRGF0YVBhY2tldF9LaW5kW0RhdGFQYWNrZXRfS2luZFtcIkxPU1NZXCJdID0gMV0gPSBcIkxPU1NZXCI7XG4gICAgRGF0YVBhY2tldF9LaW5kW0RhdGFQYWNrZXRfS2luZFtcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShEYXRhUGFja2V0X0tpbmQgPSBleHBvcnRzLkRhdGFQYWNrZXRfS2luZCB8fCAoZXhwb3J0cy5EYXRhUGFja2V0X0tpbmQgPSB7fSkpO1xuZnVuY3Rpb24gZGF0YVBhY2tldF9LaW5kRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiUkVMSUFCTEVcIjpcbiAgICAgICAgICAgIHJldHVybiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEU7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIkxPU1NZXCI6XG4gICAgICAgICAgICByZXR1cm4gRGF0YVBhY2tldF9LaW5kLkxPU1NZO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gRGF0YVBhY2tldF9LaW5kLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnRzLmRhdGFQYWNrZXRfS2luZEZyb21KU09OID0gZGF0YVBhY2tldF9LaW5kRnJvbUpTT047XG5mdW5jdGlvbiBkYXRhUGFja2V0X0tpbmRUb0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEU6XG4gICAgICAgICAgICByZXR1cm4gXCJSRUxJQUJMRVwiO1xuICAgICAgICBjYXNlIERhdGFQYWNrZXRfS2luZC5MT1NTWTpcbiAgICAgICAgICAgIHJldHVybiBcIkxPU1NZXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJVTktOT1dOXCI7XG4gICAgfVxufVxuZXhwb3J0cy5kYXRhUGFja2V0X0tpbmRUb0pTT04gPSBkYXRhUGFja2V0X0tpbmRUb0pTT047XG52YXIgQ2xpZW50SW5mb19TREs7XG4oZnVuY3Rpb24gKENsaWVudEluZm9fU0RLKSB7XG4gICAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJVTktOT1dOXCJdID0gMF0gPSBcIlVOS05PV05cIjtcbiAgICBDbGllbnRJbmZvX1NES1tDbGllbnRJbmZvX1NES1tcIkpTXCJdID0gMV0gPSBcIkpTXCI7XG4gICAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJTV0lGVFwiXSA9IDJdID0gXCJTV0lGVFwiO1xuICAgIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiQU5EUk9JRFwiXSA9IDNdID0gXCJBTkRST0lEXCI7XG4gICAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJGTFVUVEVSXCJdID0gNF0gPSBcIkZMVVRURVJcIjtcbiAgICBDbGllbnRJbmZvX1NES1tDbGllbnRJbmZvX1NES1tcIkdPXCJdID0gNV0gPSBcIkdPXCI7XG4gICAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJVTklUWVwiXSA9IDZdID0gXCJVTklUWVwiO1xuICAgIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiVU5SRUNPR05JWkVEXCJdID0gLTFdID0gXCJVTlJFQ09HTklaRURcIjtcbn0pKENsaWVudEluZm9fU0RLID0gZXhwb3J0cy5DbGllbnRJbmZvX1NESyB8fCAoZXhwb3J0cy5DbGllbnRJbmZvX1NESyA9IHt9KSk7XG5mdW5jdGlvbiBjbGllbnRJbmZvX1NES0Zyb21KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSBcIlVOS05PV05cIjpcbiAgICAgICAgICAgIHJldHVybiBDbGllbnRJbmZvX1NESy5VTktOT1dOO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJKU1wiOlxuICAgICAgICAgICAgcmV0dXJuIENsaWVudEluZm9fU0RLLkpTO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgXCJTV0lGVFwiOlxuICAgICAgICAgICAgcmV0dXJuIENsaWVudEluZm9fU0RLLlNXSUZUO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgXCJBTkRST0lEXCI6XG4gICAgICAgICAgICByZXR1cm4gQ2xpZW50SW5mb19TREsuQU5EUk9JRDtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIFwiRkxVVFRFUlwiOlxuICAgICAgICAgICAgcmV0dXJuIENsaWVudEluZm9fU0RLLkZMVVRURVI7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgY2FzZSBcIkdPXCI6XG4gICAgICAgICAgICByZXR1cm4gQ2xpZW50SW5mb19TREsuR087XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSBcIlVOSVRZXCI6XG4gICAgICAgICAgICByZXR1cm4gQ2xpZW50SW5mb19TREsuVU5JVFk7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgXCJVTlJFQ09HTklaRURcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBDbGllbnRJbmZvX1NESy5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0cy5jbGllbnRJbmZvX1NES0Zyb21KU09OID0gY2xpZW50SW5mb19TREtGcm9tSlNPTjtcbmZ1bmN0aW9uIGNsaWVudEluZm9fU0RLVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgQ2xpZW50SW5mb19TREsuVU5LTk9XTjpcbiAgICAgICAgICAgIHJldHVybiBcIlVOS05PV05cIjtcbiAgICAgICAgY2FzZSBDbGllbnRJbmZvX1NESy5KUzpcbiAgICAgICAgICAgIHJldHVybiBcIkpTXCI7XG4gICAgICAgIGNhc2UgQ2xpZW50SW5mb19TREsuU1dJRlQ6XG4gICAgICAgICAgICByZXR1cm4gXCJTV0lGVFwiO1xuICAgICAgICBjYXNlIENsaWVudEluZm9fU0RLLkFORFJPSUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJBTkRST0lEXCI7XG4gICAgICAgIGNhc2UgQ2xpZW50SW5mb19TREsuRkxVVFRFUjpcbiAgICAgICAgICAgIHJldHVybiBcIkZMVVRURVJcIjtcbiAgICAgICAgY2FzZSBDbGllbnRJbmZvX1NESy5HTzpcbiAgICAgICAgICAgIHJldHVybiBcIkdPXCI7XG4gICAgICAgIGNhc2UgQ2xpZW50SW5mb19TREsuVU5JVFk6XG4gICAgICAgICAgICByZXR1cm4gXCJVTklUWVwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5LTk9XTlwiO1xuICAgIH1cbn1cbmV4cG9ydHMuY2xpZW50SW5mb19TREtUb0pTT04gPSBjbGllbnRJbmZvX1NES1RvSlNPTjtcbmNvbnN0IGJhc2VSb29tID0ge1xuICAgIHNpZDogXCJcIixcbiAgICBuYW1lOiBcIlwiLFxuICAgIGVtcHR5VGltZW91dDogMCxcbiAgICBtYXhQYXJ0aWNpcGFudHM6IDAsXG4gICAgY3JlYXRpb25UaW1lOiAwLFxuICAgIHR1cm5QYXNzd29yZDogXCJcIixcbiAgICBtZXRhZGF0YTogXCJcIixcbiAgICBudW1QYXJ0aWNpcGFudHM6IDAsXG4gICAgYWN0aXZlUmVjb3JkaW5nOiBmYWxzZSxcbn07XG5leHBvcnRzLlJvb20gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zaWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZW1wdHlUaW1lb3V0ICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS51aW50MzIobWVzc2FnZS5lbXB0eVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1heFBhcnRpY2lwYW50cyAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzMikudWludDMyKG1lc3NhZ2UubWF4UGFydGljaXBhbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jcmVhdGlvblRpbWUgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNDApLmludDY0KG1lc3NhZ2UuY3JlYXRpb25UaW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50dXJuUGFzc3dvcmQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNTApLnN0cmluZyhtZXNzYWdlLnR1cm5QYXNzd29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuZW5hYmxlZENvZGVjcykge1xuICAgICAgICAgICAgZXhwb3J0cy5Db2RlYy5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMig1OCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5tZXRhZGF0YSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig2Nikuc3RyaW5nKG1lc3NhZ2UubWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm51bVBhcnRpY2lwYW50cyAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig3MikudWludDMyKG1lc3NhZ2UubnVtUGFydGljaXBhbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5hY3RpdmVSZWNvcmRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoODApLmJvb2wobWVzc2FnZS5hY3RpdmVSZWNvcmRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVJvb20pO1xuICAgICAgICBtZXNzYWdlLmVuYWJsZWRDb2RlY3MgPSBbXTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbXB0eVRpbWVvdXQgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tYXhQYXJ0aWNpcGFudHMgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGlvblRpbWUgPSBsb25nVG9OdW1iZXIocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHVyblBhc3N3b3JkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW5hYmxlZENvZGVjcy5wdXNoKGV4cG9ydHMuQ29kZWMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXRhZGF0YSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm51bVBhcnRpY2lwYW50cyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hY3RpdmVSZWNvcmRpbmcgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlUm9vbSk7XG4gICAgICAgIG1lc3NhZ2UuZW5hYmxlZENvZGVjcyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LnNpZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2lkID0gU3RyaW5nKG9iamVjdC5zaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5zaWQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QubmFtZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5uYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSBTdHJpbmcob2JqZWN0Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LmVtcHR5VGltZW91dCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5lbXB0eVRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZW1wdHlUaW1lb3V0ID0gTnVtYmVyKG9iamVjdC5lbXB0eVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5lbXB0eVRpbWVvdXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QubWF4UGFydGljaXBhbnRzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIG9iamVjdC5tYXhQYXJ0aWNpcGFudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubWF4UGFydGljaXBhbnRzID0gTnVtYmVyKG9iamVjdC5tYXhQYXJ0aWNpcGFudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5tYXhQYXJ0aWNpcGFudHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QuY3JlYXRpb25UaW1lICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNyZWF0aW9uVGltZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGlvblRpbWUgPSBOdW1iZXIob2JqZWN0LmNyZWF0aW9uVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmNyZWF0aW9uVGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC50dXJuUGFzc3dvcmQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudHVyblBhc3N3b3JkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnR1cm5QYXNzd29yZCA9IFN0cmluZyhvYmplY3QudHVyblBhc3N3b3JkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHVyblBhc3N3b3JkID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LmVuYWJsZWRDb2RlY3MgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZW5hYmxlZENvZGVjcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iamVjdC5lbmFibGVkQ29kZWNzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5lbmFibGVkQ29kZWNzLnB1c2goZXhwb3J0cy5Db2RlYy5mcm9tSlNPTihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5tZXRhZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5tZXRhZGF0YSA9IFN0cmluZyhvYmplY3QubWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5tZXRhZGF0YSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5udW1QYXJ0aWNpcGFudHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgb2JqZWN0Lm51bVBhcnRpY2lwYW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5udW1QYXJ0aWNpcGFudHMgPSBOdW1iZXIob2JqZWN0Lm51bVBhcnRpY2lwYW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLm51bVBhcnRpY2lwYW50cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5hY3RpdmVSZWNvcmRpbmcgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgb2JqZWN0LmFjdGl2ZVJlY29yZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5hY3RpdmVSZWNvcmRpbmcgPSBCb29sZWFuKG9iamVjdC5hY3RpdmVSZWNvcmRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5hY3RpdmVSZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnNpZCAhPT0gdW5kZWZpbmVkICYmIChvYmouc2lkID0gbWVzc2FnZS5zaWQpO1xuICAgICAgICBtZXNzYWdlLm5hbWUgIT09IHVuZGVmaW5lZCAmJiAob2JqLm5hbWUgPSBtZXNzYWdlLm5hbWUpO1xuICAgICAgICBtZXNzYWdlLmVtcHR5VGltZW91dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmVtcHR5VGltZW91dCA9IG1lc3NhZ2UuZW1wdHlUaW1lb3V0KTtcbiAgICAgICAgbWVzc2FnZS5tYXhQYXJ0aWNpcGFudHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5tYXhQYXJ0aWNpcGFudHMgPSBtZXNzYWdlLm1heFBhcnRpY2lwYW50cyk7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRpb25UaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY3JlYXRpb25UaW1lID0gbWVzc2FnZS5jcmVhdGlvblRpbWUpO1xuICAgICAgICBtZXNzYWdlLnR1cm5QYXNzd29yZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnR1cm5QYXNzd29yZCA9IG1lc3NhZ2UudHVyblBhc3N3b3JkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZW5hYmxlZENvZGVjcykge1xuICAgICAgICAgICAgb2JqLmVuYWJsZWRDb2RlY3MgPSBtZXNzYWdlLmVuYWJsZWRDb2RlY3MubWFwKChlKSA9PiBlID8gZXhwb3J0cy5Db2RlYy50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmVuYWJsZWRDb2RlY3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLm1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiYgKG9iai5tZXRhZGF0YSA9IG1lc3NhZ2UubWV0YWRhdGEpO1xuICAgICAgICBtZXNzYWdlLm51bVBhcnRpY2lwYW50cyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm51bVBhcnRpY2lwYW50cyA9IG1lc3NhZ2UubnVtUGFydGljaXBhbnRzKTtcbiAgICAgICAgbWVzc2FnZS5hY3RpdmVSZWNvcmRpbmcgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hY3RpdmVSZWNvcmRpbmcgPSBtZXNzYWdlLmFjdGl2ZVJlY29yZGluZyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlUm9vbSk7XG4gICAgICAgIG1lc3NhZ2Uuc2lkID0gKF9hID0gb2JqZWN0LnNpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5uYW1lID0gKF9iID0gb2JqZWN0Lm5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuZW1wdHlUaW1lb3V0ID0gKF9jID0gb2JqZWN0LmVtcHR5VGltZW91dCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcbiAgICAgICAgbWVzc2FnZS5tYXhQYXJ0aWNpcGFudHMgPSAoX2QgPSBvYmplY3QubWF4UGFydGljaXBhbnRzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwO1xuICAgICAgICBtZXNzYWdlLmNyZWF0aW9uVGltZSA9IChfZSA9IG9iamVjdC5jcmVhdGlvblRpbWUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDA7XG4gICAgICAgIG1lc3NhZ2UudHVyblBhc3N3b3JkID0gKF9mID0gb2JqZWN0LnR1cm5QYXNzd29yZCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5lbmFibGVkQ29kZWNzID0gW107XG4gICAgICAgIGlmIChvYmplY3QuZW5hYmxlZENvZGVjcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5lbmFibGVkQ29kZWNzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LmVuYWJsZWRDb2RlY3MpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmVuYWJsZWRDb2RlY3MucHVzaChleHBvcnRzLkNvZGVjLmZyb21QYXJ0aWFsKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLm1ldGFkYXRhID0gKF9nID0gb2JqZWN0Lm1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLm51bVBhcnRpY2lwYW50cyA9IChfaCA9IG9iamVjdC5udW1QYXJ0aWNpcGFudHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IDA7XG4gICAgICAgIG1lc3NhZ2UuYWN0aXZlUmVjb3JkaW5nID0gKF9qID0gb2JqZWN0LmFjdGl2ZVJlY29yZGluZykgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogZmFsc2U7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuY29uc3QgYmFzZUNvZGVjID0geyBtaW1lOiBcIlwiLCBmbXRwTGluZTogXCJcIiB9O1xuZXhwb3J0cy5Db2RlYyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm1pbWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLm1pbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmZtdHBMaW5lICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5mbXRwTGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlQ29kZWMpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWltZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZtdHBMaW5lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlQ29kZWMpO1xuICAgICAgICBpZiAob2JqZWN0Lm1pbWUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubWltZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5taW1lID0gU3RyaW5nKG9iamVjdC5taW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubWltZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5mbXRwTGluZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5mbXRwTGluZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5mbXRwTGluZSA9IFN0cmluZyhvYmplY3QuZm10cExpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5mbXRwTGluZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5taW1lICE9PSB1bmRlZmluZWQgJiYgKG9iai5taW1lID0gbWVzc2FnZS5taW1lKTtcbiAgICAgICAgbWVzc2FnZS5mbXRwTGluZSAhPT0gdW5kZWZpbmVkICYmIChvYmouZm10cExpbmUgPSBtZXNzYWdlLmZtdHBMaW5lKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZUNvZGVjKTtcbiAgICAgICAgbWVzc2FnZS5taW1lID0gKF9hID0gb2JqZWN0Lm1pbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuZm10cExpbmUgPSAoX2IgPSBvYmplY3QuZm10cExpbmUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuY29uc3QgYmFzZVBhcnRpY2lwYW50SW5mbyA9IHtcbiAgICBzaWQ6IFwiXCIsXG4gICAgaWRlbnRpdHk6IFwiXCIsXG4gICAgc3RhdGU6IDAsXG4gICAgbWV0YWRhdGE6IFwiXCIsXG4gICAgam9pbmVkQXQ6IDAsXG4gICAgaGlkZGVuOiBmYWxzZSxcbiAgICByZWNvcmRlcjogZmFsc2UsXG4gICAgbmFtZTogXCJcIixcbn07XG5leHBvcnRzLlBhcnRpY2lwYW50SW5mbyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uuc2lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pZGVudGl0eSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuaWRlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN0YXRlICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS5pbnQzMihtZXNzYWdlLnN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS50cmFja3MpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVHJhY2tJbmZvLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDM0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGFkYXRhICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQyKS5zdHJpbmcobWVzc2FnZS5tZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuam9pbmVkQXQgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNDgpLmludDY0KG1lc3NhZ2Uuam9pbmVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmhpZGRlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig1NikuYm9vbChtZXNzYWdlLmhpZGRlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVjb3JkZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNjQpLmJvb2wobWVzc2FnZS5yZWNvcmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig3NCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlUGFydGljaXBhbnRJbmZvKTtcbiAgICAgICAgbWVzc2FnZS50cmFja3MgPSBbXTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkZW50aXR5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RhdGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWNrcy5wdXNoKGV4cG9ydHMuVHJhY2tJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWV0YWRhdGEgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5qb2luZWRBdCA9IGxvbmdUb051bWJlcihyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oaWRkZW4gPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVjb3JkZXIgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVBhcnRpY2lwYW50SW5mbyk7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tzID0gW107XG4gICAgICAgIGlmIChvYmplY3Quc2lkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNpZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5zaWQgPSBTdHJpbmcob2JqZWN0LnNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNpZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5pZGVudGl0eSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5pZGVudGl0eSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5pZGVudGl0eSA9IFN0cmluZyhvYmplY3QuaWRlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5pZGVudGl0eSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5zdGF0ZSA9IHBhcnRpY2lwYW50SW5mb19TdGF0ZUZyb21KU09OKG9iamVjdC5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN0YXRlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnRyYWNrcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50cmFja3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QudHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja3MucHVzaChleHBvcnRzLlRyYWNrSW5mby5mcm9tSlNPTihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5tZXRhZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5tZXRhZGF0YSA9IFN0cmluZyhvYmplY3QubWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5tZXRhZGF0YSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5qb2luZWRBdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5qb2luZWRBdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5qb2luZWRBdCA9IE51bWJlcihvYmplY3Quam9pbmVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5qb2luZWRBdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5oaWRkZW4gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuaGlkZGVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmhpZGRlbiA9IEJvb2xlYW4ob2JqZWN0LmhpZGRlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QucmVjb3JkZXIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVjb3JkZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UucmVjb3JkZXIgPSBCb29sZWFuKG9iamVjdC5yZWNvcmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnJlY29yZGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lm5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuc2lkICE9PSB1bmRlZmluZWQgJiYgKG9iai5zaWQgPSBtZXNzYWdlLnNpZCk7XG4gICAgICAgIG1lc3NhZ2UuaWRlbnRpdHkgIT09IHVuZGVmaW5lZCAmJiAob2JqLmlkZW50aXR5ID0gbWVzc2FnZS5pZGVudGl0eSk7XG4gICAgICAgIG1lc3NhZ2Uuc3RhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zdGF0ZSA9IHBhcnRpY2lwYW50SW5mb19TdGF0ZVRvSlNPTihtZXNzYWdlLnN0YXRlKSk7XG4gICAgICAgIGlmIChtZXNzYWdlLnRyYWNrcykge1xuICAgICAgICAgICAgb2JqLnRyYWNrcyA9IG1lc3NhZ2UudHJhY2tzLm1hcCgoZSkgPT4gZSA/IGV4cG9ydHMuVHJhY2tJbmZvLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoudHJhY2tzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmIChvYmoubWV0YWRhdGEgPSBtZXNzYWdlLm1ldGFkYXRhKTtcbiAgICAgICAgbWVzc2FnZS5qb2luZWRBdCAhPT0gdW5kZWZpbmVkICYmIChvYmouam9pbmVkQXQgPSBtZXNzYWdlLmpvaW5lZEF0KTtcbiAgICAgICAgbWVzc2FnZS5oaWRkZW4gIT09IHVuZGVmaW5lZCAmJiAob2JqLmhpZGRlbiA9IG1lc3NhZ2UuaGlkZGVuKTtcbiAgICAgICAgbWVzc2FnZS5yZWNvcmRlciAhPT0gdW5kZWZpbmVkICYmIChvYmoucmVjb3JkZXIgPSBtZXNzYWdlLnJlY29yZGVyKTtcbiAgICAgICAgbWVzc2FnZS5uYW1lICE9PSB1bmRlZmluZWQgJiYgKG9iai5uYW1lID0gbWVzc2FnZS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVBhcnRpY2lwYW50SW5mbyk7XG4gICAgICAgIG1lc3NhZ2Uuc2lkID0gKF9hID0gb2JqZWN0LnNpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5pZGVudGl0eSA9IChfYiA9IG9iamVjdC5pZGVudGl0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zdGF0ZSA9IChfYyA9IG9iamVjdC5zdGF0ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcbiAgICAgICAgbWVzc2FnZS50cmFja3MgPSBbXTtcbiAgICAgICAgaWYgKG9iamVjdC50cmFja3MgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudHJhY2tzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LnRyYWNrcykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tzLnB1c2goZXhwb3J0cy5UcmFja0luZm8uZnJvbVBhcnRpYWwoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UubWV0YWRhdGEgPSAoX2QgPSBvYmplY3QubWV0YWRhdGEpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuam9pbmVkQXQgPSAoX2UgPSBvYmplY3Quam9pbmVkQXQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDA7XG4gICAgICAgIG1lc3NhZ2UuaGlkZGVuID0gKF9mID0gb2JqZWN0LmhpZGRlbikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogZmFsc2U7XG4gICAgICAgIG1lc3NhZ2UucmVjb3JkZXIgPSAoX2cgPSBvYmplY3QucmVjb3JkZXIpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLm5hbWUgPSAoX2ggPSBvYmplY3QubmFtZSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlVHJhY2tJbmZvID0ge1xuICAgIHNpZDogXCJcIixcbiAgICB0eXBlOiAwLFxuICAgIG5hbWU6IFwiXCIsXG4gICAgbXV0ZWQ6IGZhbHNlLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBzaW11bGNhc3Q6IGZhbHNlLFxuICAgIGRpc2FibGVEdHg6IGZhbHNlLFxuICAgIHNvdXJjZTogMCxcbiAgICBtaW1lVHlwZTogXCJcIixcbiAgICBtaWQ6IFwiXCIsXG59O1xuZXhwb3J0cy5UcmFja0luZm8gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zaWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5tdXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzMikuYm9vbChtZXNzYWdlLm11dGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS53aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0MCkudWludDMyKG1lc3NhZ2Uud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmhlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0OCkudWludDMyKG1lc3NhZ2UuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaW11bGNhc3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNTYpLmJvb2wobWVzc2FnZS5zaW11bGNhc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRpc2FibGVEdHggPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNjQpLmJvb2wobWVzc2FnZS5kaXNhYmxlRHR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zb3VyY2UgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNzIpLmludDMyKG1lc3NhZ2Uuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5sYXllcnMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVmlkZW9MYXllci5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMig4MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5taW1lVHlwZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig5MCkuc3RyaW5nKG1lc3NhZ2UubWltZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1pZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig5OCkuc3RyaW5nKG1lc3NhZ2UubWlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VUcmFja0luZm8pO1xuICAgICAgICBtZXNzYWdlLmxheWVycyA9IFtdO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2lkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm11dGVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLndpZHRoID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2ltdWxjYXN0ID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpc2FibGVEdHggPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc291cmNlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGF5ZXJzLnB1c2goZXhwb3J0cy5WaWRlb0xheWVyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1pbWVUeXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1pZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVRyYWNrSW5mbyk7XG4gICAgICAgIG1lc3NhZ2UubGF5ZXJzID0gW107XG4gICAgICAgIGlmIChvYmplY3Quc2lkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNpZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5zaWQgPSBTdHJpbmcob2JqZWN0LnNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNpZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC50eXBlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHRyYWNrVHlwZUZyb21KU09OKG9iamVjdC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lm5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QubXV0ZWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubXV0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubXV0ZWQgPSBCb29sZWFuKG9iamVjdC5tdXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLm11dGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC53aWR0aCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC53aWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS53aWR0aCA9IE51bWJlcihvYmplY3Qud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS53aWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5oZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmhlaWdodCA9IE51bWJlcihvYmplY3QuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnNpbXVsY2FzdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zaW11bGNhc3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2ltdWxjYXN0ID0gQm9vbGVhbihvYmplY3Quc2ltdWxjYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2ltdWxjYXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5kaXNhYmxlRHR4ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmRpc2FibGVEdHggIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZGlzYWJsZUR0eCA9IEJvb2xlYW4ob2JqZWN0LmRpc2FibGVEdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5kaXNhYmxlRHR4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNvdXJjZSA9IHRyYWNrU291cmNlRnJvbUpTT04ob2JqZWN0LnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNvdXJjZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5sYXllcnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubGF5ZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LmxheWVycykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGF5ZXJzLnB1c2goZXhwb3J0cy5WaWRlb0xheWVyLmZyb21KU09OKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Lm1pbWVUeXBlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lm1pbWVUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLm1pbWVUeXBlID0gU3RyaW5nKG9iamVjdC5taW1lVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLm1pbWVUeXBlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Lm1pZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5taWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubWlkID0gU3RyaW5nKG9iamVjdC5taWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5taWQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuc2lkICE9PSB1bmRlZmluZWQgJiYgKG9iai5zaWQgPSBtZXNzYWdlLnNpZCk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSAhPT0gdW5kZWZpbmVkICYmIChvYmoudHlwZSA9IHRyYWNrVHlwZVRvSlNPTihtZXNzYWdlLnR5cGUpKTtcbiAgICAgICAgbWVzc2FnZS5uYW1lICE9PSB1bmRlZmluZWQgJiYgKG9iai5uYW1lID0gbWVzc2FnZS5uYW1lKTtcbiAgICAgICAgbWVzc2FnZS5tdXRlZCAhPT0gdW5kZWZpbmVkICYmIChvYmoubXV0ZWQgPSBtZXNzYWdlLm11dGVkKTtcbiAgICAgICAgbWVzc2FnZS53aWR0aCAhPT0gdW5kZWZpbmVkICYmIChvYmoud2lkdGggPSBtZXNzYWdlLndpZHRoKTtcbiAgICAgICAgbWVzc2FnZS5oZWlnaHQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmhlaWdodCA9IG1lc3NhZ2UuaGVpZ2h0KTtcbiAgICAgICAgbWVzc2FnZS5zaW11bGNhc3QgIT09IHVuZGVmaW5lZCAmJiAob2JqLnNpbXVsY2FzdCA9IG1lc3NhZ2Uuc2ltdWxjYXN0KTtcbiAgICAgICAgbWVzc2FnZS5kaXNhYmxlRHR4ICE9PSB1bmRlZmluZWQgJiYgKG9iai5kaXNhYmxlRHR4ID0gbWVzc2FnZS5kaXNhYmxlRHR4KTtcbiAgICAgICAgbWVzc2FnZS5zb3VyY2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zb3VyY2UgPSB0cmFja1NvdXJjZVRvSlNPTihtZXNzYWdlLnNvdXJjZSkpO1xuICAgICAgICBpZiAobWVzc2FnZS5sYXllcnMpIHtcbiAgICAgICAgICAgIG9iai5sYXllcnMgPSBtZXNzYWdlLmxheWVycy5tYXAoKGUpID0+IGUgPyBleHBvcnRzLlZpZGVvTGF5ZXIudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5sYXllcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLm1pbWVUeXBlICE9PSB1bmRlZmluZWQgJiYgKG9iai5taW1lVHlwZSA9IG1lc3NhZ2UubWltZVR5cGUpO1xuICAgICAgICBtZXNzYWdlLm1pZCAhPT0gdW5kZWZpbmVkICYmIChvYmoubWlkID0gbWVzc2FnZS5taWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2w7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlVHJhY2tJbmZvKTtcbiAgICAgICAgbWVzc2FnZS5zaWQgPSAoX2EgPSBvYmplY3Quc2lkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSAoX2IgPSBvYmplY3QudHlwZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgbWVzc2FnZS5uYW1lID0gKF9jID0gb2JqZWN0Lm5hbWUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UubXV0ZWQgPSAoX2QgPSBvYmplY3QubXV0ZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLndpZHRoID0gKF9lID0gb2JqZWN0LndpZHRoKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwO1xuICAgICAgICBtZXNzYWdlLmhlaWdodCA9IChfZiA9IG9iamVjdC5oZWlnaHQpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDA7XG4gICAgICAgIG1lc3NhZ2Uuc2ltdWxjYXN0ID0gKF9nID0gb2JqZWN0LnNpbXVsY2FzdCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogZmFsc2U7XG4gICAgICAgIG1lc3NhZ2UuZGlzYWJsZUR0eCA9IChfaCA9IG9iamVjdC5kaXNhYmxlRHR4KSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5zb3VyY2UgPSAoX2ogPSBvYmplY3Quc291cmNlKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiAwO1xuICAgICAgICBtZXNzYWdlLmxheWVycyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LmxheWVycyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5sYXllcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QubGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5sYXllcnMucHVzaChleHBvcnRzLlZpZGVvTGF5ZXIuZnJvbVBhcnRpYWwoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UubWltZVR5cGUgPSAoX2sgPSBvYmplY3QubWltZVR5cGUpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UubWlkID0gKF9sID0gb2JqZWN0Lm1pZCkgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlVmlkZW9MYXllciA9IHtcbiAgICBxdWFsaXR5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBiaXRyYXRlOiAwLFxuICAgIHNzcmM6IDAsXG59O1xuZXhwb3J0cy5WaWRlb0xheWVyID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucXVhbGl0eSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQzMihtZXNzYWdlLnF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS51aW50MzIobWVzc2FnZS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS51aW50MzIobWVzc2FnZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmJpdHJhdGUgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzIpLnVpbnQzMihtZXNzYWdlLmJpdHJhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNzcmMgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNDApLnVpbnQzMihtZXNzYWdlLnNzcmMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVZpZGVvTGF5ZXIpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucXVhbGl0eSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uud2lkdGggPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oZWlnaHQgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iaXRyYXRlID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3NyYyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVZpZGVvTGF5ZXIpO1xuICAgICAgICBpZiAob2JqZWN0LnF1YWxpdHkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucXVhbGl0eSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5xdWFsaXR5ID0gdmlkZW9RdWFsaXR5RnJvbUpTT04ob2JqZWN0LnF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5xdWFsaXR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LndpZHRoICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LndpZHRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLndpZHRoID0gTnVtYmVyKG9iamVjdC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLndpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LmhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5oZWlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gTnVtYmVyKG9iamVjdC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5oZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QuYml0cmF0ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5iaXRyYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmJpdHJhdGUgPSBOdW1iZXIob2JqZWN0LmJpdHJhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5iaXRyYXRlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnNzcmMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc3NyYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5zc3JjID0gTnVtYmVyKG9iamVjdC5zc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3NyYyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5xdWFsaXR5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucXVhbGl0eSA9IHZpZGVvUXVhbGl0eVRvSlNPTihtZXNzYWdlLnF1YWxpdHkpKTtcbiAgICAgICAgbWVzc2FnZS53aWR0aCAhPT0gdW5kZWZpbmVkICYmIChvYmoud2lkdGggPSBtZXNzYWdlLndpZHRoKTtcbiAgICAgICAgbWVzc2FnZS5oZWlnaHQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmhlaWdodCA9IG1lc3NhZ2UuaGVpZ2h0KTtcbiAgICAgICAgbWVzc2FnZS5iaXRyYXRlICE9PSB1bmRlZmluZWQgJiYgKG9iai5iaXRyYXRlID0gbWVzc2FnZS5iaXRyYXRlKTtcbiAgICAgICAgbWVzc2FnZS5zc3JjICE9PSB1bmRlZmluZWQgJiYgKG9iai5zc3JjID0gbWVzc2FnZS5zc3JjKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVZpZGVvTGF5ZXIpO1xuICAgICAgICBtZXNzYWdlLnF1YWxpdHkgPSAoX2EgPSBvYmplY3QucXVhbGl0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgbWVzc2FnZS53aWR0aCA9IChfYiA9IG9iamVjdC53aWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgbWVzc2FnZS5oZWlnaHQgPSAoX2MgPSBvYmplY3QuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwO1xuICAgICAgICBtZXNzYWdlLmJpdHJhdGUgPSAoX2QgPSBvYmplY3QuYml0cmF0ZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMDtcbiAgICAgICAgbWVzc2FnZS5zc3JjID0gKF9lID0gb2JqZWN0LnNzcmMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDA7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuY29uc3QgYmFzZURhdGFQYWNrZXQgPSB7IGtpbmQ6IDAgfTtcbmV4cG9ydHMuRGF0YVBhY2tldCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtpbmQgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkuaW50MzIobWVzc2FnZS5raW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS51c2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVXNlclBhY2tldC5lbmNvZGUobWVzc2FnZS51c2VyLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNwZWFrZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5BY3RpdmVTcGVha2VyVXBkYXRlLmVuY29kZShtZXNzYWdlLnNwZWFrZXIsIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlRGF0YVBhY2tldCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5raW5kID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51c2VyID0gZXhwb3J0cy5Vc2VyUGFja2V0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zcGVha2VyID0gZXhwb3J0cy5BY3RpdmVTcGVha2VyVXBkYXRlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VEYXRhUGFja2V0KTtcbiAgICAgICAgaWYgKG9iamVjdC5raW5kICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmtpbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uua2luZCA9IGRhdGFQYWNrZXRfS2luZEZyb21KU09OKG9iamVjdC5raW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uua2luZCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC51c2VyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnVzZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudXNlciA9IGV4cG9ydHMuVXNlclBhY2tldC5mcm9tSlNPTihvYmplY3QudXNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnVzZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zcGVha2VyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNwZWFrZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3BlYWtlciA9IGV4cG9ydHMuQWN0aXZlU3BlYWtlclVwZGF0ZS5mcm9tSlNPTihvYmplY3Quc3BlYWtlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNwZWFrZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5raW5kICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoua2luZCA9IGRhdGFQYWNrZXRfS2luZFRvSlNPTihtZXNzYWdlLmtpbmQpKTtcbiAgICAgICAgbWVzc2FnZS51c2VyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudXNlciA9IG1lc3NhZ2UudXNlciA/IGV4cG9ydHMuVXNlclBhY2tldC50b0pTT04obWVzc2FnZS51c2VyKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2Uuc3BlYWtlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNwZWFrZXIgPSBtZXNzYWdlLnNwZWFrZXJcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQWN0aXZlU3BlYWtlclVwZGF0ZS50b0pTT04obWVzc2FnZS5zcGVha2VyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlRGF0YVBhY2tldCk7XG4gICAgICAgIG1lc3NhZ2Uua2luZCA9IChfYSA9IG9iamVjdC5raW5kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBpZiAob2JqZWN0LnVzZXIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudXNlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS51c2VyID0gZXhwb3J0cy5Vc2VyUGFja2V0LmZyb21QYXJ0aWFsKG9iamVjdC51c2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudXNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnNwZWFrZXIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc3BlYWtlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5zcGVha2VyID0gZXhwb3J0cy5BY3RpdmVTcGVha2VyVXBkYXRlLmZyb21QYXJ0aWFsKG9iamVjdC5zcGVha2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3BlYWtlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmNvbnN0IGJhc2VBY3RpdmVTcGVha2VyVXBkYXRlID0ge307XG5leHBvcnRzLkFjdGl2ZVNwZWFrZXJVcGRhdGUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5zcGVha2Vycykge1xuICAgICAgICAgICAgZXhwb3J0cy5TcGVha2VySW5mby5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VBY3RpdmVTcGVha2VyVXBkYXRlKTtcbiAgICAgICAgbWVzc2FnZS5zcGVha2VycyA9IFtdO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BlYWtlcnMucHVzaChleHBvcnRzLlNwZWFrZXJJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlQWN0aXZlU3BlYWtlclVwZGF0ZSk7XG4gICAgICAgIG1lc3NhZ2Uuc3BlYWtlcnMgPSBbXTtcbiAgICAgICAgaWYgKG9iamVjdC5zcGVha2VycyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zcGVha2VycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iamVjdC5zcGVha2Vycykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BlYWtlcnMucHVzaChleHBvcnRzLlNwZWFrZXJJbmZvLmZyb21KU09OKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5zcGVha2Vycykge1xuICAgICAgICAgICAgb2JqLnNwZWFrZXJzID0gbWVzc2FnZS5zcGVha2Vycy5tYXAoKGUpID0+IGUgPyBleHBvcnRzLlNwZWFrZXJJbmZvLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouc3BlYWtlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlQWN0aXZlU3BlYWtlclVwZGF0ZSk7XG4gICAgICAgIG1lc3NhZ2Uuc3BlYWtlcnMgPSBbXTtcbiAgICAgICAgaWYgKG9iamVjdC5zcGVha2VycyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zcGVha2VycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iamVjdC5zcGVha2Vycykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BlYWtlcnMucHVzaChleHBvcnRzLlNwZWFrZXJJbmZvLmZyb21QYXJ0aWFsKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmNvbnN0IGJhc2VTcGVha2VySW5mbyA9IHsgc2lkOiBcIlwiLCBsZXZlbDogMCwgYWN0aXZlOiBmYWxzZSB9O1xuZXhwb3J0cy5TcGVha2VySW5mbyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uuc2lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5sZXZlbCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyMSkuZmxvYXQobWVzc2FnZS5sZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS5ib29sKG1lc3NhZ2UuYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTcGVha2VySW5mbyk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sZXZlbCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWN0aXZlID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVNwZWFrZXJJbmZvKTtcbiAgICAgICAgaWYgKG9iamVjdC5zaWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2lkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNpZCA9IFN0cmluZyhvYmplY3Quc2lkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2lkID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LmxldmVsICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmxldmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmxldmVsID0gTnVtYmVyKG9iamVjdC5sZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmxldmVsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LmFjdGl2ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5hY3RpdmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYWN0aXZlID0gQm9vbGVhbihvYmplY3QuYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5zaWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLnNpZCA9IG1lc3NhZ2Uuc2lkKTtcbiAgICAgICAgbWVzc2FnZS5sZXZlbCAhPT0gdW5kZWZpbmVkICYmIChvYmoubGV2ZWwgPSBtZXNzYWdlLmxldmVsKTtcbiAgICAgICAgbWVzc2FnZS5hY3RpdmUgIT09IHVuZGVmaW5lZCAmJiAob2JqLmFjdGl2ZSA9IG1lc3NhZ2UuYWN0aXZlKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTcGVha2VySW5mbyk7XG4gICAgICAgIG1lc3NhZ2Uuc2lkID0gKF9hID0gb2JqZWN0LnNpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5sZXZlbCA9IChfYiA9IG9iamVjdC5sZXZlbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgbWVzc2FnZS5hY3RpdmUgPSAoX2MgPSBvYmplY3QuYWN0aXZlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlVXNlclBhY2tldCA9IHsgcGFydGljaXBhbnRTaWQ6IFwiXCIsIGRlc3RpbmF0aW9uU2lkczogXCJcIiB9O1xuZXhwb3J0cy5Vc2VyUGFja2V0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydGljaXBhbnRTaWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnBhcnRpY2lwYW50U2lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5kZXN0aW5hdGlvblNpZHMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VVc2VyUGFja2V0KTtcbiAgICAgICAgbWVzc2FnZS5kZXN0aW5hdGlvblNpZHMgPSBbXTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50U2lkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVzdGluYXRpb25TaWRzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVVzZXJQYWNrZXQpO1xuICAgICAgICBtZXNzYWdlLmRlc3RpbmF0aW9uU2lkcyA9IFtdO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBpZiAob2JqZWN0LnBhcnRpY2lwYW50U2lkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBhcnRpY2lwYW50U2lkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50U2lkID0gU3RyaW5nKG9iamVjdC5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50U2lkID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnBheWxvYWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LmRlc3RpbmF0aW9uU2lkcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBvYmplY3QuZGVzdGluYXRpb25TaWRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LmRlc3RpbmF0aW9uU2lkcykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVzdGluYXRpb25TaWRzLnB1c2goU3RyaW5nKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50U2lkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGFydGljaXBhbnRTaWQgPSBtZXNzYWdlLnBhcnRpY2lwYW50U2lkKTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGF5bG9hZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UucGF5bG9hZCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVzdGluYXRpb25TaWRzKSB7XG4gICAgICAgICAgICBvYmouZGVzdGluYXRpb25TaWRzID0gbWVzc2FnZS5kZXN0aW5hdGlvblNpZHMubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5kZXN0aW5hdGlvblNpZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlVXNlclBhY2tldCk7XG4gICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRTaWQgPSAoX2EgPSBvYmplY3QucGFydGljaXBhbnRTaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IChfYiA9IG9iamVjdC5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmRlc3RpbmF0aW9uU2lkcyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LmRlc3RpbmF0aW9uU2lkcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBvYmplY3QuZGVzdGluYXRpb25TaWRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LmRlc3RpbmF0aW9uU2lkcykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVzdGluYXRpb25TaWRzLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlUGFydGljaXBhbnRUcmFja3MgPSB7IHBhcnRpY2lwYW50U2lkOiBcIlwiLCB0cmFja1NpZHM6IFwiXCIgfTtcbmV4cG9ydHMuUGFydGljaXBhbnRUcmFja3MgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0aWNpcGFudFNpZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UucGFydGljaXBhbnRTaWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnRyYWNrU2lkcykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVBhcnRpY2lwYW50VHJhY2tzKTtcbiAgICAgICAgbWVzc2FnZS50cmFja1NpZHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50U2lkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tTaWRzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVBhcnRpY2lwYW50VHJhY2tzKTtcbiAgICAgICAgbWVzc2FnZS50cmFja1NpZHMgPSBbXTtcbiAgICAgICAgaWYgKG9iamVjdC5wYXJ0aWNpcGFudFNpZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYXJ0aWNpcGFudFNpZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudFNpZCA9IFN0cmluZyhvYmplY3QucGFydGljaXBhbnRTaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC50cmFja1NpZHMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudHJhY2tTaWRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LnRyYWNrU2lkcykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tTaWRzLnB1c2goU3RyaW5nKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50U2lkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGFydGljaXBhbnRTaWQgPSBtZXNzYWdlLnBhcnRpY2lwYW50U2lkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tTaWRzKSB7XG4gICAgICAgICAgICBvYmoudHJhY2tTaWRzID0gbWVzc2FnZS50cmFja1NpZHMubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai50cmFja1NpZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VQYXJ0aWNpcGFudFRyYWNrcyk7XG4gICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRTaWQgPSAoX2EgPSBvYmplY3QucGFydGljaXBhbnRTaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tTaWRzID0gW107XG4gICAgICAgIGlmIChvYmplY3QudHJhY2tTaWRzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnRyYWNrU2lkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iamVjdC50cmFja1NpZHMpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWNrU2lkcy5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuY29uc3QgYmFzZUNsaWVudEluZm8gPSB7XG4gICAgc2RrOiAwLFxuICAgIHZlcnNpb246IFwiXCIsXG4gICAgcHJvdG9jb2w6IDAsXG4gICAgb3M6IFwiXCIsXG4gICAgb3NWZXJzaW9uOiBcIlwiLFxuICAgIGRldmljZU1vZGVsOiBcIlwiLFxuICAgIGJyb3dzZXI6IFwiXCIsXG4gICAgYnJvd3NlclZlcnNpb246IFwiXCIsXG59O1xuZXhwb3J0cy5DbGllbnRJbmZvID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2RrICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2Uuc2RrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52ZXJzaW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS52ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wcm90b2NvbCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkuaW50MzIobWVzc2FnZS5wcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uub3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzQpLnN0cmluZyhtZXNzYWdlLm9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5vc1ZlcnNpb24gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNDIpLnN0cmluZyhtZXNzYWdlLm9zVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGV2aWNlTW9kZWwgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNTApLnN0cmluZyhtZXNzYWdlLmRldmljZU1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5icm93c2VyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDU4KS5zdHJpbmcobWVzc2FnZS5icm93c2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5icm93c2VyVmVyc2lvbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig2Nikuc3RyaW5nKG1lc3NhZ2UuYnJvd3NlclZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZUNsaWVudEluZm8pO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2RrID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJvdG9jb2wgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9zID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3NWZXJzaW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGV2aWNlTW9kZWwgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5icm93c2VyID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYnJvd3NlclZlcnNpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VDbGllbnRJbmZvKTtcbiAgICAgICAgaWYgKG9iamVjdC5zZGsgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2RrICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNkayA9IGNsaWVudEluZm9fU0RLRnJvbUpTT04ob2JqZWN0LnNkayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNkayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC52ZXJzaW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IFN0cmluZyhvYmplY3QudmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QucHJvdG9jb2wgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucHJvdG9jb2wgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UucHJvdG9jb2wgPSBOdW1iZXIob2JqZWN0LnByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UucHJvdG9jb2wgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Qub3MgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Qub3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uub3MgPSBTdHJpbmcob2JqZWN0Lm9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uub3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Qub3NWZXJzaW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lm9zVmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5vc1ZlcnNpb24gPSBTdHJpbmcob2JqZWN0Lm9zVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLm9zVmVyc2lvbiA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5kZXZpY2VNb2RlbCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5kZXZpY2VNb2RlbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5kZXZpY2VNb2RlbCA9IFN0cmluZyhvYmplY3QuZGV2aWNlTW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5kZXZpY2VNb2RlbCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5icm93c2VyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmJyb3dzZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYnJvd3NlciA9IFN0cmluZyhvYmplY3QuYnJvd3Nlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmJyb3dzZXIgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QuYnJvd3NlclZlcnNpb24gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYnJvd3NlclZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYnJvd3NlclZlcnNpb24gPSBTdHJpbmcob2JqZWN0LmJyb3dzZXJWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYnJvd3NlclZlcnNpb24gPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuc2RrICE9PSB1bmRlZmluZWQgJiYgKG9iai5zZGsgPSBjbGllbnRJbmZvX1NES1RvSlNPTihtZXNzYWdlLnNkaykpO1xuICAgICAgICBtZXNzYWdlLnZlcnNpb24gIT09IHVuZGVmaW5lZCAmJiAob2JqLnZlcnNpb24gPSBtZXNzYWdlLnZlcnNpb24pO1xuICAgICAgICBtZXNzYWdlLnByb3RvY29sICE9PSB1bmRlZmluZWQgJiYgKG9iai5wcm90b2NvbCA9IG1lc3NhZ2UucHJvdG9jb2wpO1xuICAgICAgICBtZXNzYWdlLm9zICE9PSB1bmRlZmluZWQgJiYgKG9iai5vcyA9IG1lc3NhZ2Uub3MpO1xuICAgICAgICBtZXNzYWdlLm9zVmVyc2lvbiAhPT0gdW5kZWZpbmVkICYmIChvYmoub3NWZXJzaW9uID0gbWVzc2FnZS5vc1ZlcnNpb24pO1xuICAgICAgICBtZXNzYWdlLmRldmljZU1vZGVsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGV2aWNlTW9kZWwgPSBtZXNzYWdlLmRldmljZU1vZGVsKTtcbiAgICAgICAgbWVzc2FnZS5icm93c2VyICE9PSB1bmRlZmluZWQgJiYgKG9iai5icm93c2VyID0gbWVzc2FnZS5icm93c2VyKTtcbiAgICAgICAgbWVzc2FnZS5icm93c2VyVmVyc2lvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmJyb3dzZXJWZXJzaW9uID0gbWVzc2FnZS5icm93c2VyVmVyc2lvbik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VDbGllbnRJbmZvKTtcbiAgICAgICAgbWVzc2FnZS5zZGsgPSAoX2EgPSBvYmplY3Quc2RrKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSAoX2IgPSBvYmplY3QudmVyc2lvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5wcm90b2NvbCA9IChfYyA9IG9iamVjdC5wcm90b2NvbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcbiAgICAgICAgbWVzc2FnZS5vcyA9IChfZCA9IG9iamVjdC5vcykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5vc1ZlcnNpb24gPSAoX2UgPSBvYmplY3Qub3NWZXJzaW9uKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmRldmljZU1vZGVsID0gKF9mID0gb2JqZWN0LmRldmljZU1vZGVsKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmJyb3dzZXIgPSAoX2cgPSBvYmplY3QuYnJvd3NlcikgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5icm93c2VyVmVyc2lvbiA9IChfaCA9IG9iamVjdC5icm93c2VyVmVyc2lvbikgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuY29uc3QgYXRvYiA9IGdsb2JhbFRoaXMuYXRvYiB8fFxuICAgICgoYjY0KSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGNvbnN0IGJpbiA9IGF0b2IoYjY0KTtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmNvbnN0IGJ0b2EgPSBnbG9iYWxUaGlzLmJ0b2EgfHxcbiAgICAoKGJpbikgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiaW4sIFwiYmluYXJ5XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBjb25zdCBiaW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgYXJyKSB7XG4gICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShiaW4uam9pbihcIlwiKSk7XG59XG5mdW5jdGlvbiBsb25nVG9OdW1iZXIobG9uZykge1xuICAgIGlmIChsb25nLmd0KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSkge1xuICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcIlZhbHVlIGlzIGxhcmdlciB0aGFuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbG9uZy50b051bWJlcigpO1xufVxuaWYgKG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyAhPT0gbG9uZ18xLmRlZmF1bHQpIHtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgPSBsb25nXzEuZGVmYXVsdDtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC5jb25maWd1cmUoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpdmVraXRfbW9kZWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaW11bGF0ZVNjZW5hcmlvID0gZXhwb3J0cy5TeW5jU3RhdGUgPSBleHBvcnRzLlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPSBleHBvcnRzLlN1YnNjcmlwdGlvblBlcm1pc3Npb24gPSBleHBvcnRzLlRyYWNrUGVybWlzc2lvbiA9IGV4cG9ydHMuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSBleHBvcnRzLlN1YnNjcmliZWRRdWFsaXR5ID0gZXhwb3J0cy5TdHJlYW1TdGF0ZVVwZGF0ZSA9IGV4cG9ydHMuU3RyZWFtU3RhdGVJbmZvID0gZXhwb3J0cy5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZSA9IGV4cG9ydHMuQ29ubmVjdGlvblF1YWxpdHlJbmZvID0gZXhwb3J0cy5Sb29tVXBkYXRlID0gZXhwb3J0cy5TcGVha2Vyc0NoYW5nZWQgPSBleHBvcnRzLklDRVNlcnZlciA9IGV4cG9ydHMuVXBkYXRlVmlkZW9MYXllcnMgPSBleHBvcnRzLkxlYXZlUmVxdWVzdCA9IGV4cG9ydHMuVXBkYXRlVHJhY2tTZXR0aW5ncyA9IGV4cG9ydHMuVXBkYXRlU3Vic2NyaXB0aW9uID0gZXhwb3J0cy5QYXJ0aWNpcGFudFVwZGF0ZSA9IGV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uID0gZXhwb3J0cy5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlID0gZXhwb3J0cy5Kb2luUmVzcG9uc2UgPSBleHBvcnRzLk11dGVUcmFja1JlcXVlc3QgPSBleHBvcnRzLlRyaWNrbGVSZXF1ZXN0ID0gZXhwb3J0cy5BZGRUcmFja1JlcXVlc3QgPSBleHBvcnRzLlNpZ25hbFJlc3BvbnNlID0gZXhwb3J0cy5TaWduYWxSZXF1ZXN0ID0gZXhwb3J0cy5zdHJlYW1TdGF0ZVRvSlNPTiA9IGV4cG9ydHMuc3RyZWFtU3RhdGVGcm9tSlNPTiA9IGV4cG9ydHMuU3RyZWFtU3RhdGUgPSBleHBvcnRzLnNpZ25hbFRhcmdldFRvSlNPTiA9IGV4cG9ydHMuc2lnbmFsVGFyZ2V0RnJvbUpTT04gPSBleHBvcnRzLlNpZ25hbFRhcmdldCA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5jb25zdCBsaXZla2l0X21vZGVsc18xID0gcmVxdWlyZShcIi4vbGl2ZWtpdF9tb2RlbHNcIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwibGl2ZWtpdFwiO1xudmFyIFNpZ25hbFRhcmdldDtcbihmdW5jdGlvbiAoU2lnbmFsVGFyZ2V0KSB7XG4gICAgU2lnbmFsVGFyZ2V0W1NpZ25hbFRhcmdldFtcIlBVQkxJU0hFUlwiXSA9IDBdID0gXCJQVUJMSVNIRVJcIjtcbiAgICBTaWduYWxUYXJnZXRbU2lnbmFsVGFyZ2V0W1wiU1VCU0NSSUJFUlwiXSA9IDFdID0gXCJTVUJTQ1JJQkVSXCI7XG4gICAgU2lnbmFsVGFyZ2V0W1NpZ25hbFRhcmdldFtcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShTaWduYWxUYXJnZXQgPSBleHBvcnRzLlNpZ25hbFRhcmdldCB8fCAoZXhwb3J0cy5TaWduYWxUYXJnZXQgPSB7fSkpO1xuZnVuY3Rpb24gc2lnbmFsVGFyZ2V0RnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiUFVCTElTSEVSXCI6XG4gICAgICAgICAgICByZXR1cm4gU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUjtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIFwiU1VCU0NSSUJFUlwiOlxuICAgICAgICAgICAgcmV0dXJuIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gU2lnbmFsVGFyZ2V0LlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnRzLnNpZ25hbFRhcmdldEZyb21KU09OID0gc2lnbmFsVGFyZ2V0RnJvbUpTT047XG5mdW5jdGlvbiBzaWduYWxUYXJnZXRUb0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBTaWduYWxUYXJnZXQuUFVCTElTSEVSOlxuICAgICAgICAgICAgcmV0dXJuIFwiUFVCTElTSEVSXCI7XG4gICAgICAgIGNhc2UgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVI6XG4gICAgICAgICAgICByZXR1cm4gXCJTVUJTQ1JJQkVSXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJVTktOT1dOXCI7XG4gICAgfVxufVxuZXhwb3J0cy5zaWduYWxUYXJnZXRUb0pTT04gPSBzaWduYWxUYXJnZXRUb0pTT047XG52YXIgU3RyZWFtU3RhdGU7XG4oZnVuY3Rpb24gKFN0cmVhbVN0YXRlKSB7XG4gICAgU3RyZWFtU3RhdGVbU3RyZWFtU3RhdGVbXCJBQ1RJVkVcIl0gPSAwXSA9IFwiQUNUSVZFXCI7XG4gICAgU3RyZWFtU3RhdGVbU3RyZWFtU3RhdGVbXCJQQVVTRURcIl0gPSAxXSA9IFwiUEFVU0VEXCI7XG4gICAgU3RyZWFtU3RhdGVbU3RyZWFtU3RhdGVbXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoU3RyZWFtU3RhdGUgPSBleHBvcnRzLlN0cmVhbVN0YXRlIHx8IChleHBvcnRzLlN0cmVhbVN0YXRlID0ge30pKTtcbmZ1bmN0aW9uIHN0cmVhbVN0YXRlRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiQUNUSVZFXCI6XG4gICAgICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUuQUNUSVZFO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJQQVVTRURcIjpcbiAgICAgICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZS5QQVVTRUQ7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgXCJVTlJFQ09HTklaRURcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZS5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0cy5zdHJlYW1TdGF0ZUZyb21KU09OID0gc3RyZWFtU3RhdGVGcm9tSlNPTjtcbmZ1bmN0aW9uIHN0cmVhbVN0YXRlVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgU3RyZWFtU3RhdGUuQUNUSVZFOlxuICAgICAgICAgICAgcmV0dXJuIFwiQUNUSVZFXCI7XG4gICAgICAgIGNhc2UgU3RyZWFtU3RhdGUuUEFVU0VEOlxuICAgICAgICAgICAgcmV0dXJuIFwiUEFVU0VEXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJVTktOT1dOXCI7XG4gICAgfVxufVxuZXhwb3J0cy5zdHJlYW1TdGF0ZVRvSlNPTiA9IHN0cmVhbVN0YXRlVG9KU09OO1xuY29uc3QgYmFzZVNpZ25hbFJlcXVlc3QgPSB7fTtcbmV4cG9ydHMuU2lnbmFsUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm9mZmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uLmVuY29kZShtZXNzYWdlLm9mZmVyLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFuc3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlNlc3Npb25EZXNjcmlwdGlvbi5lbmNvZGUobWVzc2FnZS5hbnN3ZXIsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHJpY2tsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlRyaWNrbGVSZXF1ZXN0LmVuY29kZShtZXNzYWdlLnRyaWNrbGUsIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWRkVHJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5BZGRUcmFja1JlcXVlc3QuZW5jb2RlKG1lc3NhZ2UuYWRkVHJhY2ssIHdyaXRlci51aW50MzIoMzQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubXV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLk11dGVUcmFja1JlcXVlc3QuZW5jb2RlKG1lc3NhZ2UubXV0ZSwgd3JpdGVyLnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zdWJzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5VcGRhdGVTdWJzY3JpcHRpb24uZW5jb2RlKG1lc3NhZ2Uuc3Vic2NyaXB0aW9uLCB3cml0ZXIudWludDMyKDUwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRyYWNrU2V0dGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlVwZGF0ZVRyYWNrU2V0dGluZ3MuZW5jb2RlKG1lc3NhZ2UudHJhY2tTZXR0aW5nLCB3cml0ZXIudWludDMyKDU4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmxlYXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuTGVhdmVSZXF1ZXN0LmVuY29kZShtZXNzYWdlLmxlYXZlLCB3cml0ZXIudWludDMyKDY2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnVwZGF0ZUxheWVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlVwZGF0ZVZpZGVvTGF5ZXJzLmVuY29kZShtZXNzYWdlLnVwZGF0ZUxheWVycywgd3JpdGVyLnVpbnQzMig4MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zdWJzY3JpcHRpb25QZXJtaXNzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuU3Vic2NyaXB0aW9uUGVybWlzc2lvbi5lbmNvZGUobWVzc2FnZS5zdWJzY3JpcHRpb25QZXJtaXNzaW9uLCB3cml0ZXIudWludDMyKDkwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN5bmNTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlN5bmNTdGF0ZS5lbmNvZGUobWVzc2FnZS5zeW5jU3RhdGUsIHdyaXRlci51aW50MzIoOTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2ltdWxhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5TaW11bGF0ZVNjZW5hcmlvLmVuY29kZShtZXNzYWdlLnNpbXVsYXRlLCB3cml0ZXIudWludDMyKDEwNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTaWduYWxSZXF1ZXN0KTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9mZmVyID0gZXhwb3J0cy5TZXNzaW9uRGVzY3JpcHRpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFuc3dlciA9IGV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmlja2xlID0gZXhwb3J0cy5Ucmlja2xlUmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkVHJhY2sgPSBleHBvcnRzLkFkZFRyYWNrUmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubXV0ZSA9IGV4cG9ydHMuTXV0ZVRyYWNrUmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaXB0aW9uID0gZXhwb3J0cy5VcGRhdGVTdWJzY3JpcHRpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWNrU2V0dGluZyA9IGV4cG9ydHMuVXBkYXRlVHJhY2tTZXR0aW5ncy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVhdmUgPSBleHBvcnRzLkxlYXZlUmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZUxheWVycyA9IGV4cG9ydHMuVXBkYXRlVmlkZW9MYXllcnMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdWJzY3JpcHRpb25QZXJtaXNzaW9uID0gZXhwb3J0cy5TdWJzY3JpcHRpb25QZXJtaXNzaW9uLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3luY1N0YXRlID0gZXhwb3J0cy5TeW5jU3RhdGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaW11bGF0ZSA9IGV4cG9ydHMuU2ltdWxhdGVTY2VuYXJpby5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU2lnbmFsUmVxdWVzdCk7XG4gICAgICAgIGlmIChvYmplY3Qub2ZmZXIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Qub2ZmZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uub2ZmZXIgPSBleHBvcnRzLlNlc3Npb25EZXNjcmlwdGlvbi5mcm9tSlNPTihvYmplY3Qub2ZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5vZmZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LmFuc3dlciAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5hbnN3ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYW5zd2VyID0gZXhwb3J0cy5TZXNzaW9uRGVzY3JpcHRpb24uZnJvbUpTT04ob2JqZWN0LmFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmFuc3dlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnRyaWNrbGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudHJpY2tsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS50cmlja2xlID0gZXhwb3J0cy5Ucmlja2xlUmVxdWVzdC5mcm9tSlNPTihvYmplY3QudHJpY2tsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnRyaWNrbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5hZGRUcmFjayAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5hZGRUcmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5hZGRUcmFjayA9IGV4cG9ydHMuQWRkVHJhY2tSZXF1ZXN0LmZyb21KU09OKG9iamVjdC5hZGRUcmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmFkZFRyYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QubXV0ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5tdXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLm11dGUgPSBleHBvcnRzLk11dGVUcmFja1JlcXVlc3QuZnJvbUpTT04ob2JqZWN0Lm11dGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5tdXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Quc3Vic2NyaXB0aW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnN1YnNjcmlwdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5zdWJzY3JpcHRpb24gPSBleHBvcnRzLlVwZGF0ZVN1YnNjcmlwdGlvbi5mcm9tSlNPTihvYmplY3Quc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QudHJhY2tTZXR0aW5nICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnRyYWNrU2V0dGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS50cmFja1NldHRpbmcgPSBleHBvcnRzLlVwZGF0ZVRyYWNrU2V0dGluZ3MuZnJvbUpTT04ob2JqZWN0LnRyYWNrU2V0dGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnRyYWNrU2V0dGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LmxlYXZlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmxlYXZlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmxlYXZlID0gZXhwb3J0cy5MZWF2ZVJlcXVlc3QuZnJvbUpTT04ob2JqZWN0LmxlYXZlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubGVhdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC51cGRhdGVMYXllcnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudXBkYXRlTGF5ZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZUxheWVycyA9IGV4cG9ydHMuVXBkYXRlVmlkZW9MYXllcnMuZnJvbUpTT04ob2JqZWN0LnVwZGF0ZUxheWVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZUxheWVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnN1YnNjcmlwdGlvblBlcm1pc3Npb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgb2JqZWN0LnN1YnNjcmlwdGlvblBlcm1pc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaXB0aW9uUGVybWlzc2lvbiA9IGV4cG9ydHMuU3Vic2NyaXB0aW9uUGVybWlzc2lvbi5mcm9tSlNPTihvYmplY3Quc3Vic2NyaXB0aW9uUGVybWlzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmlwdGlvblBlcm1pc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zeW5jU3RhdGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc3luY1N0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN5bmNTdGF0ZSA9IGV4cG9ydHMuU3luY1N0YXRlLmZyb21KU09OKG9iamVjdC5zeW5jU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5zeW5jU3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zaW11bGF0ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zaW11bGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5zaW11bGF0ZSA9IGV4cG9ydHMuU2ltdWxhdGVTY2VuYXJpby5mcm9tSlNPTihvYmplY3Quc2ltdWxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5zaW11bGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLm9mZmVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoub2ZmZXIgPSBtZXNzYWdlLm9mZmVyXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlNlc3Npb25EZXNjcmlwdGlvbi50b0pTT04obWVzc2FnZS5vZmZlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuYW5zd2VyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYW5zd2VyID0gbWVzc2FnZS5hbnN3ZXJcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uLnRvSlNPTihtZXNzYWdlLmFuc3dlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UudHJpY2tsZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRyaWNrbGUgPSBtZXNzYWdlLnRyaWNrbGVcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuVHJpY2tsZVJlcXVlc3QudG9KU09OKG1lc3NhZ2UudHJpY2tsZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuYWRkVHJhY2sgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hZGRUcmFjayA9IG1lc3NhZ2UuYWRkVHJhY2tcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQWRkVHJhY2tSZXF1ZXN0LnRvSlNPTihtZXNzYWdlLmFkZFRyYWNrKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5tdXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubXV0ZSA9IG1lc3NhZ2UubXV0ZVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5NdXRlVHJhY2tSZXF1ZXN0LnRvSlNPTihtZXNzYWdlLm11dGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnN1YnNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnN1YnNjcmlwdGlvbiA9IG1lc3NhZ2Uuc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlVwZGF0ZVN1YnNjcmlwdGlvbi50b0pTT04obWVzc2FnZS5zdWJzY3JpcHRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnRyYWNrU2V0dGluZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRyYWNrU2V0dGluZyA9IG1lc3NhZ2UudHJhY2tTZXR0aW5nXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlVwZGF0ZVRyYWNrU2V0dGluZ3MudG9KU09OKG1lc3NhZ2UudHJhY2tTZXR0aW5nKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5sZWF2ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmxlYXZlID0gbWVzc2FnZS5sZWF2ZVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5MZWF2ZVJlcXVlc3QudG9KU09OKG1lc3NhZ2UubGVhdmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnVwZGF0ZUxheWVycyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnVwZGF0ZUxheWVycyA9IG1lc3NhZ2UudXBkYXRlTGF5ZXJzXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlVwZGF0ZVZpZGVvTGF5ZXJzLnRvSlNPTihtZXNzYWdlLnVwZGF0ZUxheWVycylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2Uuc3Vic2NyaXB0aW9uUGVybWlzc2lvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnN1YnNjcmlwdGlvblBlcm1pc3Npb24gPSBtZXNzYWdlLnN1YnNjcmlwdGlvblBlcm1pc3Npb25cbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuU3Vic2NyaXB0aW9uUGVybWlzc2lvbi50b0pTT04obWVzc2FnZS5zdWJzY3JpcHRpb25QZXJtaXNzaW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5zeW5jU3RhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zeW5jU3RhdGUgPSBtZXNzYWdlLnN5bmNTdGF0ZVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TeW5jU3RhdGUudG9KU09OKG1lc3NhZ2Uuc3luY1N0YXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5zaW11bGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNpbXVsYXRlID0gbWVzc2FnZS5zaW11bGF0ZVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TaW11bGF0ZVNjZW5hcmlvLnRvSlNPTihtZXNzYWdlLnNpbXVsYXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVNpZ25hbFJlcXVlc3QpO1xuICAgICAgICBpZiAob2JqZWN0Lm9mZmVyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lm9mZmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLm9mZmVyID0gZXhwb3J0cy5TZXNzaW9uRGVzY3JpcHRpb24uZnJvbVBhcnRpYWwob2JqZWN0Lm9mZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uub2ZmZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5hbnN3ZXIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYW5zd2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmFuc3dlciA9IGV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uLmZyb21QYXJ0aWFsKG9iamVjdC5hbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5hbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC50cmlja2xlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnRyaWNrbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHJpY2tsZSA9IGV4cG9ydHMuVHJpY2tsZVJlcXVlc3QuZnJvbVBhcnRpYWwob2JqZWN0LnRyaWNrbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS50cmlja2xlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QuYWRkVHJhY2sgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYWRkVHJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYWRkVHJhY2sgPSBleHBvcnRzLkFkZFRyYWNrUmVxdWVzdC5mcm9tUGFydGlhbChvYmplY3QuYWRkVHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5hZGRUcmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Lm11dGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubXV0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5tdXRlID0gZXhwb3J0cy5NdXRlVHJhY2tSZXF1ZXN0LmZyb21QYXJ0aWFsKG9iamVjdC5tdXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubXV0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnN1YnNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zdWJzY3JpcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaXB0aW9uID0gZXhwb3J0cy5VcGRhdGVTdWJzY3JpcHRpb24uZnJvbVBhcnRpYWwob2JqZWN0LnN1YnNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnRyYWNrU2V0dGluZyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50cmFja1NldHRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tTZXR0aW5nID0gZXhwb3J0cy5VcGRhdGVUcmFja1NldHRpbmdzLmZyb21QYXJ0aWFsKG9iamVjdC50cmFja1NldHRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS50cmFja1NldHRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5sZWF2ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5sZWF2ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5sZWF2ZSA9IGV4cG9ydHMuTGVhdmVSZXF1ZXN0LmZyb21QYXJ0aWFsKG9iamVjdC5sZWF2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmxlYXZlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QudXBkYXRlTGF5ZXJzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnVwZGF0ZUxheWVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS51cGRhdGVMYXllcnMgPSBleHBvcnRzLlVwZGF0ZVZpZGVvTGF5ZXJzLmZyb21QYXJ0aWFsKG9iamVjdC51cGRhdGVMYXllcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS51cGRhdGVMYXllcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zdWJzY3JpcHRpb25QZXJtaXNzaW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIG9iamVjdC5zdWJzY3JpcHRpb25QZXJtaXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmlwdGlvblBlcm1pc3Npb24gPSBleHBvcnRzLlN1YnNjcmlwdGlvblBlcm1pc3Npb24uZnJvbVBhcnRpYWwob2JqZWN0LnN1YnNjcmlwdGlvblBlcm1pc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5zdWJzY3JpcHRpb25QZXJtaXNzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Quc3luY1N0YXRlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnN5bmNTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5zeW5jU3RhdGUgPSBleHBvcnRzLlN5bmNTdGF0ZS5mcm9tUGFydGlhbChvYmplY3Quc3luY1N0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3luY1N0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Quc2ltdWxhdGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2ltdWxhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2ltdWxhdGUgPSBleHBvcnRzLlNpbXVsYXRlU2NlbmFyaW8uZnJvbVBhcnRpYWwob2JqZWN0LnNpbXVsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2ltdWxhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlU2lnbmFsUmVzcG9uc2UgPSB7fTtcbmV4cG9ydHMuU2lnbmFsUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5qb2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuSm9pblJlc3BvbnNlLmVuY29kZShtZXNzYWdlLmpvaW4sIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYW5zd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uLmVuY29kZShtZXNzYWdlLmFuc3dlciwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5vZmZlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlNlc3Npb25EZXNjcmlwdGlvbi5lbmNvZGUobWVzc2FnZS5vZmZlciwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50cmlja2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVHJpY2tsZVJlcXVlc3QuZW5jb2RlKG1lc3NhZ2UudHJpY2tsZSwgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS51cGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5QYXJ0aWNpcGFudFVwZGF0ZS5lbmNvZGUobWVzc2FnZS51cGRhdGUsIHdyaXRlci51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tQdWJsaXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlLmVuY29kZShtZXNzYWdlLnRyYWNrUHVibGlzaGVkLCB3cml0ZXIudWludDMyKDUwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmxlYXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuTGVhdmVSZXF1ZXN0LmVuY29kZShtZXNzYWdlLmxlYXZlLCB3cml0ZXIudWludDMyKDY2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm11dGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5NdXRlVHJhY2tSZXF1ZXN0LmVuY29kZShtZXNzYWdlLm11dGUsIHdyaXRlci51aW50MzIoNzQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3BlYWtlcnNDaGFuZ2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuU3BlYWtlcnNDaGFuZ2VkLmVuY29kZShtZXNzYWdlLnNwZWFrZXJzQ2hhbmdlZCwgd3JpdGVyLnVpbnQzMig4MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yb29tVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuUm9vbVVwZGF0ZS5lbmNvZGUobWVzc2FnZS5yb29tVXBkYXRlLCB3cml0ZXIudWludDMyKDkwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUuZW5jb2RlKG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHksIHdyaXRlci51aW50MzIoOTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyZWFtU3RhdGVVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5TdHJlYW1TdGF0ZVVwZGF0ZS5lbmNvZGUobWVzc2FnZS5zdHJlYW1TdGF0ZVVwZGF0ZSwgd3JpdGVyLnVpbnQzMigxMDYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZS5lbmNvZGUobWVzc2FnZS5zdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSwgd3JpdGVyLnVpbnQzMigxMTQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUuZW5jb2RlKG1lc3NhZ2Uuc3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgd3JpdGVyLnVpbnQzMigxMjIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVmcmVzaFRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTMwKS5zdHJpbmcobWVzc2FnZS5yZWZyZXNoVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVNpZ25hbFJlc3BvbnNlKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmpvaW4gPSBleHBvcnRzLkpvaW5SZXNwb25zZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYW5zd2VyID0gZXhwb3J0cy5TZXNzaW9uRGVzY3JpcHRpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9mZmVyID0gZXhwb3J0cy5TZXNzaW9uRGVzY3JpcHRpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyaWNrbGUgPSBleHBvcnRzLlRyaWNrbGVSZXF1ZXN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51cGRhdGUgPSBleHBvcnRzLlBhcnRpY2lwYW50VXBkYXRlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja1B1Ymxpc2hlZCA9IGV4cG9ydHMuVHJhY2tQdWJsaXNoZWRSZXNwb25zZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVhdmUgPSBleHBvcnRzLkxlYXZlUmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubXV0ZSA9IGV4cG9ydHMuTXV0ZVRyYWNrUmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNwZWFrZXJzQ2hhbmdlZCA9IGV4cG9ydHMuU3BlYWtlcnNDaGFuZ2VkLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uucm9vbVVwZGF0ZSA9IGV4cG9ydHMuUm9vbVVwZGF0ZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5ID0gZXhwb3J0cy5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmVhbVN0YXRlVXBkYXRlID0gZXhwb3J0cy5TdHJlYW1TdGF0ZVVwZGF0ZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gZXhwb3J0cy5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVmcmVzaFRva2VuID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU2lnbmFsUmVzcG9uc2UpO1xuICAgICAgICBpZiAob2JqZWN0LmpvaW4gIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quam9pbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5qb2luID0gZXhwb3J0cy5Kb2luUmVzcG9uc2UuZnJvbUpTT04ob2JqZWN0LmpvaW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5qb2luID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QuYW5zd2VyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmFuc3dlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5hbnN3ZXIgPSBleHBvcnRzLlNlc3Npb25EZXNjcmlwdGlvbi5mcm9tSlNPTihvYmplY3QuYW5zd2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYW5zd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Qub2ZmZXIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Qub2ZmZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uub2ZmZXIgPSBleHBvcnRzLlNlc3Npb25EZXNjcmlwdGlvbi5mcm9tSlNPTihvYmplY3Qub2ZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5vZmZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnRyaWNrbGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudHJpY2tsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS50cmlja2xlID0gZXhwb3J0cy5Ucmlja2xlUmVxdWVzdC5mcm9tSlNPTihvYmplY3QudHJpY2tsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnRyaWNrbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC51cGRhdGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZSA9IGV4cG9ydHMuUGFydGljaXBhbnRVcGRhdGUuZnJvbUpTT04ob2JqZWN0LnVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnRyYWNrUHVibGlzaGVkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnRyYWNrUHVibGlzaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnRyYWNrUHVibGlzaGVkID0gZXhwb3J0cy5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlLmZyb21KU09OKG9iamVjdC50cmFja1B1Ymxpc2hlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnRyYWNrUHVibGlzaGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QubGVhdmUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubGVhdmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubGVhdmUgPSBleHBvcnRzLkxlYXZlUmVxdWVzdC5mcm9tSlNPTihvYmplY3QubGVhdmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5sZWF2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Lm11dGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubXV0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5tdXRlID0gZXhwb3J0cy5NdXRlVHJhY2tSZXF1ZXN0LmZyb21KU09OKG9iamVjdC5tdXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubXV0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnNwZWFrZXJzQ2hhbmdlZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBvYmplY3Quc3BlYWtlcnNDaGFuZ2VkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNwZWFrZXJzQ2hhbmdlZCA9IGV4cG9ydHMuU3BlYWtlcnNDaGFuZ2VkLmZyb21KU09OKG9iamVjdC5zcGVha2Vyc0NoYW5nZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5zcGVha2Vyc0NoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5yb29tVXBkYXRlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJvb21VcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uucm9vbVVwZGF0ZSA9IGV4cG9ydHMuUm9vbVVwZGF0ZS5mcm9tSlNPTihvYmplY3Qucm9vbVVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnJvb21VcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5jb25uZWN0aW9uUXVhbGl0eSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBvYmplY3QuY29ubmVjdGlvblF1YWxpdHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkgPSBleHBvcnRzLkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLmZyb21KU09OKG9iamVjdC5jb25uZWN0aW9uUXVhbGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Quc3RyZWFtU3RhdGVVcGRhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgb2JqZWN0LnN0cmVhbVN0YXRlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN0cmVhbVN0YXRlVXBkYXRlID0gZXhwb3J0cy5TdHJlYW1TdGF0ZVVwZGF0ZS5mcm9tSlNPTihvYmplY3Quc3RyZWFtU3RhdGVVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5zdHJlYW1TdGF0ZVVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnN1YnNjcmliZWRRdWFsaXR5VXBkYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIG9iamVjdC5zdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5zdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IGV4cG9ydHMuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUuZnJvbUpTT04ob2JqZWN0LnN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIG9iamVjdC5zdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPVxuICAgICAgICAgICAgICAgIGV4cG9ydHMuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZS5mcm9tSlNPTihvYmplY3Quc3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5yZWZyZXNoVG9rZW4gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVmcmVzaFRva2VuICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnJlZnJlc2hUb2tlbiA9IFN0cmluZyhvYmplY3QucmVmcmVzaFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UucmVmcmVzaFRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuam9pbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmpvaW4gPSBtZXNzYWdlLmpvaW4gPyBleHBvcnRzLkpvaW5SZXNwb25zZS50b0pTT04obWVzc2FnZS5qb2luKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuYW5zd2VyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYW5zd2VyID0gbWVzc2FnZS5hbnN3ZXJcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uLnRvSlNPTihtZXNzYWdlLmFuc3dlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2Uub2ZmZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5vZmZlciA9IG1lc3NhZ2Uub2ZmZXJcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uLnRvSlNPTihtZXNzYWdlLm9mZmVyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS50cmlja2xlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudHJpY2tsZSA9IG1lc3NhZ2UudHJpY2tsZVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Ucmlja2xlUmVxdWVzdC50b0pTT04obWVzc2FnZS50cmlja2xlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS51cGRhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai51cGRhdGUgPSBtZXNzYWdlLnVwZGF0ZVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5QYXJ0aWNpcGFudFVwZGF0ZS50b0pTT04obWVzc2FnZS51cGRhdGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnRyYWNrUHVibGlzaGVkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudHJhY2tQdWJsaXNoZWQgPSBtZXNzYWdlLnRyYWNrUHVibGlzaGVkXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlRyYWNrUHVibGlzaGVkUmVzcG9uc2UudG9KU09OKG1lc3NhZ2UudHJhY2tQdWJsaXNoZWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmxlYXZlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubGVhdmUgPSBtZXNzYWdlLmxlYXZlXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkxlYXZlUmVxdWVzdC50b0pTT04obWVzc2FnZS5sZWF2ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UubXV0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm11dGUgPSBtZXNzYWdlLm11dGVcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuTXV0ZVRyYWNrUmVxdWVzdC50b0pTT04obWVzc2FnZS5tdXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5zcGVha2Vyc0NoYW5nZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zcGVha2Vyc0NoYW5nZWQgPSBtZXNzYWdlLnNwZWFrZXJzQ2hhbmdlZFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TcGVha2Vyc0NoYW5nZWQudG9KU09OKG1lc3NhZ2Uuc3BlYWtlcnNDaGFuZ2VkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5yb29tVXBkYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucm9vbVVwZGF0ZSA9IG1lc3NhZ2Uucm9vbVVwZGF0ZVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Sb29tVXBkYXRlLnRvSlNPTihtZXNzYWdlLnJvb21VcGRhdGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29ubmVjdGlvblF1YWxpdHkgPSBtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5XG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLnRvSlNPTihtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5zdHJlYW1TdGF0ZVVwZGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnN0cmVhbVN0YXRlVXBkYXRlID0gbWVzc2FnZS5zdHJlYW1TdGF0ZVVwZGF0ZVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TdHJlYW1TdGF0ZVVwZGF0ZS50b0pTT04obWVzc2FnZS5zdHJlYW1TdGF0ZVVwZGF0ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2Uuc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IG1lc3NhZ2Uuc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGVcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUudG9KU09OKG1lc3NhZ2Uuc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gbWVzc2FnZS5zdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUudG9KU09OKG1lc3NhZ2Uuc3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UucmVmcmVzaFRva2VuICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucmVmcmVzaFRva2VuID0gbWVzc2FnZS5yZWZyZXNoVG9rZW4pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTaWduYWxSZXNwb25zZSk7XG4gICAgICAgIGlmIChvYmplY3Quam9pbiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5qb2luICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmpvaW4gPSBleHBvcnRzLkpvaW5SZXNwb25zZS5mcm9tUGFydGlhbChvYmplY3Quam9pbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmpvaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5hbnN3ZXIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYW5zd2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmFuc3dlciA9IGV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uLmZyb21QYXJ0aWFsKG9iamVjdC5hbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5hbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5vZmZlciAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5vZmZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5vZmZlciA9IGV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uLmZyb21QYXJ0aWFsKG9iamVjdC5vZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLm9mZmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QudHJpY2tsZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50cmlja2xlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnRyaWNrbGUgPSBleHBvcnRzLlRyaWNrbGVSZXF1ZXN0LmZyb21QYXJ0aWFsKG9iamVjdC50cmlja2xlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHJpY2tsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnVwZGF0ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC51cGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudXBkYXRlID0gZXhwb3J0cy5QYXJ0aWNpcGFudFVwZGF0ZS5mcm9tUGFydGlhbChvYmplY3QudXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudXBkYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QudHJhY2tQdWJsaXNoZWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudHJhY2tQdWJsaXNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tQdWJsaXNoZWQgPSBleHBvcnRzLlRyYWNrUHVibGlzaGVkUmVzcG9uc2UuZnJvbVBhcnRpYWwob2JqZWN0LnRyYWNrUHVibGlzaGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tQdWJsaXNoZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5sZWF2ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5sZWF2ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5sZWF2ZSA9IGV4cG9ydHMuTGVhdmVSZXF1ZXN0LmZyb21QYXJ0aWFsKG9iamVjdC5sZWF2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmxlYXZlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QubXV0ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5tdXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLm11dGUgPSBleHBvcnRzLk11dGVUcmFja1JlcXVlc3QuZnJvbVBhcnRpYWwob2JqZWN0Lm11dGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5tdXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Quc3BlYWtlcnNDaGFuZ2VkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIG9iamVjdC5zcGVha2Vyc0NoYW5nZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3BlYWtlcnNDaGFuZ2VkID0gZXhwb3J0cy5TcGVha2Vyc0NoYW5nZWQuZnJvbVBhcnRpYWwob2JqZWN0LnNwZWFrZXJzQ2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNwZWFrZXJzQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnJvb21VcGRhdGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Qucm9vbVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5yb29tVXBkYXRlID0gZXhwb3J0cy5Sb29tVXBkYXRlLmZyb21QYXJ0aWFsKG9iamVjdC5yb29tVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uucm9vbVVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LmNvbm5lY3Rpb25RdWFsaXR5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIG9iamVjdC5jb25uZWN0aW9uUXVhbGl0eSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eSA9IGV4cG9ydHMuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUuZnJvbVBhcnRpYWwob2JqZWN0LmNvbm5lY3Rpb25RdWFsaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zdHJlYW1TdGF0ZVVwZGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBvYmplY3Quc3RyZWFtU3RhdGVVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3RyZWFtU3RhdGVVcGRhdGUgPSBleHBvcnRzLlN0cmVhbVN0YXRlVXBkYXRlLmZyb21QYXJ0aWFsKG9iamVjdC5zdHJlYW1TdGF0ZVVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN0cmVhbVN0YXRlVXBkYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Quc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgb2JqZWN0LnN1YnNjcmliZWRRdWFsaXR5VXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gZXhwb3J0cy5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZS5mcm9tUGFydGlhbChvYmplY3Quc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5zdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgb2JqZWN0LnN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLmZyb21QYXJ0aWFsKG9iamVjdC5zdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLnJlZnJlc2hUb2tlbiA9IChfYSA9IG9iamVjdC5yZWZyZXNoVG9rZW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlQWRkVHJhY2tSZXF1ZXN0ID0ge1xuICAgIGNpZDogXCJcIixcbiAgICBuYW1lOiBcIlwiLFxuICAgIHR5cGU6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIG11dGVkOiBmYWxzZSxcbiAgICBkaXNhYmxlRHR4OiBmYWxzZSxcbiAgICBzb3VyY2U6IDAsXG59O1xuZXhwb3J0cy5BZGRUcmFja1JlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5jaWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS53aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzMikudWludDMyKG1lc3NhZ2Uud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmhlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0MCkudWludDMyKG1lc3NhZ2UuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5tdXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0OCkuYm9vbChtZXNzYWdlLm11dGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kaXNhYmxlRHR4ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDU2KS5ib29sKG1lc3NhZ2UuZGlzYWJsZUR0eCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc291cmNlICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDY0KS5pbnQzMihtZXNzYWdlLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UubGF5ZXJzKSB7XG4gICAgICAgICAgICBsaXZla2l0X21vZGVsc18xLlZpZGVvTGF5ZXIuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoNzQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlQWRkVHJhY2tSZXF1ZXN0KTtcbiAgICAgICAgbWVzc2FnZS5sYXllcnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNpZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS53aWR0aCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhlaWdodCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm11dGVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpc2FibGVEdHggPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc291cmNlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sYXllcnMucHVzaChsaXZla2l0X21vZGVsc18xLlZpZGVvTGF5ZXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VBZGRUcmFja1JlcXVlc3QpO1xuICAgICAgICBtZXNzYWdlLmxheWVycyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LmNpZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuY2lkID0gU3RyaW5nKG9iamVjdC5jaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5jaWQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QubmFtZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5uYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSBTdHJpbmcob2JqZWN0Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnR5cGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gbGl2ZWtpdF9tb2RlbHNfMS50cmFja1R5cGVGcm9tSlNPTihvYmplY3QudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Qud2lkdGggIT09IHVuZGVmaW5lZCAmJiBvYmplY3Qud2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uud2lkdGggPSBOdW1iZXIob2JqZWN0LndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uud2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmhlaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5oZWlnaHQgPSBOdW1iZXIob2JqZWN0LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5tdXRlZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5tdXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5tdXRlZCA9IEJvb2xlYW4ob2JqZWN0Lm11dGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubXV0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LmRpc2FibGVEdHggIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZGlzYWJsZUR0eCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5kaXNhYmxlRHR4ID0gQm9vbGVhbihvYmplY3QuZGlzYWJsZUR0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmRpc2FibGVEdHggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc291cmNlID0gbGl2ZWtpdF9tb2RlbHNfMS50cmFja1NvdXJjZUZyb21KU09OKG9iamVjdC5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5zb3VyY2UgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QubGF5ZXJzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmxheWVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iamVjdC5sYXllcnMpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxheWVycy5wdXNoKGxpdmVraXRfbW9kZWxzXzEuVmlkZW9MYXllci5mcm9tSlNPTihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jaWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmNpZCA9IG1lc3NhZ2UuY2lkKTtcbiAgICAgICAgbWVzc2FnZS5uYW1lICE9PSB1bmRlZmluZWQgJiYgKG9iai5uYW1lID0gbWVzc2FnZS5uYW1lKTtcbiAgICAgICAgbWVzc2FnZS50eXBlICE9PSB1bmRlZmluZWQgJiYgKG9iai50eXBlID0gbGl2ZWtpdF9tb2RlbHNfMS50cmFja1R5cGVUb0pTT04obWVzc2FnZS50eXBlKSk7XG4gICAgICAgIG1lc3NhZ2Uud2lkdGggIT09IHVuZGVmaW5lZCAmJiAob2JqLndpZHRoID0gbWVzc2FnZS53aWR0aCk7XG4gICAgICAgIG1lc3NhZ2UuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgKG9iai5oZWlnaHQgPSBtZXNzYWdlLmhlaWdodCk7XG4gICAgICAgIG1lc3NhZ2UubXV0ZWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLm11dGVkID0gbWVzc2FnZS5tdXRlZCk7XG4gICAgICAgIG1lc3NhZ2UuZGlzYWJsZUR0eCAhPT0gdW5kZWZpbmVkICYmIChvYmouZGlzYWJsZUR0eCA9IG1lc3NhZ2UuZGlzYWJsZUR0eCk7XG4gICAgICAgIG1lc3NhZ2Uuc291cmNlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc291cmNlID0gbGl2ZWtpdF9tb2RlbHNfMS50cmFja1NvdXJjZVRvSlNPTihtZXNzYWdlLnNvdXJjZSkpO1xuICAgICAgICBpZiAobWVzc2FnZS5sYXllcnMpIHtcbiAgICAgICAgICAgIG9iai5sYXllcnMgPSBtZXNzYWdlLmxheWVycy5tYXAoKGUpID0+IGUgPyBsaXZla2l0X21vZGVsc18xLlZpZGVvTGF5ZXIudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5sYXllcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlQWRkVHJhY2tSZXF1ZXN0KTtcbiAgICAgICAgbWVzc2FnZS5jaWQgPSAoX2EgPSBvYmplY3QuY2lkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLm5hbWUgPSAoX2IgPSBvYmplY3QubmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gKF9jID0gb2JqZWN0LnR5cGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDA7XG4gICAgICAgIG1lc3NhZ2Uud2lkdGggPSAoX2QgPSBvYmplY3Qud2lkdGgpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDA7XG4gICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gKF9lID0gb2JqZWN0LmhlaWdodCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMDtcbiAgICAgICAgbWVzc2FnZS5tdXRlZCA9IChfZiA9IG9iamVjdC5tdXRlZCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogZmFsc2U7XG4gICAgICAgIG1lc3NhZ2UuZGlzYWJsZUR0eCA9IChfZyA9IG9iamVjdC5kaXNhYmxlRHR4KSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5zb3VyY2UgPSAoX2ggPSBvYmplY3Quc291cmNlKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiAwO1xuICAgICAgICBtZXNzYWdlLmxheWVycyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LmxheWVycyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5sYXllcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QubGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5sYXllcnMucHVzaChsaXZla2l0X21vZGVsc18xLlZpZGVvTGF5ZXIuZnJvbVBhcnRpYWwoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuY29uc3QgYmFzZVRyaWNrbGVSZXF1ZXN0ID0geyBjYW5kaWRhdGVJbml0OiBcIlwiLCB0YXJnZXQ6IDAgfTtcbmV4cG9ydHMuVHJpY2tsZVJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5jYW5kaWRhdGVJbml0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5jYW5kaWRhdGVJbml0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50YXJnZXQgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmludDMyKG1lc3NhZ2UudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VUcmlja2xlUmVxdWVzdCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jYW5kaWRhdGVJbml0ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGFyZ2V0ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VUcmlja2xlUmVxdWVzdCk7XG4gICAgICAgIGlmIChvYmplY3QuY2FuZGlkYXRlSW5pdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jYW5kaWRhdGVJbml0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmNhbmRpZGF0ZUluaXQgPSBTdHJpbmcob2JqZWN0LmNhbmRpZGF0ZUluaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5jYW5kaWRhdGVJbml0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnRhcmdldCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50YXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudGFyZ2V0ID0gc2lnbmFsVGFyZ2V0RnJvbUpTT04ob2JqZWN0LnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnRhcmdldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jYW5kaWRhdGVJbml0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY2FuZGlkYXRlSW5pdCA9IG1lc3NhZ2UuY2FuZGlkYXRlSW5pdCk7XG4gICAgICAgIG1lc3NhZ2UudGFyZ2V0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudGFyZ2V0ID0gc2lnbmFsVGFyZ2V0VG9KU09OKG1lc3NhZ2UudGFyZ2V0KSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VUcmlja2xlUmVxdWVzdCk7XG4gICAgICAgIG1lc3NhZ2UuY2FuZGlkYXRlSW5pdCA9IChfYSA9IG9iamVjdC5jYW5kaWRhdGVJbml0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnRhcmdldCA9IChfYiA9IG9iamVjdC50YXJnZXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuY29uc3QgYmFzZU11dGVUcmFja1JlcXVlc3QgPSB7IHNpZDogXCJcIiwgbXV0ZWQ6IGZhbHNlIH07XG5leHBvcnRzLk11dGVUcmFja1JlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zaWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubXV0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmJvb2wobWVzc2FnZS5tdXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlTXV0ZVRyYWNrUmVxdWVzdCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tdXRlZCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VNdXRlVHJhY2tSZXF1ZXN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5zaWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2lkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNpZCA9IFN0cmluZyhvYmplY3Quc2lkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2lkID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Lm11dGVkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lm11dGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLm11dGVkID0gQm9vbGVhbihvYmplY3QubXV0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5tdXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuc2lkICE9PSB1bmRlZmluZWQgJiYgKG9iai5zaWQgPSBtZXNzYWdlLnNpZCk7XG4gICAgICAgIG1lc3NhZ2UubXV0ZWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLm11dGVkID0gbWVzc2FnZS5tdXRlZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VNdXRlVHJhY2tSZXF1ZXN0KTtcbiAgICAgICAgbWVzc2FnZS5zaWQgPSAoX2EgPSBvYmplY3Quc2lkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLm11dGVkID0gKF9iID0gb2JqZWN0Lm11dGVkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlSm9pblJlc3BvbnNlID0ge1xuICAgIHNlcnZlclZlcnNpb246IFwiXCIsXG4gICAgc3Vic2NyaWJlclByaW1hcnk6IGZhbHNlLFxuICAgIGFsdGVybmF0aXZlVXJsOiBcIlwiLFxufTtcbmV4cG9ydHMuSm9pblJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uucm9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsaXZla2l0X21vZGVsc18xLlJvb20uZW5jb2RlKG1lc3NhZ2Uucm9vbSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0aWNpcGFudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsaXZla2l0X21vZGVsc18xLlBhcnRpY2lwYW50SW5mby5lbmNvZGUobWVzc2FnZS5wYXJ0aWNpcGFudCwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5vdGhlclBhcnRpY2lwYW50cykge1xuICAgICAgICAgICAgbGl2ZWtpdF9tb2RlbHNfMS5QYXJ0aWNpcGFudEluZm8uZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VydmVyVmVyc2lvbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuc3RyaW5nKG1lc3NhZ2Uuc2VydmVyVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuaWNlU2VydmVycykge1xuICAgICAgICAgICAgZXhwb3J0cy5JQ0VTZXJ2ZXIuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3Vic2NyaWJlclByaW1hcnkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNDgpLmJvb2wobWVzc2FnZS5zdWJzY3JpYmVyUHJpbWFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWx0ZXJuYXRpdmVVcmwgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNTgpLnN0cmluZyhtZXNzYWdlLmFsdGVybmF0aXZlVXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VKb2luUmVzcG9uc2UpO1xuICAgICAgICBtZXNzYWdlLm90aGVyUGFydGljaXBhbnRzID0gW107XG4gICAgICAgIG1lc3NhZ2UuaWNlU2VydmVycyA9IFtdO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uucm9vbSA9IGxpdmVraXRfbW9kZWxzXzEuUm9vbS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnQgPSBsaXZla2l0X21vZGVsc18xLlBhcnRpY2lwYW50SW5mby5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3RoZXJQYXJ0aWNpcGFudHMucHVzaChsaXZla2l0X21vZGVsc18xLlBhcnRpY2lwYW50SW5mby5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlcnZlclZlcnNpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pY2VTZXJ2ZXJzLnB1c2goZXhwb3J0cy5JQ0VTZXJ2ZXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdWJzY3JpYmVyUHJpbWFyeSA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbHRlcm5hdGl2ZVVybCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZUpvaW5SZXNwb25zZSk7XG4gICAgICAgIG1lc3NhZ2Uub3RoZXJQYXJ0aWNpcGFudHMgPSBbXTtcbiAgICAgICAgbWVzc2FnZS5pY2VTZXJ2ZXJzID0gW107XG4gICAgICAgIGlmIChvYmplY3Qucm9vbSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yb29tICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnJvb20gPSBsaXZla2l0X21vZGVsc18xLlJvb20uZnJvbUpTT04ob2JqZWN0LnJvb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5yb29tID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QucGFydGljaXBhbnQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucGFydGljaXBhbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnQgPSBsaXZla2l0X21vZGVsc18xLlBhcnRpY2lwYW50SW5mby5mcm9tSlNPTihvYmplY3QucGFydGljaXBhbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Lm90aGVyUGFydGljaXBhbnRzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIG9iamVjdC5vdGhlclBhcnRpY2lwYW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iamVjdC5vdGhlclBhcnRpY2lwYW50cykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3RoZXJQYXJ0aWNpcGFudHMucHVzaChsaXZla2l0X21vZGVsc18xLlBhcnRpY2lwYW50SW5mby5mcm9tSlNPTihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zZXJ2ZXJWZXJzaW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNlcnZlclZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2VydmVyVmVyc2lvbiA9IFN0cmluZyhvYmplY3Quc2VydmVyVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNlcnZlclZlcnNpb24gPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QuaWNlU2VydmVycyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5pY2VTZXJ2ZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LmljZVNlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmljZVNlcnZlcnMucHVzaChleHBvcnRzLklDRVNlcnZlci5mcm9tSlNPTihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zdWJzY3JpYmVyUHJpbWFyeSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBvYmplY3Quc3Vic2NyaWJlclByaW1hcnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaWJlclByaW1hcnkgPSBCb29sZWFuKG9iamVjdC5zdWJzY3JpYmVyUHJpbWFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmliZXJQcmltYXJ5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5hbHRlcm5hdGl2ZVVybCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5hbHRlcm5hdGl2ZVVybCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5hbHRlcm5hdGl2ZVVybCA9IFN0cmluZyhvYmplY3QuYWx0ZXJuYXRpdmVVcmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5hbHRlcm5hdGl2ZVVybCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5yb29tICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucm9vbSA9IG1lc3NhZ2Uucm9vbSA/IGxpdmVraXRfbW9kZWxzXzEuUm9vbS50b0pTT04obWVzc2FnZS5yb29tKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXJ0aWNpcGFudCA9IG1lc3NhZ2UucGFydGljaXBhbnRcbiAgICAgICAgICAgICAgICA/IGxpdmVraXRfbW9kZWxzXzEuUGFydGljaXBhbnRJbmZvLnRvSlNPTihtZXNzYWdlLnBhcnRpY2lwYW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uub3RoZXJQYXJ0aWNpcGFudHMpIHtcbiAgICAgICAgICAgIG9iai5vdGhlclBhcnRpY2lwYW50cyA9IG1lc3NhZ2Uub3RoZXJQYXJ0aWNpcGFudHMubWFwKChlKSA9PiBlID8gbGl2ZWtpdF9tb2RlbHNfMS5QYXJ0aWNpcGFudEluZm8udG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5vdGhlclBhcnRpY2lwYW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2Uuc2VydmVyVmVyc2lvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNlcnZlclZlcnNpb24gPSBtZXNzYWdlLnNlcnZlclZlcnNpb24pO1xuICAgICAgICBpZiAobWVzc2FnZS5pY2VTZXJ2ZXJzKSB7XG4gICAgICAgICAgICBvYmouaWNlU2VydmVycyA9IG1lc3NhZ2UuaWNlU2VydmVycy5tYXAoKGUpID0+IGUgPyBleHBvcnRzLklDRVNlcnZlci50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmljZVNlcnZlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLnN1YnNjcmliZXJQcmltYXJ5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc3Vic2NyaWJlclByaW1hcnkgPSBtZXNzYWdlLnN1YnNjcmliZXJQcmltYXJ5KTtcbiAgICAgICAgbWVzc2FnZS5hbHRlcm5hdGl2ZVVybCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmFsdGVybmF0aXZlVXJsID0gbWVzc2FnZS5hbHRlcm5hdGl2ZVVybCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlSm9pblJlc3BvbnNlKTtcbiAgICAgICAgaWYgKG9iamVjdC5yb29tICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJvb20gIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uucm9vbSA9IGxpdmVraXRfbW9kZWxzXzEuUm9vbS5mcm9tUGFydGlhbChvYmplY3Qucm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnJvb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5wYXJ0aWNpcGFudCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYXJ0aWNpcGFudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudCA9IGxpdmVraXRfbW9kZWxzXzEuUGFydGljaXBhbnRJbmZvLmZyb21QYXJ0aWFsKG9iamVjdC5wYXJ0aWNpcGFudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2Uub3RoZXJQYXJ0aWNpcGFudHMgPSBbXTtcbiAgICAgICAgaWYgKG9iamVjdC5vdGhlclBhcnRpY2lwYW50cyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBvYmplY3Qub3RoZXJQYXJ0aWNpcGFudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3Qub3RoZXJQYXJ0aWNpcGFudHMpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm90aGVyUGFydGljaXBhbnRzLnB1c2gobGl2ZWtpdF9tb2RlbHNfMS5QYXJ0aWNpcGFudEluZm8uZnJvbVBhcnRpYWwoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2Uuc2VydmVyVmVyc2lvbiA9IChfYSA9IG9iamVjdC5zZXJ2ZXJWZXJzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmljZVNlcnZlcnMgPSBbXTtcbiAgICAgICAgaWYgKG9iamVjdC5pY2VTZXJ2ZXJzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmljZVNlcnZlcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QuaWNlU2VydmVycykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWNlU2VydmVycy5wdXNoKGV4cG9ydHMuSUNFU2VydmVyLmZyb21QYXJ0aWFsKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLnN1YnNjcmliZXJQcmltYXJ5ID0gKF9iID0gb2JqZWN0LnN1YnNjcmliZXJQcmltYXJ5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5hbHRlcm5hdGl2ZVVybCA9IChfYyA9IG9iamVjdC5hbHRlcm5hdGl2ZVVybCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlVHJhY2tQdWJsaXNoZWRSZXNwb25zZSA9IHsgY2lkOiBcIlwiIH07XG5leHBvcnRzLlRyYWNrUHVibGlzaGVkUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5jaWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGl2ZWtpdF9tb2RlbHNfMS5UcmFja0luZm8uZW5jb2RlKG1lc3NhZ2UudHJhY2ssIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlVHJhY2tQdWJsaXNoZWRSZXNwb25zZSk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFjayA9IGxpdmVraXRfbW9kZWxzXzEuVHJhY2tJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VUcmFja1B1Ymxpc2hlZFJlc3BvbnNlKTtcbiAgICAgICAgaWYgKG9iamVjdC5jaWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY2lkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmNpZCA9IFN0cmluZyhvYmplY3QuY2lkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuY2lkID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnRyYWNrICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnRyYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnRyYWNrID0gbGl2ZWtpdF9tb2RlbHNfMS5UcmFja0luZm8uZnJvbUpTT04ob2JqZWN0LnRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jaWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmNpZCA9IG1lc3NhZ2UuY2lkKTtcbiAgICAgICAgbWVzc2FnZS50cmFjayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRyYWNrID0gbWVzc2FnZS50cmFjayA/IGxpdmVraXRfbW9kZWxzXzEuVHJhY2tJbmZvLnRvSlNPTihtZXNzYWdlLnRyYWNrKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVRyYWNrUHVibGlzaGVkUmVzcG9uc2UpO1xuICAgICAgICBtZXNzYWdlLmNpZCA9IChfYSA9IG9iamVjdC5jaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIGlmIChvYmplY3QudHJhY2sgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudHJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHJhY2sgPSBsaXZla2l0X21vZGVsc18xLlRyYWNrSW5mby5mcm9tUGFydGlhbChvYmplY3QudHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS50cmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmNvbnN0IGJhc2VTZXNzaW9uRGVzY3JpcHRpb24gPSB7IHR5cGU6IFwiXCIsIHNkcDogXCJcIiB9O1xuZXhwb3J0cy5TZXNzaW9uRGVzY3JpcHRpb24gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zZHAgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnNkcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU2Vzc2lvbkRlc2NyaXB0aW9uKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZHAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTZXNzaW9uRGVzY3JpcHRpb24pO1xuICAgICAgICBpZiAob2JqZWN0LnR5cGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gU3RyaW5nKG9iamVjdC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zZHAgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2RwICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNkcCA9IFN0cmluZyhvYmplY3Quc2RwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2RwID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnR5cGUgIT09IHVuZGVmaW5lZCAmJiAob2JqLnR5cGUgPSBtZXNzYWdlLnR5cGUpO1xuICAgICAgICBtZXNzYWdlLnNkcCAhPT0gdW5kZWZpbmVkICYmIChvYmouc2RwID0gbWVzc2FnZS5zZHApO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU2Vzc2lvbkRlc2NyaXB0aW9uKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gKF9hID0gb2JqZWN0LnR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuc2RwID0gKF9iID0gb2JqZWN0LnNkcCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlUGFydGljaXBhbnRVcGRhdGUgPSB7fTtcbmV4cG9ydHMuUGFydGljaXBhbnRVcGRhdGUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5wYXJ0aWNpcGFudHMpIHtcbiAgICAgICAgICAgIGxpdmVraXRfbW9kZWxzXzEuUGFydGljaXBhbnRJbmZvLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVBhcnRpY2lwYW50VXBkYXRlKTtcbiAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50cy5wdXNoKGxpdmVraXRfbW9kZWxzXzEuUGFydGljaXBhbnRJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlUGFydGljaXBhbnRVcGRhdGUpO1xuICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50cyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LnBhcnRpY2lwYW50cyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYXJ0aWNpcGFudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QucGFydGljaXBhbnRzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudHMucHVzaChsaXZla2l0X21vZGVsc18xLlBhcnRpY2lwYW50SW5mby5mcm9tSlNPTihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydGljaXBhbnRzKSB7XG4gICAgICAgICAgICBvYmoucGFydGljaXBhbnRzID0gbWVzc2FnZS5wYXJ0aWNpcGFudHMubWFwKChlKSA9PiBlID8gbGl2ZWtpdF9tb2RlbHNfMS5QYXJ0aWNpcGFudEluZm8udG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5wYXJ0aWNpcGFudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlUGFydGljaXBhbnRVcGRhdGUpO1xuICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50cyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LnBhcnRpY2lwYW50cyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYXJ0aWNpcGFudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QucGFydGljaXBhbnRzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudHMucHVzaChsaXZla2l0X21vZGVsc18xLlBhcnRpY2lwYW50SW5mby5mcm9tUGFydGlhbChlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlVXBkYXRlU3Vic2NyaXB0aW9uID0geyB0cmFja1NpZHM6IFwiXCIsIHN1YnNjcmliZTogZmFsc2UgfTtcbmV4cG9ydHMuVXBkYXRlU3Vic2NyaXB0aW9uID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UudHJhY2tTaWRzKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcodik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3Vic2NyaWJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS5ib29sKG1lc3NhZ2Uuc3Vic2NyaWJlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5wYXJ0aWNpcGFudFRyYWNrcykge1xuICAgICAgICAgICAgbGl2ZWtpdF9tb2RlbHNfMS5QYXJ0aWNpcGFudFRyYWNrcy5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VVcGRhdGVTdWJzY3JpcHRpb24pO1xuICAgICAgICBtZXNzYWdlLnRyYWNrU2lkcyA9IFtdO1xuICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50VHJhY2tzID0gW107XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja1NpZHMucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaWJlID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50VHJhY2tzLnB1c2gobGl2ZWtpdF9tb2RlbHNfMS5QYXJ0aWNpcGFudFRyYWNrcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVVwZGF0ZVN1YnNjcmlwdGlvbik7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tTaWRzID0gW107XG4gICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRUcmFja3MgPSBbXTtcbiAgICAgICAgaWYgKG9iamVjdC50cmFja1NpZHMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudHJhY2tTaWRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LnRyYWNrU2lkcykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tTaWRzLnB1c2goU3RyaW5nKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnN1YnNjcmliZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zdWJzY3JpYmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaWJlID0gQm9vbGVhbihvYmplY3Quc3Vic2NyaWJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaWJlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5wYXJ0aWNpcGFudFRyYWNrcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBvYmplY3QucGFydGljaXBhbnRUcmFja3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QucGFydGljaXBhbnRUcmFja3MpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50VHJhY2tzLnB1c2gobGl2ZWtpdF9tb2RlbHNfMS5QYXJ0aWNpcGFudFRyYWNrcy5mcm9tSlNPTihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tTaWRzKSB7XG4gICAgICAgICAgICBvYmoudHJhY2tTaWRzID0gbWVzc2FnZS50cmFja1NpZHMubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai50cmFja1NpZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLnN1YnNjcmliZSAhPT0gdW5kZWZpbmVkICYmIChvYmouc3Vic2NyaWJlID0gbWVzc2FnZS5zdWJzY3JpYmUpO1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0aWNpcGFudFRyYWNrcykge1xuICAgICAgICAgICAgb2JqLnBhcnRpY2lwYW50VHJhY2tzID0gbWVzc2FnZS5wYXJ0aWNpcGFudFRyYWNrcy5tYXAoKGUpID0+IGUgPyBsaXZla2l0X21vZGVsc18xLlBhcnRpY2lwYW50VHJhY2tzLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucGFydGljaXBhbnRUcmFja3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VVcGRhdGVTdWJzY3JpcHRpb24pO1xuICAgICAgICBtZXNzYWdlLnRyYWNrU2lkcyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LnRyYWNrU2lkcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50cmFja1NpZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QudHJhY2tTaWRzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja1NpZHMucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLnN1YnNjcmliZSA9IChfYSA9IG9iamVjdC5zdWJzY3JpYmUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50VHJhY2tzID0gW107XG4gICAgICAgIGlmIChvYmplY3QucGFydGljaXBhbnRUcmFja3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgb2JqZWN0LnBhcnRpY2lwYW50VHJhY2tzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LnBhcnRpY2lwYW50VHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudFRyYWNrcy5wdXNoKGxpdmVraXRfbW9kZWxzXzEuUGFydGljaXBhbnRUcmFja3MuZnJvbVBhcnRpYWwoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuY29uc3QgYmFzZVVwZGF0ZVRyYWNrU2V0dGluZ3MgPSB7XG4gICAgdHJhY2tTaWRzOiBcIlwiLFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBxdWFsaXR5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbn07XG5leHBvcnRzLlVwZGF0ZVRyYWNrU2V0dGluZ3MgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS50cmFja1NpZHMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kaXNhYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkuYm9vbChtZXNzYWdlLmRpc2FibGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5xdWFsaXR5ICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS5pbnQzMihtZXNzYWdlLnF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQwKS51aW50MzIobWVzc2FnZS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQ4KS51aW50MzIobWVzc2FnZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVVwZGF0ZVRyYWNrU2V0dGluZ3MpO1xuICAgICAgICBtZXNzYWdlLnRyYWNrU2lkcyA9IFtdO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tTaWRzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpc2FibGVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnF1YWxpdHkgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLndpZHRoID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlVXBkYXRlVHJhY2tTZXR0aW5ncyk7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tTaWRzID0gW107XG4gICAgICAgIGlmIChvYmplY3QudHJhY2tTaWRzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnRyYWNrU2lkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iamVjdC50cmFja1NpZHMpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWNrU2lkcy5wdXNoKFN0cmluZyhlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5kaXNhYmxlZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5kaXNhYmxlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5kaXNhYmxlZCA9IEJvb2xlYW4ob2JqZWN0LmRpc2FibGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnF1YWxpdHkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucXVhbGl0eSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5xdWFsaXR5ID0gbGl2ZWtpdF9tb2RlbHNfMS52aWRlb1F1YWxpdHlGcm9tSlNPTihvYmplY3QucXVhbGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnF1YWxpdHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Qud2lkdGggIT09IHVuZGVmaW5lZCAmJiBvYmplY3Qud2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uud2lkdGggPSBOdW1iZXIob2JqZWN0LndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uud2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmhlaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5oZWlnaHQgPSBOdW1iZXIob2JqZWN0LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tTaWRzKSB7XG4gICAgICAgICAgICBvYmoudHJhY2tTaWRzID0gbWVzc2FnZS50cmFja1NpZHMubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai50cmFja1NpZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLmRpc2FibGVkICE9PSB1bmRlZmluZWQgJiYgKG9iai5kaXNhYmxlZCA9IG1lc3NhZ2UuZGlzYWJsZWQpO1xuICAgICAgICBtZXNzYWdlLnF1YWxpdHkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5xdWFsaXR5ID0gbGl2ZWtpdF9tb2RlbHNfMS52aWRlb1F1YWxpdHlUb0pTT04obWVzc2FnZS5xdWFsaXR5KSk7XG4gICAgICAgIG1lc3NhZ2Uud2lkdGggIT09IHVuZGVmaW5lZCAmJiAob2JqLndpZHRoID0gbWVzc2FnZS53aWR0aCk7XG4gICAgICAgIG1lc3NhZ2UuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgKG9iai5oZWlnaHQgPSBtZXNzYWdlLmhlaWdodCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVVwZGF0ZVRyYWNrU2V0dGluZ3MpO1xuICAgICAgICBtZXNzYWdlLnRyYWNrU2lkcyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LnRyYWNrU2lkcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50cmFja1NpZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QudHJhY2tTaWRzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja1NpZHMucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLmRpc2FibGVkID0gKF9hID0gb2JqZWN0LmRpc2FibGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5xdWFsaXR5ID0gKF9iID0gb2JqZWN0LnF1YWxpdHkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgICAgIG1lc3NhZ2Uud2lkdGggPSAoX2MgPSBvYmplY3Qud2lkdGgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDA7XG4gICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gKF9kID0gb2JqZWN0LmhlaWdodCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlTGVhdmVSZXF1ZXN0ID0geyBjYW5SZWNvbm5lY3Q6IGZhbHNlIH07XG5leHBvcnRzLkxlYXZlUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmNhblJlY29ubmVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5ib29sKG1lc3NhZ2UuY2FuUmVjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VMZWF2ZVJlcXVlc3QpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FuUmVjb25uZWN0ID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZUxlYXZlUmVxdWVzdCk7XG4gICAgICAgIGlmIChvYmplY3QuY2FuUmVjb25uZWN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNhblJlY29ubmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5jYW5SZWNvbm5lY3QgPSBCb29sZWFuKG9iamVjdC5jYW5SZWNvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5jYW5SZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmNhblJlY29ubmVjdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNhblJlY29ubmVjdCA9IG1lc3NhZ2UuY2FuUmVjb25uZWN0KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlTGVhdmVSZXF1ZXN0KTtcbiAgICAgICAgbWVzc2FnZS5jYW5SZWNvbm5lY3QgPSAoX2EgPSBvYmplY3QuY2FuUmVjb25uZWN0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlVXBkYXRlVmlkZW9MYXllcnMgPSB7IHRyYWNrU2lkOiBcIlwiIH07XG5leHBvcnRzLlVwZGF0ZVZpZGVvTGF5ZXJzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tTaWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnRyYWNrU2lkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5sYXllcnMpIHtcbiAgICAgICAgICAgIGxpdmVraXRfbW9kZWxzXzEuVmlkZW9MYXllci5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VVcGRhdGVWaWRlb0xheWVycyk7XG4gICAgICAgIG1lc3NhZ2UubGF5ZXJzID0gW107XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja1NpZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxheWVycy5wdXNoKGxpdmVraXRfbW9kZWxzXzEuVmlkZW9MYXllci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVVwZGF0ZVZpZGVvTGF5ZXJzKTtcbiAgICAgICAgbWVzc2FnZS5sYXllcnMgPSBbXTtcbiAgICAgICAgaWYgKG9iamVjdC50cmFja1NpZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50cmFja1NpZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS50cmFja1NpZCA9IFN0cmluZyhvYmplY3QudHJhY2tTaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS50cmFja1NpZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5sYXllcnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubGF5ZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LmxheWVycykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGF5ZXJzLnB1c2gobGl2ZWtpdF9tb2RlbHNfMS5WaWRlb0xheWVyLmZyb21KU09OKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnRyYWNrU2lkICE9PSB1bmRlZmluZWQgJiYgKG9iai50cmFja1NpZCA9IG1lc3NhZ2UudHJhY2tTaWQpO1xuICAgICAgICBpZiAobWVzc2FnZS5sYXllcnMpIHtcbiAgICAgICAgICAgIG9iai5sYXllcnMgPSBtZXNzYWdlLmxheWVycy5tYXAoKGUpID0+IGUgPyBsaXZla2l0X21vZGVsc18xLlZpZGVvTGF5ZXIudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5sYXllcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VVcGRhdGVWaWRlb0xheWVycyk7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tTaWQgPSAoX2EgPSBvYmplY3QudHJhY2tTaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UubGF5ZXJzID0gW107XG4gICAgICAgIGlmIChvYmplY3QubGF5ZXJzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmxheWVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iamVjdC5sYXllcnMpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxheWVycy5wdXNoKGxpdmVraXRfbW9kZWxzXzEuVmlkZW9MYXllci5mcm9tUGFydGlhbChlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlSUNFU2VydmVyID0geyB1cmxzOiBcIlwiLCB1c2VybmFtZTogXCJcIiwgY3JlZGVudGlhbDogXCJcIiB9O1xuZXhwb3J0cy5JQ0VTZXJ2ZXIgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS51cmxzKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcodik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudXNlcm5hbWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnVzZXJuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jcmVkZW50aWFsICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5jcmVkZW50aWFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VJQ0VTZXJ2ZXIpO1xuICAgICAgICBtZXNzYWdlLnVybHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVybHMucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVkZW50aWFsID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlSUNFU2VydmVyKTtcbiAgICAgICAgbWVzc2FnZS51cmxzID0gW107XG4gICAgICAgIGlmIChvYmplY3QudXJscyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC51cmxzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LnVybHMpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnVybHMucHVzaChTdHJpbmcoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QudXNlcm5hbWUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudXNlcm5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudXNlcm5hbWUgPSBTdHJpbmcob2JqZWN0LnVzZXJuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudXNlcm5hbWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QuY3JlZGVudGlhbCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jcmVkZW50aWFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmNyZWRlbnRpYWwgPSBTdHJpbmcob2JqZWN0LmNyZWRlbnRpYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5jcmVkZW50aWFsID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS51cmxzKSB7XG4gICAgICAgICAgICBvYmoudXJscyA9IG1lc3NhZ2UudXJscy5tYXAoKGUpID0+IGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnVybHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLnVzZXJuYW1lICE9PSB1bmRlZmluZWQgJiYgKG9iai51c2VybmFtZSA9IG1lc3NhZ2UudXNlcm5hbWUpO1xuICAgICAgICBtZXNzYWdlLmNyZWRlbnRpYWwgIT09IHVuZGVmaW5lZCAmJiAob2JqLmNyZWRlbnRpYWwgPSBtZXNzYWdlLmNyZWRlbnRpYWwpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlSUNFU2VydmVyKTtcbiAgICAgICAgbWVzc2FnZS51cmxzID0gW107XG4gICAgICAgIGlmIChvYmplY3QudXJscyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC51cmxzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LnVybHMpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnVybHMucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLnVzZXJuYW1lID0gKF9hID0gb2JqZWN0LnVzZXJuYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNyZWRlbnRpYWwgPSAoX2IgPSBvYmplY3QuY3JlZGVudGlhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlU3BlYWtlcnNDaGFuZ2VkID0ge307XG5leHBvcnRzLlNwZWFrZXJzQ2hhbmdlZCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnNwZWFrZXJzKSB7XG4gICAgICAgICAgICBsaXZla2l0X21vZGVsc18xLlNwZWFrZXJJbmZvLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVNwZWFrZXJzQ2hhbmdlZCk7XG4gICAgICAgIG1lc3NhZ2Uuc3BlYWtlcnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNwZWFrZXJzLnB1c2gobGl2ZWtpdF9tb2RlbHNfMS5TcGVha2VySW5mby5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVNwZWFrZXJzQ2hhbmdlZCk7XG4gICAgICAgIG1lc3NhZ2Uuc3BlYWtlcnMgPSBbXTtcbiAgICAgICAgaWYgKG9iamVjdC5zcGVha2VycyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zcGVha2VycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iamVjdC5zcGVha2Vycykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BlYWtlcnMucHVzaChsaXZla2l0X21vZGVsc18xLlNwZWFrZXJJbmZvLmZyb21KU09OKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5zcGVha2Vycykge1xuICAgICAgICAgICAgb2JqLnNwZWFrZXJzID0gbWVzc2FnZS5zcGVha2Vycy5tYXAoKGUpID0+IGUgPyBsaXZla2l0X21vZGVsc18xLlNwZWFrZXJJbmZvLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouc3BlYWtlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU3BlYWtlcnNDaGFuZ2VkKTtcbiAgICAgICAgbWVzc2FnZS5zcGVha2VycyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LnNwZWFrZXJzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNwZWFrZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LnNwZWFrZXJzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zcGVha2Vycy5wdXNoKGxpdmVraXRfbW9kZWxzXzEuU3BlYWtlckluZm8uZnJvbVBhcnRpYWwoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuY29uc3QgYmFzZVJvb21VcGRhdGUgPSB7fTtcbmV4cG9ydHMuUm9vbVVwZGF0ZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnJvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGl2ZWtpdF9tb2RlbHNfMS5Sb29tLmVuY29kZShtZXNzYWdlLnJvb20sIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlUm9vbVVwZGF0ZSk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yb29tID0gbGl2ZWtpdF9tb2RlbHNfMS5Sb29tLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VSb29tVXBkYXRlKTtcbiAgICAgICAgaWYgKG9iamVjdC5yb29tICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJvb20gIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uucm9vbSA9IGxpdmVraXRfbW9kZWxzXzEuUm9vbS5mcm9tSlNPTihvYmplY3Qucm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnJvb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5yb29tICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucm9vbSA9IG1lc3NhZ2Uucm9vbSA/IGxpdmVraXRfbW9kZWxzXzEuUm9vbS50b0pTT04obWVzc2FnZS5yb29tKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VSb29tVXBkYXRlKTtcbiAgICAgICAgaWYgKG9iamVjdC5yb29tICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJvb20gIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uucm9vbSA9IGxpdmVraXRfbW9kZWxzXzEuUm9vbS5mcm9tUGFydGlhbChvYmplY3Qucm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnJvb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlQ29ubmVjdGlvblF1YWxpdHlJbmZvID0ge1xuICAgIHBhcnRpY2lwYW50U2lkOiBcIlwiLFxuICAgIHF1YWxpdHk6IDAsXG4gICAgc2NvcmU6IDAsXG59O1xuZXhwb3J0cy5Db25uZWN0aW9uUXVhbGl0eUluZm8gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0aWNpcGFudFNpZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UucGFydGljaXBhbnRTaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnF1YWxpdHkgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmludDMyKG1lc3NhZ2UucXVhbGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2NvcmUgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjkpLmZsb2F0KG1lc3NhZ2Uuc2NvcmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZUNvbm5lY3Rpb25RdWFsaXR5SW5mbyk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudFNpZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnF1YWxpdHkgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNjb3JlID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VDb25uZWN0aW9uUXVhbGl0eUluZm8pO1xuICAgICAgICBpZiAob2JqZWN0LnBhcnRpY2lwYW50U2lkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBhcnRpY2lwYW50U2lkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50U2lkID0gU3RyaW5nKG9iamVjdC5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50U2lkID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnF1YWxpdHkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucXVhbGl0eSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5xdWFsaXR5ID0gbGl2ZWtpdF9tb2RlbHNfMS5jb25uZWN0aW9uUXVhbGl0eUZyb21KU09OKG9iamVjdC5xdWFsaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UucXVhbGl0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zY29yZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zY29yZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5zY29yZSA9IE51bWJlcihvYmplY3Quc2NvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5zY29yZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudFNpZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBhcnRpY2lwYW50U2lkID0gbWVzc2FnZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICAgIG1lc3NhZ2UucXVhbGl0eSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnF1YWxpdHkgPSBsaXZla2l0X21vZGVsc18xLmNvbm5lY3Rpb25RdWFsaXR5VG9KU09OKG1lc3NhZ2UucXVhbGl0eSkpO1xuICAgICAgICBtZXNzYWdlLnNjb3JlICE9PSB1bmRlZmluZWQgJiYgKG9iai5zY29yZSA9IG1lc3NhZ2Uuc2NvcmUpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZUNvbm5lY3Rpb25RdWFsaXR5SW5mbyk7XG4gICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRTaWQgPSAoX2EgPSBvYmplY3QucGFydGljaXBhbnRTaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UucXVhbGl0eSA9IChfYiA9IG9iamVjdC5xdWFsaXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICBtZXNzYWdlLnNjb3JlID0gKF9jID0gb2JqZWN0LnNjb3JlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmNvbnN0IGJhc2VDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSA9IHt9O1xuZXhwb3J0cy5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnVwZGF0ZXMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuQ29ubmVjdGlvblF1YWxpdHlJbmZvLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZUNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlKTtcbiAgICAgICAgbWVzc2FnZS51cGRhdGVzID0gW107XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51cGRhdGVzLnB1c2goZXhwb3J0cy5Db25uZWN0aW9uUXVhbGl0eUluZm8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSk7XG4gICAgICAgIG1lc3NhZ2UudXBkYXRlcyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LnVwZGF0ZXMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudXBkYXRlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iamVjdC51cGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS51cGRhdGVzLnB1c2goZXhwb3J0cy5Db25uZWN0aW9uUXVhbGl0eUluZm8uZnJvbUpTT04oZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnVwZGF0ZXMpIHtcbiAgICAgICAgICAgIG9iai51cGRhdGVzID0gbWVzc2FnZS51cGRhdGVzLm1hcCgoZSkgPT4gZSA/IGV4cG9ydHMuQ29ubmVjdGlvblF1YWxpdHlJbmZvLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoudXBkYXRlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSk7XG4gICAgICAgIG1lc3NhZ2UudXBkYXRlcyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LnVwZGF0ZXMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudXBkYXRlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iamVjdC51cGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS51cGRhdGVzLnB1c2goZXhwb3J0cy5Db25uZWN0aW9uUXVhbGl0eUluZm8uZnJvbVBhcnRpYWwoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuY29uc3QgYmFzZVN0cmVhbVN0YXRlSW5mbyA9IHtcbiAgICBwYXJ0aWNpcGFudFNpZDogXCJcIixcbiAgICB0cmFja1NpZDogXCJcIixcbiAgICBzdGF0ZTogMCxcbn07XG5leHBvcnRzLlN0cmVhbVN0YXRlSW5mbyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRpY2lwYW50U2lkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tTaWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnRyYWNrU2lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zdGF0ZSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkuaW50MzIobWVzc2FnZS5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU3RyZWFtU3RhdGVJbmZvKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50U2lkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tTaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdGF0ZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU3RyZWFtU3RhdGVJbmZvKTtcbiAgICAgICAgaWYgKG9iamVjdC5wYXJ0aWNpcGFudFNpZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYXJ0aWNpcGFudFNpZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudFNpZCA9IFN0cmluZyhvYmplY3QucGFydGljaXBhbnRTaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC50cmFja1NpZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50cmFja1NpZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS50cmFja1NpZCA9IFN0cmluZyhvYmplY3QudHJhY2tTaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS50cmFja1NpZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5zdGF0ZSA9IHN0cmVhbVN0YXRlRnJvbUpTT04ob2JqZWN0LnN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3RhdGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRTaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXJ0aWNpcGFudFNpZCA9IG1lc3NhZ2UucGFydGljaXBhbnRTaWQpO1xuICAgICAgICBtZXNzYWdlLnRyYWNrU2lkICE9PSB1bmRlZmluZWQgJiYgKG9iai50cmFja1NpZCA9IG1lc3NhZ2UudHJhY2tTaWQpO1xuICAgICAgICBtZXNzYWdlLnN0YXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc3RhdGUgPSBzdHJlYW1TdGF0ZVRvSlNPTihtZXNzYWdlLnN0YXRlKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU3RyZWFtU3RhdGVJbmZvKTtcbiAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudFNpZCA9IChfYSA9IG9iamVjdC5wYXJ0aWNpcGFudFNpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS50cmFja1NpZCA9IChfYiA9IG9iamVjdC50cmFja1NpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zdGF0ZSA9IChfYyA9IG9iamVjdC5zdGF0ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlU3RyZWFtU3RhdGVVcGRhdGUgPSB7fTtcbmV4cG9ydHMuU3RyZWFtU3RhdGVVcGRhdGUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5zdHJlYW1TdGF0ZXMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuU3RyZWFtU3RhdGVJbmZvLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVN0cmVhbVN0YXRlVXBkYXRlKTtcbiAgICAgICAgbWVzc2FnZS5zdHJlYW1TdGF0ZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmVhbVN0YXRlcy5wdXNoKGV4cG9ydHMuU3RyZWFtU3RhdGVJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU3RyZWFtU3RhdGVVcGRhdGUpO1xuICAgICAgICBtZXNzYWdlLnN0cmVhbVN0YXRlcyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LnN0cmVhbVN0YXRlcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zdHJlYW1TdGF0ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3Quc3RyZWFtU3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJlYW1TdGF0ZXMucHVzaChleHBvcnRzLlN0cmVhbVN0YXRlSW5mby5mcm9tSlNPTihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyZWFtU3RhdGVzKSB7XG4gICAgICAgICAgICBvYmouc3RyZWFtU3RhdGVzID0gbWVzc2FnZS5zdHJlYW1TdGF0ZXMubWFwKChlKSA9PiBlID8gZXhwb3J0cy5TdHJlYW1TdGF0ZUluZm8udG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5zdHJlYW1TdGF0ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU3RyZWFtU3RhdGVVcGRhdGUpO1xuICAgICAgICBtZXNzYWdlLnN0cmVhbVN0YXRlcyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LnN0cmVhbVN0YXRlcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zdHJlYW1TdGF0ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3Quc3RyZWFtU3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJlYW1TdGF0ZXMucHVzaChleHBvcnRzLlN0cmVhbVN0YXRlSW5mby5mcm9tUGFydGlhbChlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlU3Vic2NyaWJlZFF1YWxpdHkgPSB7IHF1YWxpdHk6IDAsIGVuYWJsZWQ6IGZhbHNlIH07XG5leHBvcnRzLlN1YnNjcmliZWRRdWFsaXR5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucXVhbGl0eSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQzMihtZXNzYWdlLnF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmJvb2wobWVzc2FnZS5lbmFibGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTdWJzY3JpYmVkUXVhbGl0eSk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFsaXR5ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbmFibGVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVN1YnNjcmliZWRRdWFsaXR5KTtcbiAgICAgICAgaWYgKG9iamVjdC5xdWFsaXR5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnF1YWxpdHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UucXVhbGl0eSA9IGxpdmVraXRfbW9kZWxzXzEudmlkZW9RdWFsaXR5RnJvbUpTT04ob2JqZWN0LnF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5xdWFsaXR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LmVuYWJsZWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZW5hYmxlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5lbmFibGVkID0gQm9vbGVhbihvYmplY3QuZW5hYmxlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnF1YWxpdHkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5xdWFsaXR5ID0gbGl2ZWtpdF9tb2RlbHNfMS52aWRlb1F1YWxpdHlUb0pTT04obWVzc2FnZS5xdWFsaXR5KSk7XG4gICAgICAgIG1lc3NhZ2UuZW5hYmxlZCAhPT0gdW5kZWZpbmVkICYmIChvYmouZW5hYmxlZCA9IG1lc3NhZ2UuZW5hYmxlZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTdWJzY3JpYmVkUXVhbGl0eSk7XG4gICAgICAgIG1lc3NhZ2UucXVhbGl0eSA9IChfYSA9IG9iamVjdC5xdWFsaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBtZXNzYWdlLmVuYWJsZWQgPSAoX2IgPSBvYmplY3QuZW5hYmxlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuY29uc3QgYmFzZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0geyB0cmFja1NpZDogXCJcIiB9O1xuZXhwb3J0cy5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRyYWNrU2lkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS50cmFja1NpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2Uuc3Vic2NyaWJlZFF1YWxpdGllcykge1xuICAgICAgICAgICAgZXhwb3J0cy5TdWJzY3JpYmVkUXVhbGl0eS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSk7XG4gICAgICAgIG1lc3NhZ2Uuc3Vic2NyaWJlZFF1YWxpdGllcyA9IFtdO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tTaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdWJzY3JpYmVkUXVhbGl0aWVzLnB1c2goZXhwb3J0cy5TdWJzY3JpYmVkUXVhbGl0eS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKTtcbiAgICAgICAgbWVzc2FnZS5zdWJzY3JpYmVkUXVhbGl0aWVzID0gW107XG4gICAgICAgIGlmIChvYmplY3QudHJhY2tTaWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudHJhY2tTaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tTaWQgPSBTdHJpbmcob2JqZWN0LnRyYWNrU2lkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tTaWQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Quc3Vic2NyaWJlZFF1YWxpdGllcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBvYmplY3Quc3Vic2NyaWJlZFF1YWxpdGllcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iamVjdC5zdWJzY3JpYmVkUXVhbGl0aWVzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zdWJzY3JpYmVkUXVhbGl0aWVzLnB1c2goZXhwb3J0cy5TdWJzY3JpYmVkUXVhbGl0eS5mcm9tSlNPTihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS50cmFja1NpZCAhPT0gdW5kZWZpbmVkICYmIChvYmoudHJhY2tTaWQgPSBtZXNzYWdlLnRyYWNrU2lkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3Vic2NyaWJlZFF1YWxpdGllcykge1xuICAgICAgICAgICAgb2JqLnN1YnNjcmliZWRRdWFsaXRpZXMgPSBtZXNzYWdlLnN1YnNjcmliZWRRdWFsaXRpZXMubWFwKChlKSA9PiBlID8gZXhwb3J0cy5TdWJzY3JpYmVkUXVhbGl0eS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnN1YnNjcmliZWRRdWFsaXRpZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSk7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tTaWQgPSAoX2EgPSBvYmplY3QudHJhY2tTaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuc3Vic2NyaWJlZFF1YWxpdGllcyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LnN1YnNjcmliZWRRdWFsaXRpZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgb2JqZWN0LnN1YnNjcmliZWRRdWFsaXRpZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3Quc3Vic2NyaWJlZFF1YWxpdGllcykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaWJlZFF1YWxpdGllcy5wdXNoKGV4cG9ydHMuU3Vic2NyaWJlZFF1YWxpdHkuZnJvbVBhcnRpYWwoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuY29uc3QgYmFzZVRyYWNrUGVybWlzc2lvbiA9IHtcbiAgICBwYXJ0aWNpcGFudFNpZDogXCJcIixcbiAgICBhbGxUcmFja3M6IGZhbHNlLFxuICAgIHRyYWNrU2lkczogXCJcIixcbn07XG5leHBvcnRzLlRyYWNrUGVybWlzc2lvbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRpY2lwYW50U2lkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWxsVHJhY2tzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS5ib29sKG1lc3NhZ2UuYWxsVHJhY2tzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS50cmFja1NpZHMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VUcmFja1Blcm1pc3Npb24pO1xuICAgICAgICBtZXNzYWdlLnRyYWNrU2lkcyA9IFtdO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRTaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbGxUcmFja3MgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tTaWRzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVRyYWNrUGVybWlzc2lvbik7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tTaWRzID0gW107XG4gICAgICAgIGlmIChvYmplY3QucGFydGljaXBhbnRTaWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucGFydGljaXBhbnRTaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRTaWQgPSBTdHJpbmcob2JqZWN0LnBhcnRpY2lwYW50U2lkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRTaWQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QuYWxsVHJhY2tzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmFsbFRyYWNrcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5hbGxUcmFja3MgPSBCb29sZWFuKG9iamVjdC5hbGxUcmFja3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5hbGxUcmFja3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnRyYWNrU2lkcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50cmFja1NpZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QudHJhY2tTaWRzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja1NpZHMucHVzaChTdHJpbmcoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRTaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXJ0aWNpcGFudFNpZCA9IG1lc3NhZ2UucGFydGljaXBhbnRTaWQpO1xuICAgICAgICBtZXNzYWdlLmFsbFRyYWNrcyAhPT0gdW5kZWZpbmVkICYmIChvYmouYWxsVHJhY2tzID0gbWVzc2FnZS5hbGxUcmFja3MpO1xuICAgICAgICBpZiAobWVzc2FnZS50cmFja1NpZHMpIHtcbiAgICAgICAgICAgIG9iai50cmFja1NpZHMgPSBtZXNzYWdlLnRyYWNrU2lkcy5tYXAoKGUpID0+IGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnRyYWNrU2lkcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VUcmFja1Blcm1pc3Npb24pO1xuICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50U2lkID0gKF9hID0gb2JqZWN0LnBhcnRpY2lwYW50U2lkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmFsbFRyYWNrcyA9IChfYiA9IG9iamVjdC5hbGxUcmFja3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLnRyYWNrU2lkcyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LnRyYWNrU2lkcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50cmFja1NpZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QudHJhY2tTaWRzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja1NpZHMucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmNvbnN0IGJhc2VTdWJzY3JpcHRpb25QZXJtaXNzaW9uID0geyBhbGxQYXJ0aWNpcGFudHM6IGZhbHNlIH07XG5leHBvcnRzLlN1YnNjcmlwdGlvblBlcm1pc3Npb24gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hbGxQYXJ0aWNpcGFudHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkuYm9vbChtZXNzYWdlLmFsbFBhcnRpY2lwYW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UudHJhY2tQZXJtaXNzaW9ucykge1xuICAgICAgICAgICAgZXhwb3J0cy5UcmFja1Blcm1pc3Npb24uZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU3Vic2NyaXB0aW9uUGVybWlzc2lvbik7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tQZXJtaXNzaW9ucyA9IFtdO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWxsUGFydGljaXBhbnRzID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWNrUGVybWlzc2lvbnMucHVzaChleHBvcnRzLlRyYWNrUGVybWlzc2lvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZVN1YnNjcmlwdGlvblBlcm1pc3Npb24pO1xuICAgICAgICBtZXNzYWdlLnRyYWNrUGVybWlzc2lvbnMgPSBbXTtcbiAgICAgICAgaWYgKG9iamVjdC5hbGxQYXJ0aWNpcGFudHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgb2JqZWN0LmFsbFBhcnRpY2lwYW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5hbGxQYXJ0aWNpcGFudHMgPSBCb29sZWFuKG9iamVjdC5hbGxQYXJ0aWNpcGFudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5hbGxQYXJ0aWNpcGFudHMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnRyYWNrUGVybWlzc2lvbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgb2JqZWN0LnRyYWNrUGVybWlzc2lvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QudHJhY2tQZXJtaXNzaW9ucykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tQZXJtaXNzaW9ucy5wdXNoKGV4cG9ydHMuVHJhY2tQZXJtaXNzaW9uLmZyb21KU09OKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmFsbFBhcnRpY2lwYW50cyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmFsbFBhcnRpY2lwYW50cyA9IG1lc3NhZ2UuYWxsUGFydGljaXBhbnRzKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tQZXJtaXNzaW9ucykge1xuICAgICAgICAgICAgb2JqLnRyYWNrUGVybWlzc2lvbnMgPSBtZXNzYWdlLnRyYWNrUGVybWlzc2lvbnMubWFwKChlKSA9PiBlID8gZXhwb3J0cy5UcmFja1Blcm1pc3Npb24udG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai50cmFja1Blcm1pc3Npb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU3Vic2NyaXB0aW9uUGVybWlzc2lvbik7XG4gICAgICAgIG1lc3NhZ2UuYWxsUGFydGljaXBhbnRzID0gKF9hID0gb2JqZWN0LmFsbFBhcnRpY2lwYW50cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tQZXJtaXNzaW9ucyA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0LnRyYWNrUGVybWlzc2lvbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgb2JqZWN0LnRyYWNrUGVybWlzc2lvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QudHJhY2tQZXJtaXNzaW9ucykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tQZXJtaXNzaW9ucy5wdXNoKGV4cG9ydHMuVHJhY2tQZXJtaXNzaW9uLmZyb21QYXJ0aWFsKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmNvbnN0IGJhc2VTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0ge1xuICAgIHBhcnRpY2lwYW50U2lkOiBcIlwiLFxuICAgIHRyYWNrU2lkOiBcIlwiLFxuICAgIGFsbG93ZWQ6IGZhbHNlLFxufTtcbmV4cG9ydHMuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRpY2lwYW50U2lkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tTaWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnRyYWNrU2lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5hbGxvd2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS5ib29sKG1lc3NhZ2UuYWxsb3dlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudFNpZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWNrU2lkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWxsb3dlZCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKTtcbiAgICAgICAgaWYgKG9iamVjdC5wYXJ0aWNpcGFudFNpZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYXJ0aWNpcGFudFNpZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudFNpZCA9IFN0cmluZyhvYmplY3QucGFydGljaXBhbnRTaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC50cmFja1NpZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50cmFja1NpZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS50cmFja1NpZCA9IFN0cmluZyhvYmplY3QudHJhY2tTaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS50cmFja1NpZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5hbGxvd2VkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmFsbG93ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYWxsb3dlZCA9IEJvb2xlYW4ob2JqZWN0LmFsbG93ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5hbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudFNpZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBhcnRpY2lwYW50U2lkID0gbWVzc2FnZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tTaWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRyYWNrU2lkID0gbWVzc2FnZS50cmFja1NpZCk7XG4gICAgICAgIG1lc3NhZ2UuYWxsb3dlZCAhPT0gdW5kZWZpbmVkICYmIChvYmouYWxsb3dlZCA9IG1lc3NhZ2UuYWxsb3dlZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSk7XG4gICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRTaWQgPSAoX2EgPSBvYmplY3QucGFydGljaXBhbnRTaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tTaWQgPSAoX2IgPSBvYmplY3QudHJhY2tTaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuYWxsb3dlZCA9IChfYyA9IG9iamVjdC5hbGxvd2VkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlU3luY1N0YXRlID0ge307XG5leHBvcnRzLlN5bmNTdGF0ZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmFuc3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlNlc3Npb25EZXNjcmlwdGlvbi5lbmNvZGUobWVzc2FnZS5hbnN3ZXIsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3Vic2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVXBkYXRlU3Vic2NyaXB0aW9uLmVuY29kZShtZXNzYWdlLnN1YnNjcmlwdGlvbiwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5wdWJsaXNoVHJhY2tzKSB7XG4gICAgICAgICAgICBleHBvcnRzLlRyYWNrUHVibGlzaGVkUmVzcG9uc2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlU3luY1N0YXRlKTtcbiAgICAgICAgbWVzc2FnZS5wdWJsaXNoVHJhY2tzID0gW107XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbnN3ZXIgPSBleHBvcnRzLlNlc3Npb25EZXNjcmlwdGlvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaXB0aW9uID0gZXhwb3J0cy5VcGRhdGVTdWJzY3JpcHRpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnB1Ymxpc2hUcmFja3MucHVzaChleHBvcnRzLlRyYWNrUHVibGlzaGVkUmVzcG9uc2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTeW5jU3RhdGUpO1xuICAgICAgICBtZXNzYWdlLnB1Ymxpc2hUcmFja3MgPSBbXTtcbiAgICAgICAgaWYgKG9iamVjdC5hbnN3ZXIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYW5zd2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmFuc3dlciA9IGV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uLmZyb21KU09OKG9iamVjdC5hbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5hbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zdWJzY3JpcHRpb24gIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc3Vic2NyaXB0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmlwdGlvbiA9IGV4cG9ydHMuVXBkYXRlU3Vic2NyaXB0aW9uLmZyb21KU09OKG9iamVjdC5zdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5zdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5wdWJsaXNoVHJhY2tzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnB1Ymxpc2hUcmFja3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QucHVibGlzaFRyYWNrcykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHVibGlzaFRyYWNrcy5wdXNoKGV4cG9ydHMuVHJhY2tQdWJsaXNoZWRSZXNwb25zZS5mcm9tSlNPTihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5hbnN3ZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hbnN3ZXIgPSBtZXNzYWdlLmFuc3dlclxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TZXNzaW9uRGVzY3JpcHRpb24udG9KU09OKG1lc3NhZ2UuYW5zd2VyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5zdWJzY3JpcHRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zdWJzY3JpcHRpb24gPSBtZXNzYWdlLnN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5VcGRhdGVTdWJzY3JpcHRpb24udG9KU09OKG1lc3NhZ2Uuc3Vic2NyaXB0aW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucHVibGlzaFRyYWNrcykge1xuICAgICAgICAgICAgb2JqLnB1Ymxpc2hUcmFja3MgPSBtZXNzYWdlLnB1Ymxpc2hUcmFja3MubWFwKChlKSA9PiBlID8gZXhwb3J0cy5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucHVibGlzaFRyYWNrcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTeW5jU3RhdGUpO1xuICAgICAgICBpZiAob2JqZWN0LmFuc3dlciAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5hbnN3ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYW5zd2VyID0gZXhwb3J0cy5TZXNzaW9uRGVzY3JpcHRpb24uZnJvbVBhcnRpYWwob2JqZWN0LmFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmFuc3dlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnN1YnNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zdWJzY3JpcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaXB0aW9uID0gZXhwb3J0cy5VcGRhdGVTdWJzY3JpcHRpb24uZnJvbVBhcnRpYWwob2JqZWN0LnN1YnNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLnB1Ymxpc2hUcmFja3MgPSBbXTtcbiAgICAgICAgaWYgKG9iamVjdC5wdWJsaXNoVHJhY2tzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnB1Ymxpc2hUcmFja3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QucHVibGlzaFRyYWNrcykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHVibGlzaFRyYWNrcy5wdXNoKGV4cG9ydHMuVHJhY2tQdWJsaXNoZWRSZXNwb25zZS5mcm9tUGFydGlhbChlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlU2ltdWxhdGVTY2VuYXJpbyA9IHt9O1xuZXhwb3J0cy5TaW11bGF0ZVNjZW5hcmlvID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3BlYWtlclVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2Uuc3BlYWtlclVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uubm9kZUZhaWx1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikuYm9vbChtZXNzYWdlLm5vZGVGYWlsdXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5taWdyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkuYm9vbChtZXNzYWdlLm1pZ3JhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VydmVyTGVhdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzMikuYm9vbChtZXNzYWdlLnNlcnZlckxlYXZlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTaW11bGF0ZVNjZW5hcmlvKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNwZWFrZXJVcGRhdGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5vZGVGYWlsdXJlID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1pZ3JhdGlvbiA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXJ2ZXJMZWF2ZSA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTaW11bGF0ZVNjZW5hcmlvKTtcbiAgICAgICAgaWYgKG9iamVjdC5zcGVha2VyVXBkYXRlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNwZWFrZXJVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3BlYWtlclVwZGF0ZSA9IE51bWJlcihvYmplY3Quc3BlYWtlclVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNwZWFrZXJVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5ub2RlRmFpbHVyZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5ub2RlRmFpbHVyZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5ub2RlRmFpbHVyZSA9IEJvb2xlYW4ob2JqZWN0Lm5vZGVGYWlsdXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uubm9kZUZhaWx1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5taWdyYXRpb24gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubWlncmF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLm1pZ3JhdGlvbiA9IEJvb2xlYW4ob2JqZWN0Lm1pZ3JhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLm1pZ3JhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnNlcnZlckxlYXZlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNlcnZlckxlYXZlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNlcnZlckxlYXZlID0gQm9vbGVhbihvYmplY3Quc2VydmVyTGVhdmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5zZXJ2ZXJMZWF2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnNwZWFrZXJVcGRhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zcGVha2VyVXBkYXRlID0gbWVzc2FnZS5zcGVha2VyVXBkYXRlKTtcbiAgICAgICAgbWVzc2FnZS5ub2RlRmFpbHVyZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm5vZGVGYWlsdXJlID0gbWVzc2FnZS5ub2RlRmFpbHVyZSk7XG4gICAgICAgIG1lc3NhZ2UubWlncmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKG9iai5taWdyYXRpb24gPSBtZXNzYWdlLm1pZ3JhdGlvbik7XG4gICAgICAgIG1lc3NhZ2Uuc2VydmVyTGVhdmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zZXJ2ZXJMZWF2ZSA9IG1lc3NhZ2Uuc2VydmVyTGVhdmUpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VTaW11bGF0ZVNjZW5hcmlvKTtcbiAgICAgICAgbWVzc2FnZS5zcGVha2VyVXBkYXRlID0gKF9hID0gb2JqZWN0LnNwZWFrZXJVcGRhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5ub2RlRmFpbHVyZSA9IChfYiA9IG9iamVjdC5ub2RlRmFpbHVyZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLm1pZ3JhdGlvbiA9IChfYyA9IG9iamVjdC5taWdyYXRpb24pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5zZXJ2ZXJMZWF2ZSA9IChfZCA9IG9iamVjdC5zZXJ2ZXJMZWF2ZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmlmIChtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgIT09IGxvbmdfMS5kZWZhdWx0KSB7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nID0gbG9uZ18xLmRlZmF1bHQ7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQuY29uZmlndXJlKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXZla2l0X3J0Yy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZGVmYXVsdElkID0gJ2RlZmF1bHQnO1xuY2xhc3MgRGV2aWNlTWFuYWdlciB7XG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IERldmljZU1hbmFnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgICB9XG4gICAgZ2V0RGV2aWNlcyhraW5kKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgZGV2aWNlcyA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKChkZXZpY2UpID0+IGRldmljZS5raW5kID09PSBraW5kKTtcbiAgICAgICAgICAgIC8vIENocm9tZSByZXR1cm5zICdkZWZhdWx0JyBkZXZpY2VzLCB3ZSB3b3VsZCBmaWx0ZXIgdGhlbSBvdXQsIGJ1dCBwdXQgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgIC8vIGRldmljZSBhdCBmaXJzdFxuICAgICAgICAgICAgLy8gd2Ugd291bGQgb25seSBkbyB0aGlzIGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gMSBkZXZpY2UgdGhvdWdoXG4gICAgICAgICAgICBpZiAoZGV2aWNlcy5sZW5ndGggPiAxICYmIGRldmljZXNbMF0uZGV2aWNlSWQgPT09IGRlZmF1bHRJZCkge1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgYW5vdGhlciBkZXZpY2Ugd2l0aCBtYXRjaGluZyBncm91cCBpZCwgYW5kIG1vdmUgdGhhdCB0byAwXG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdERldmljZSA9IGRldmljZXNbMF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkZXZpY2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2VzW2ldLmdyb3VwSWQgPT09IGRlZmF1bHREZXZpY2UuZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcCA9IGRldmljZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VzWzBdID0gZGV2aWNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZXNbaV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZXMuZmlsdGVyKChkZXZpY2UpID0+IGRldmljZSAhPT0gZGVmYXVsdERldmljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZURldmljZUlkKGtpbmQsIGRldmljZUlkLCBncm91cElkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoZGV2aWNlSWQgIT09IGRlZmF1bHRJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXZpY2VJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlc29sdmUgYWN0dWFsIGRldmljZSBpZCBpZiBpdCdzICdkZWZhdWx0JzogQ2hyb21lIHJldHVybnMgaXQgd2hlbiBub1xuICAgICAgICAgICAgLy8gZGV2aWNlIGhhcyBiZWVuIGNob3NlblxuICAgICAgICAgICAgY29uc3QgZGV2aWNlcyA9IHlpZWxkIHRoaXMuZ2V0RGV2aWNlcyhraW5kKTtcbiAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IGRldmljZXMuZmluZCgoZCkgPT4gZC5ncm91cElkID09PSBncm91cElkICYmIGQuZGV2aWNlSWQgIT09IGRlZmF1bHRJZCk7XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlID09PSBudWxsIHx8IGRldmljZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGV2aWNlLmRldmljZUlkO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEZXZpY2VNYW5hZ2VyO1xuRGV2aWNlTWFuYWdlci5tZWRpYURldmljZUtpbmRzID0gW1xuICAgICdhdWRpb2lucHV0JyxcbiAgICAnYXVkaW9vdXRwdXQnLFxuICAgICd2aWRlb2lucHV0Jyxcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZXZpY2VNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c19kZWJvdW5jZV8xID0gcmVxdWlyZShcInRzLWRlYm91bmNlXCIpO1xuY29uc3QgbG9nZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2xvZ2dlclwiKSk7XG4vKiogQGludGVybmFsICovXG5jbGFzcyBQQ1RyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZWdvdGlhdGUgPSBmYWxzZTtcbiAgICAgICAgLy8gZGVib3VuY2VkIG5lZ290aWF0ZSBpbnRlcmZhY2VcbiAgICAgICAgdGhpcy5uZWdvdGlhdGUgPSB0c19kZWJvdW5jZV8xLmRlYm91bmNlKCgpID0+IHsgdGhpcy5jcmVhdGVBbmRTZW5kT2ZmZXIoKTsgfSwgMTAwKTtcbiAgICAgICAgdGhpcy5wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihjb25maWcpO1xuICAgIH1cbiAgICBnZXQgaXNJQ0VDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb21wbGV0ZWQnO1xuICAgIH1cbiAgICBhZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYy5yZW1vdGVEZXNjcmlwdGlvbiAmJiAhdGhpcy5yZXN0YXJ0aW5nSWNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGMuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldFJlbW90ZURlc2NyaXB0aW9uKHNkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMuZm9yRWFjaCgoY2FuZGlkYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW5lZ290aWF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZWdvdGlhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUFuZFNlbmRPZmZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlQW5kU2VuZE9mZmVyKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uT2ZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWNlUmVzdGFydCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVidWcoJ3Jlc3RhcnRpbmcgSUNFJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBjLnNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1sb2NhbC1vZmZlcicpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSB3YWl0aW5nIGZvciB0aGUgcGVlciB0byBhY2NlcHQgb3VyIG9mZmVyLCBzbyB3ZSdsbCBqdXN0IHdhaXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyB3aGVuIElDRSByZXN0YXJ0IGlzIG5lZWRlZFxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTRCA9IHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWNlUmVzdGFydCkgJiYgY3VycmVudFNEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGhhbmRsZSB3aGVuIElDRSByZXN0YXJ0IGlzIG5lZWRlZCBidXQgd2UgZG9uJ3QgaGF2ZSBhIHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYmVzdCB0aGluZyB0byBkbyBpcyB0byByZWNyZWF0ZSB0aGUgcGVlcmNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihjdXJyZW50U0QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5lZ290aWF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBjLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQud2FybignY291bGQgbm90IGNyZWF0ZU9mZmVyIHdpdGggY2xvc2VkIHBlZXIgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IG5lZ290aWF0ZVxuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZWJ1Zygnc3RhcnRpbmcgdG8gbmVnb3RpYXRlJyk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHlpZWxkIHRoaXMucGMuY3JlYXRlT2ZmZXIob3B0aW9ucyk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgdGhpcy5vbk9mZmVyKG9mZmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnBjLmNsb3NlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUENUcmFuc3BvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QQ1RyYW5zcG9ydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYXhJQ0VDb25uZWN0VGltZW91dCA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IFNpZ25hbENsaWVudF8xID0gcmVxdWlyZShcIi4uL2FwaS9TaWduYWxDbGllbnRcIik7XG5jb25zdCBsb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbG9nZ2VyXCIpKTtcbmNvbnN0IGxpdmVraXRfbW9kZWxzXzEgPSByZXF1aXJlKFwiLi4vcHJvdG8vbGl2ZWtpdF9tb2RlbHNcIik7XG5jb25zdCBsaXZla2l0X3J0Y18xID0gcmVxdWlyZShcIi4uL3Byb3RvL2xpdmVraXRfcnRjXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBldmVudHNfMiA9IHJlcXVpcmUoXCIuL2V2ZW50c1wiKTtcbmNvbnN0IFBDVHJhbnNwb3J0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUENUcmFuc3BvcnRcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgbG9zc3lEYXRhQ2hhbm5lbCA9ICdfbG9zc3knO1xuY29uc3QgcmVsaWFibGVEYXRhQ2hhbm5lbCA9ICdfcmVsaWFibGUnO1xuY29uc3QgbWF4UmVjb25uZWN0UmV0cmllcyA9IDEwO1xuY29uc3QgbWluUmVjb25uZWN0V2FpdCA9IDEgKiAxMDAwO1xuY29uc3QgbWF4UmVjb25uZWN0RHVyYXRpb24gPSA2MCAqIDEwMDA7XG5leHBvcnRzLm1heElDRUNvbm5lY3RUaW1lb3V0ID0gMTUgKiAxMDAwO1xuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgUlRDRW5naW5lIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ydGNDb25maWcgPSB7fTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyUHJpbWFyeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBjQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVycyA9IHt9O1xuICAgICAgICAvLyB0cnVlIGlmIHB1Ymxpc2hlciBjb25uZWN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gZXN0YWJsaXNoZWQuXG4gICAgICAgIC8vIHRoaXMgaXMgaGVscGZ1bCB0byBrbm93IGlmIHdlIG5lZWQgdG8gcmVzdGFydCBJQ0Ugb24gdGhlIHB1Ymxpc2hlciBjb25uZWN0aW9uXG4gICAgICAgIHRoaXMuaGFzUHVibGlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgICAgICB0aGlzLnJlY29ubmVjdFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFuZGxlRGF0YUNoYW5uZWwgPSAoeyBjaGFubmVsIH0pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFubmVsLmxhYmVsID09PSByZWxpYWJsZURhdGFDaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxpYWJsZURDU3ViID0gY2hhbm5lbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5uZWwubGFiZWwgPT09IGxvc3N5RGF0YUNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvc3N5RENTdWIgPSBjaGFubmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbm5lbC5vbm1lc3NhZ2UgPSB0aGlzLmhhbmRsZURhdGFNZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVEYXRhTWVzc2FnZSA9IChtZXNzYWdlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBkZWNvZGVcbiAgICAgICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0geWllbGQgbWVzc2FnZS5kYXRhLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmVycm9yKCd1bnN1cHBvcnRlZCBkYXRhIHR5cGUnLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRwID0gbGl2ZWtpdF9tb2RlbHNfMS5EYXRhUGFja2V0LmRlY29kZShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgICAgICAgIGlmIChkcC5zcGVha2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gZGlzcGF0Y2ggc3BlYWtlciB1cGRhdGVzXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLkVuZ2luZUV2ZW50LkFjdGl2ZVNwZWFrZXJzVXBkYXRlLCBkcC5zcGVha2VyLnNwZWFrZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRwLnVzZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzIuRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCBkcC51c2VyLCBkcC5raW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlRGF0YUVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxLaW5kID0gY2hhbm5lbC5tYXhSZXRyYW5zbWl0cyA9PT0gMCA/ICdsb3NzeScgOiAncmVsaWFibGUnO1xuICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgRXJyb3JFdmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGV2ZW50LmVycm9yO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZXJyb3IoYERhdGFDaGFubmVsIGVycm9yIG9uICR7Y2hhbm5lbEtpbmR9OiAke2V2ZW50Lm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5lcnJvcihgVW5rbm93biBEYXRhQ2hhbm5lbCBFcnJvciBvbiAke2NoYW5uZWxLaW5kfWAsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gd2Vic29ja2V0IHJlY29ubmVjdCBiZWhhdmlvci4gaWYgd2Vic29ja2V0IGlzIGludGVycnVwdGVkLCBhbmQgdGhlIFBlZXJDb25uZWN0aW9uXG4gICAgICAgIC8vIGNvbnRpbnVlcyB0byB3b3JrLCB3ZSBjYW4gcmVjb25uZWN0IHRvIHdlYnNvY2tldCB0byBjb250aW51ZSB0aGUgc2Vzc2lvblxuICAgICAgICAvLyBhZnRlciBhIG51bWJlciBvZiByZXRyaWVzLCB3ZSdsbCBjbG9zZSBhbmQgZ2l2ZSB1cCBwZXJtYW5lbnRseVxuICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QgPSAoY29ubmVjdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKGAke2Nvbm5lY3Rpb259IGRpc2Nvbm5lY3RlZGApO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHJlc2V0IHN0YXJ0IHRpbWUgb24gdGhlIGZpcnN0IHRyeVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0U3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyAqIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMpICogMzAwO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mdWxsUmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlc3VtZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY292ZXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBlcnJvcnNfMS5VbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCdyZWNlaXZlZCB1bnJlY292ZXJhYmxlIGVycm9yJywgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVucmVjb3ZlcmFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY292ZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIShlIGluc3RhbmNlb2YgU2lnbmFsUmVjb25uZWN0RXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW5ub3QgcmVzdW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHRoaXMucmVjb25uZWN0U3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzID49IG1heFJlY29ubmVjdFJldHJpZXMgfHwgZHVyYXRpb24gPiBtYXhSZWNvbm5lY3REdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgncmVjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmluZm8oYGNvdWxkIG5vdCByZWNvdmVyIGNvbm5lY3Rpb24gYWZ0ZXIgJHttYXhSZWNvbm5lY3RSZXRyaWVzfSBhdHRlbXB0cywgJHtkdXJhdGlvbn1tcy4gZ2l2aW5nIHVwYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzIuRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCBkZWxheSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xpZW50ID0gbmV3IFNpZ25hbENsaWVudF8xLlNpZ25hbENsaWVudCgpO1xuICAgIH1cbiAgICBqb2luKHVybCwgdG9rZW4sIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdGhpcy5zaWduYWxPcHRzID0gb3B0cztcbiAgICAgICAgICAgIGNvbnN0IGpvaW5SZXNwb25zZSA9IHlpZWxkIHRoaXMuY2xpZW50LmpvaW4odXJsLCB0b2tlbiwgb3B0cyk7XG4gICAgICAgICAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJQcmltYXJ5ID0gam9pblJlc3BvbnNlLnN1YnNjcmliZXJQcmltYXJ5O1xuICAgICAgICAgICAgaWYgKCF0aGlzLnB1Ymxpc2hlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKGpvaW5SZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjcmVhdGUgb2ZmZXJcbiAgICAgICAgICAgIGlmICghdGhpcy5zdWJzY3JpYmVyUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVnb3RpYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gam9pblJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICBpZiAodGhpcy5wdWJsaXNoZXIgJiYgdGhpcy5wdWJsaXNoZXIucGMuc2lnbmFsaW5nU3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hlci5wYy5nZXRTZW5kZXJzKCkuZm9yRWFjaCgoc2VuZGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucHVibGlzaGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGMucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC53YXJuKCdjb3VsZCBub3QgcmVtb3ZlVHJhY2snLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudC5jbG9zZSgpO1xuICAgIH1cbiAgICBhZGRUcmFjayhyZXEpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3JlcS5jaWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVHJhY2tJbnZhbGlkRXJyb3IoJ2EgdHJhY2sgd2l0aCB0aGUgc2FtZSBJRCBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF0gPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuc2VuZEFkZFRyYWNrKHJlcSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVNdXRlU3RhdHVzKHRyYWNrU2lkLCBtdXRlZCkge1xuICAgICAgICB0aGlzLmNsaWVudC5zZW5kTXV0ZVRyYWNrKHRyYWNrU2lkLCBtdXRlZCk7XG4gICAgfVxuICAgIGdldCBkYXRhU3Vic2NyaWJlclJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMucmVsaWFibGVEQ1N1YikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGU7XG4gICAgfVxuICAgIGdldCBjb25uZWN0ZWRTZXJ2ZXJBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWRTZXJ2ZXJBZGRyO1xuICAgIH1cbiAgICBjb25maWd1cmUoam9pblJlc3BvbnNlKSB7XG4gICAgICAgIC8vIGFscmVhZHkgY29uZmlndXJlZFxuICAgICAgICBpZiAodGhpcy5wdWJsaXNoZXIgfHwgdGhpcy5zdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIElDRSBzZXJ2ZXJzIGJlZm9yZSBjcmVhdGluZyBQZWVyQ29ubmVjdGlvblxuICAgICAgICBpZiAoam9pblJlc3BvbnNlLmljZVNlcnZlcnMgJiYgIXRoaXMucnRjQ29uZmlnLmljZVNlcnZlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ0Y0ljZVNlcnZlcnMgPSBbXTtcbiAgICAgICAgICAgIGpvaW5SZXNwb25zZS5pY2VTZXJ2ZXJzLmZvckVhY2goKGljZVNlcnZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ0Y0ljZVNlcnZlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsczogaWNlU2VydmVyLnVybHMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoaWNlU2VydmVyLnVzZXJuYW1lKVxuICAgICAgICAgICAgICAgICAgICBydGNJY2VTZXJ2ZXIudXNlcm5hbWUgPSBpY2VTZXJ2ZXIudXNlcm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGljZVNlcnZlci5jcmVkZW50aWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ0Y0ljZVNlcnZlci5jcmVkZW50aWFsID0gaWNlU2VydmVyLmNyZWRlbnRpYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ0Y0ljZVNlcnZlcnMucHVzaChydGNJY2VTZXJ2ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJ0Y0NvbmZpZy5pY2VTZXJ2ZXJzID0gcnRjSWNlU2VydmVycztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1Ymxpc2hlciA9IG5ldyBQQ1RyYW5zcG9ydF8xLmRlZmF1bHQodGhpcy5ydGNDb25maWcpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBuZXcgUENUcmFuc3BvcnRfMS5kZWZhdWx0KHRoaXMucnRjQ29uZmlnKTtcbiAgICAgICAgdGhpcy5wdWJsaXNoZXIucGMub25pY2VjYW5kaWRhdGUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICghZXYuY2FuZGlkYXRlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQudHJhY2UoJ2FkZGluZyBJQ0UgY2FuZGlkYXRlIGZvciBwZWVyJywgZXYuY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50LnNlbmRJY2VDYW5kaWRhdGUoZXYuY2FuZGlkYXRlLCBsaXZla2l0X3J0Y18xLlNpZ25hbFRhcmdldC5QVUJMSVNIRVIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIucGMub25pY2VjYW5kaWRhdGUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICghZXYuY2FuZGlkYXRlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50LnNlbmRJY2VDYW5kaWRhdGUoZXYuY2FuZGlkYXRlLCBsaXZla2l0X3J0Y18xLlNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wdWJsaXNoZXIub25PZmZlciA9IChvZmZlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuc2VuZE9mZmVyKG9mZmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHByaW1hcnlQQyA9IHRoaXMucHVibGlzaGVyLnBjO1xuICAgICAgICBpZiAoam9pblJlc3BvbnNlLnN1YnNjcmliZXJQcmltYXJ5KSB7XG4gICAgICAgICAgICBwcmltYXJ5UEMgPSB0aGlzLnN1YnNjcmliZXIucGM7XG4gICAgICAgICAgICAvLyBpbiBzdWJzY3JpYmVyIHByaW1hcnkgbW9kZSwgc2VydmVyIHNpZGUgb3BlbnMgc3ViIGRhdGEgY2hhbm5lbHMuXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIucGMub25kYXRhY2hhbm5lbCA9IHRoaXMuaGFuZGxlRGF0YUNoYW5uZWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmltYXJ5UEMgPSBwcmltYXJ5UEM7XG4gICAgICAgIHByaW1hcnlQQy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwcmltYXJ5UEMuY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQudHJhY2UoJ3BjIGNvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wY0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBjQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLkVuZ2luZUV2ZW50LkNvbm5lY3RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdldENvbm5lY3RlZEFkZHJlc3MocHJpbWFyeVBDKS50aGVuKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkU2VydmVyQWRkciA9IHY7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmltYXJ5UEMuY29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgICAgIC8vIG9uIFNhZmFyaSwgUGVlckNvbm5lY3Rpb24gd2lsbCBzd2l0Y2ggdG8gJ2Rpc2Nvbm5lY3RlZCcgZHVyaW5nIHJlbmVnb3RpYXRpb25cbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LnRyYWNlKCdwYyBkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wY0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBjQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgncGVlcmNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlci5wYy5vbnRyYWNrID0gKGV2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzIuRW5naW5lRXZlbnQuTWVkaWFUcmFja0FkZGVkLCBldi50cmFjaywgZXYuc3RyZWFtc1swXSwgZXYucmVjZWl2ZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBkYXRhIGNoYW5uZWxzXG4gICAgICAgIHRoaXMubG9zc3lEQyA9IHRoaXMucHVibGlzaGVyLnBjLmNyZWF0ZURhdGFDaGFubmVsKGxvc3N5RGF0YUNoYW5uZWwsIHtcbiAgICAgICAgICAgIC8vIHdpbGwgZHJvcCBvbGRlciBwYWNrZXRzIHRoYXQgYXJyaXZlXG4gICAgICAgICAgICBvcmRlcmVkOiB0cnVlLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbGlhYmxlREMgPSB0aGlzLnB1Ymxpc2hlci5wYy5jcmVhdGVEYXRhQ2hhbm5lbChyZWxpYWJsZURhdGFDaGFubmVsLCB7XG4gICAgICAgICAgICBvcmRlcmVkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gYWxzbyBoYW5kbGUgbWVzc2FnZXMgb3ZlciB0aGUgcHViIGNoYW5uZWwsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICB0aGlzLmxvc3N5REMub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgICAgICAgdGhpcy5yZWxpYWJsZURDLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XG4gICAgICAgIC8vIGhhbmRsZSBkYXRhY2hhbm5lbCBlcnJvcnNcbiAgICAgICAgdGhpcy5sb3NzeURDLm9uZXJyb3IgPSB0aGlzLmhhbmRsZURhdGFFcnJvcjtcbiAgICAgICAgdGhpcy5yZWxpYWJsZURDLm9uZXJyb3IgPSB0aGlzLmhhbmRsZURhdGFFcnJvcjtcbiAgICAgICAgLy8gY29uZmlndXJlIHNpZ25hbGluZyBjbGllbnRcbiAgICAgICAgdGhpcy5jbGllbnQub25BbnN3ZXIgPSAoc2QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wdWJsaXNoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCdyZWNlaXZlZCBzZXJ2ZXIgYW5zd2VyJywgc2QudHlwZSwgdGhpcy5wdWJsaXNoZXIucGMuc2lnbmFsaW5nU3RhdGUpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoZXIuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gYWRkIGNhbmRpZGF0ZSBvbiB0cmlja2xlXG4gICAgICAgIHRoaXMuY2xpZW50Lm9uVHJpY2tsZSA9IChjYW5kaWRhdGUsIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnB1Ymxpc2hlciB8fCAhdGhpcy5zdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC50cmFjZSgnZ290IElDRSBjYW5kaWRhdGUgZnJvbSBwZWVyJywgY2FuZGlkYXRlLCB0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gbGl2ZWtpdF9ydGNfMS5TaWduYWxUYXJnZXQuUFVCTElTSEVSKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHdoZW4gc2VydmVyIGNyZWF0ZXMgYW4gb2ZmZXIgZm9yIHRoZSBjbGllbnRcbiAgICAgICAgdGhpcy5jbGllbnQub25PZmZlciA9IChzZCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCdyZWNlaXZlZCBzZXJ2ZXIgb2ZmZXInLCBzZC50eXBlLCB0aGlzLnN1YnNjcmliZXIucGMuc2lnbmFsaW5nU3RhdGUpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zdWJzY3JpYmVyLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgICAgIC8vIGFuc3dlciB0aGUgb2ZmZXJcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHlpZWxkIHRoaXMuc3Vic2NyaWJlci5wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc3Vic2NyaWJlci5wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5zZW5kQW5zd2VyKGFuc3dlcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsaWVudC5vbkxvY2FsVHJhY2tQdWJsaXNoZWQgPSAocmVzKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCdyZWNlaXZlZCB0cmFja1B1Ymxpc2hlZFJlc3BvbnNlJywgcmVzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXMuY2lkXTtcbiAgICAgICAgICAgIGlmICghcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZXJyb3IoJ21pc3NpbmcgdHJhY2sgcmVzb2x2ZXIgZm9yICcsIHJlcy5jaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXMuY2lkXTtcbiAgICAgICAgICAgIHJlc29sdmUocmVzLnRyYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGllbnQub25Ub2tlblJlZnJlc2ggPSAodG9rZW4pID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGllbnQub25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgnc2lnbmFsJyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xpZW50Lm9uTGVhdmUgPSAobGVhdmUpID0+IHtcbiAgICAgICAgICAgIGlmIChsZWF2ZSA9PT0gbnVsbCB8fCBsZWF2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhdmUuY2FuUmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW1hcnlQQyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5FbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVzdGFydENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXJsIHx8ICF0aGlzLnRva2VuKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVybWFuZW50IGZhaWx1cmUsIGRvbid0IGF0dGVtcHQgcmVjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHVybCBvciB0b2tlbiBub3Qgc2F2ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuaW5mbygncmVjb25uZWN0aW5nLCBhdHRlbXB0JywgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5FbmdpbmVFdmVudC5SZXN0YXJ0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJpbWFyeVBDID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5wdWJsaXNoZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLnN1YnNjcmliZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGpvaW5SZXNwb25zZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgam9pblJlc3BvbnNlID0geWllbGQgdGhpcy5qb2luKHRoaXMudXJsLCB0aGlzLnRva2VuLCB0aGlzLnNpZ25hbE9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHRoaXMud2FpdEZvclBDQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICAvLyByZWNvbm5lY3Qgc3VjY2Vzc1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLkVuZ2luZUV2ZW50LlJlc3RhcnRlZCwgam9pblJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3VtZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXJsIHx8ICF0aGlzLnRva2VuKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVybWFuZW50IGZhaWx1cmUsIGRvbid0IGF0dGVtcHQgcmVjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHVybCBvciB0b2tlbiBub3Qgc2F2ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgcHVibGlzaGVyIHJlY29ubmVjdFxuICAgICAgICAgICAgaWYgKCF0aGlzLnB1Ymxpc2hlciB8fCAhdGhpcy5zdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3B1Ymxpc2hlciBhbmQgc3Vic2NyaWJlciBjb25uZWN0aW9ucyB1bnNldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5pbmZvKCdyZXN1bWluZyBzaWduYWwgY29ubmVjdGlvbiwgYXR0ZW1wdCcsIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzIuRW5naW5lRXZlbnQuUmVzdW1pbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNsaWVudC5yZWNvbm5lY3QodGhpcy51cmwsIHRoaXMudG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5FbmdpbmVFdmVudC5TaWduYWxSZXN1bWVkKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5yZXN0YXJ0aW5nSWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIG9ubHkgcmVzdGFydCBwdWJsaXNoZXIgaWYgaXQncyBuZWVkZWRcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1B1Ymxpc2hlZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucHVibGlzaGVyLmNyZWF0ZUFuZFNlbmRPZmZlcih7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB0aGlzLndhaXRGb3JQQ0Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgLy8gcmVzdW1lIHN1Y2Nlc3NcbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5FbmdpbmVFdmVudC5SZXN1bWVkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdhaXRGb3JQQ0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGxldCBub3cgPSBzdGFydFRpbWU7XG4gICAgICAgICAgICB0aGlzLnBjQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAobm93IC0gc3RhcnRUaW1lIDwgZXhwb3J0cy5tYXhJQ0VDb25uZWN0VGltZW91dCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGNvbm5lY3Rpb25zdGF0ZWNoYW5nZSBjYWxsYmFjayBmaXJlZFxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGNvbm5lY3Rpb25zdGF0ZSBhZnRlciBtaW5SZWNvbm5lY3RXYWl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJpbWFyeVBDID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGFib3J0IGVhcmx5LCBjb25uZWN0aW9uIGlzIGhvc2VkXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub3cgLSBzdGFydFRpbWUgPiBtaW5SZWNvbm5lY3RXYWl0ICYmICgoX2EgPSB0aGlzLnByaW1hcnlQQykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbm5lY3Rpb25TdGF0ZSkgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wY0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHV0aWxzXzEuc2xlZXAoMTAwKTtcbiAgICAgICAgICAgICAgICBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGF2ZSBub3QgcmVjb25uZWN0ZWQsIHRocm93XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ29ubmVjdGlvbkVycm9yKCdjb3VsZCBub3QgZXN0YWJsaXNoIFBDIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qIEBpbnRlcm5hbCAqL1xuICAgIHNlbmREYXRhUGFja2V0KHBhY2tldCwga2luZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gbGl2ZWtpdF9tb2RlbHNfMS5EYXRhUGFja2V0LmVuY29kZShwYWNrZXQpLmZpbmlzaCgpO1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGRvIGhhdmUgYSBkYXRhIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5zdXJlUHVibGlzaGVyQ29ubmVjdGVkKGtpbmQpO1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IGxpdmVraXRfbW9kZWxzXzEuRGF0YVBhY2tldF9LaW5kLkxPU1NZICYmIHRoaXMubG9zc3lEQykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9zc3lEQy5zZW5kKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChraW5kID09PSBsaXZla2l0X21vZGVsc18xLkRhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSAmJiB0aGlzLnJlbGlhYmxlREMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGlhYmxlREMuc2VuZChtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5zdXJlUHVibGlzaGVyQ29ubmVjdGVkKGtpbmQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdWJzY3JpYmVyUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5wdWJsaXNoZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ29ubmVjdGlvbkVycm9yKCdwdWJsaXNoZXIgY29ubmVjdGlvbiBub3Qgc2V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucHVibGlzaGVyLmlzSUNFQ29ubmVjdGVkICYmIHRoaXMucHVibGlzaGVyLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSAhPT0gJ2NoZWNraW5nJykge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG5lZ290aWF0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5uZWdvdGlhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldENoYW5uZWwgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kKTtcbiAgICAgICAgICAgIGlmICgodGFyZ2V0Q2hhbm5lbCA9PT0gbnVsbCB8fCB0YXJnZXRDaGFubmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXRDaGFubmVsLnJlYWR5U3RhdGUpID09PSAnb3BlbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3YWl0IHVudGlsIHB1Ymxpc2hlciBJQ0UgY29ubmVjdGVkXG4gICAgICAgICAgICBjb25zdCBlbmRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIGV4cG9ydHMubWF4SUNFQ29ubmVjdFRpbWVvdXQ7XG4gICAgICAgICAgICB3aGlsZSAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSA8IGVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wdWJsaXNoZXIuaXNJQ0VDb25uZWN0ZWQgJiYgKChfYSA9IHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZHlTdGF0ZSkgPT09ICdvcGVuJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHV0aWxzXzEuc2xlZXAoNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNvbm5lY3Rpb25FcnJvcihgY291bGQgbm90IGVzdGFibGlzaCBwdWJsaXNoZXIgY29ubmVjdGlvbiwgc3RhdGUgJHsoX2IgPSB0aGlzLnB1Ymxpc2hlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBjLmljZUNvbm5lY3Rpb25TdGF0ZX1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBuZWdvdGlhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5wdWJsaXNoZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc1B1Ymxpc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucHVibGlzaGVyLm5lZ290aWF0ZSgpO1xuICAgIH1cbiAgICBkYXRhQ2hhbm5lbEZvcktpbmQoa2luZCkge1xuICAgICAgICBpZiAoa2luZCA9PT0gbGl2ZWtpdF9tb2RlbHNfMS5EYXRhUGFja2V0X0tpbmQuTE9TU1kpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvc3N5REM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtpbmQgPT09IGxpdmVraXRfbW9kZWxzXzEuRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxpYWJsZURDO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUlRDRW5naW5lO1xuZnVuY3Rpb24gZ2V0Q29ubmVjdGVkQWRkcmVzcyhwYykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsZXQgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSAnJztcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlUGFpcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIGlkIC0+IGNhbmRpZGF0ZSBpcFxuICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHBjLmdldFN0YXRzKCk7XG4gICAgICAgIHN0YXRzLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndHJhbnNwb3J0JzpcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSB2LnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjYW5kaWRhdGUtcGFpcic6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9PT0gJycgJiYgdi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSB2LmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVBhaXJzLnNldCh2LmlkLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVtb3RlLWNhbmRpZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMuc2V0KHYuaWQsIGAke3YuYWRkcmVzc306JHt2LnBvcnR9YCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkSUQgPSAoX2EgPSBjYW5kaWRhdGVQYWlycy5nZXQoc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3RlQ2FuZGlkYXRlSWQ7XG4gICAgICAgIGlmIChzZWxlY3RlZElEID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZXMuZ2V0KHNlbGVjdGVkSUQpO1xuICAgIH0pO1xufVxuY2xhc3MgU2lnbmFsUmVjb25uZWN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SVENFbmdpbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Sb29tU3RhdGUgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBTaWduYWxDbGllbnRfMSA9IHJlcXVpcmUoXCIuLi9hcGkvU2lnbmFsQ2xpZW50XCIpO1xuY29uc3QgbG9nZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2xvZ2dlclwiKSk7XG5jb25zdCBsaXZla2l0X21vZGVsc18xID0gcmVxdWlyZShcIi4uL3Byb3RvL2xpdmVraXRfbW9kZWxzXCIpO1xuY29uc3QgbGl2ZWtpdF9ydGNfMSA9IHJlcXVpcmUoXCIuLi9wcm90by9saXZla2l0X3J0Y1wiKTtcbmNvbnN0IERldmljZU1hbmFnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9EZXZpY2VNYW5hZ2VyXCIpKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgZXZlbnRzXzIgPSByZXF1aXJlKFwiLi9ldmVudHNcIik7XG5jb25zdCBMb2NhbFBhcnRpY2lwYW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFydGljaXBhbnQvTG9jYWxQYXJ0aWNpcGFudFwiKSk7XG5jb25zdCBSZW1vdGVQYXJ0aWNpcGFudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnRpY2lwYW50L1JlbW90ZVBhcnRpY2lwYW50XCIpKTtcbmNvbnN0IFJUQ0VuZ2luZV8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL1JUQ0VuZ2luZVwiKSk7XG5jb25zdCBkZWZhdWx0c18xID0gcmVxdWlyZShcIi4vdHJhY2svZGVmYXVsdHNcIik7XG5jb25zdCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHJhY2svUmVtb3RlVHJhY2tQdWJsaWNhdGlvblwiKSk7XG5jb25zdCBUcmFja18xID0gcmVxdWlyZShcIi4vdHJhY2svVHJhY2tcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgUm9vbVN0YXRlO1xuKGZ1bmN0aW9uIChSb29tU3RhdGUpIHtcbiAgICBSb29tU3RhdGVbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIFJvb21TdGF0ZVtcIkNvbm5lY3RlZFwiXSA9IFwiY29ubmVjdGVkXCI7XG4gICAgUm9vbVN0YXRlW1wiUmVjb25uZWN0aW5nXCJdID0gXCJyZWNvbm5lY3RpbmdcIjtcbn0pKFJvb21TdGF0ZSA9IGV4cG9ydHMuUm9vbVN0YXRlIHx8IChleHBvcnRzLlJvb21TdGF0ZSA9IHt9KSk7XG4vKipcbiAqIEluIExpdmVLaXQsIGEgcm9vbSBpcyB0aGUgbG9naWNhbCBncm91cGluZyBmb3IgYSBsaXN0IG9mIHBhcnRpY2lwYW50cy5cbiAqIFBhcnRpY2lwYW50cyBpbiBhIHJvb20gY2FuIHB1Ymxpc2ggdHJhY2tzLCBhbmQgc3Vic2NyaWJlIHRvIG90aGVycycgdHJhY2tzLlxuICpcbiAqIGEgUm9vbSBmaXJlcyBbW1Jvb21FdmVudCB8IFJvb21FdmVudHNdXS5cbiAqXG4gKiBAbm9Jbmhlcml0RG9jXG4gKi9cbmNsYXNzIFJvb20gZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgUm9vbSwgdGhlIHByaW1hcnkgY29uc3RydWN0IGZvciBhIExpdmVLaXQgc2Vzc2lvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFJvb21TdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsaXN0IG9mIHBhcnRpY2lwYW50cyB0aGF0IGFyZSBhY3RpdmVseSBzcGVha2luZy4gd2hlbiB0aGlzIGNoYW5nZXNcbiAgICAgICAgICogYSBbW1Jvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWRdXSBldmVudCBpcyBmaXJlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IFtdO1xuICAgICAgICAvLyBhdmFpbGFibGUgYWZ0ZXIgY29ubmVjdGVkXG4gICAgICAgIC8qKiBzZXJ2ZXIgYXNzaWduZWQgdW5pcXVlIHJvb20gaWQgKi9cbiAgICAgICAgdGhpcy5zaWQgPSAnJztcbiAgICAgICAgLyoqIHVzZXIgYXNzaWduZWQgbmFtZSwgZGVyaXZlZCBmcm9tIEpXVCB0b2tlbiAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnJztcbiAgICAgICAgLyoqIHJvb20gbWV0YWRhdGEgKi9cbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hdWRpb0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbm5lY3QgPSAodXJsLCB0b2tlbiwgb3B0cykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBjYWxsaW5nIGNvbm5lY3RcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBSb29tU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC53YXJuKCdhbHJlYWR5IGNvbm5lY3RlZCB0byByb29tJywgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWNyZWF0ZSBlbmdpbmUgaWYgcHJldmlvdXNseSBkaXNjb25uZWN0ZWRcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRW5naW5lKCk7XG4gICAgICAgICAgICB0aGlzLmFjcXVpcmVBdWRpb0NvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMucnRjQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUucnRjQ29uZmlnID0gb3B0cy5ydGNDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbm5PcHRpb25zID0gb3B0cztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9pblJlc3BvbnNlID0geWllbGQgdGhpcy5lbmdpbmUuam9pbih1cmwsIHRva2VuLCBvcHRzKTtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCdjb25uZWN0ZWQgdG8gTGl2ZWtpdCBTZXJ2ZXInLCBqb2luUmVzcG9uc2Uuc2VydmVyVmVyc2lvbik7XG4gICAgICAgICAgICAgICAgaWYgKCFqb2luUmVzcG9uc2Uuc2VydmVyVmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRTZXJ2ZXIoJ3Vua25vd24gc2VydmVyIHZlcnNpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGpvaW5SZXNwb25zZS5zZXJ2ZXJWZXJzaW9uID09PSAnMC4xNS4xJyAmJiB0aGlzLm9wdGlvbnMuZHluYWNhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZWJ1ZygnZGlzYWJsaW5nIGR5bmFjYXN0IGR1ZSB0byBzZXJ2ZXIgdmVyc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkeW5hY2FzdCBoYXMgYSBidWcgaW4gMC4xNS4xLCBzbyB3ZSBjYW5ub3QgdXNlIGl0IHRoZW5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmR5bmFjYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBSb29tU3RhdGUuQ29ubmVjdGVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50O1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudCA9IG5ldyBMb2NhbFBhcnRpY2lwYW50XzEuZGVmYXVsdChwaS5zaWQsIHBpLmlkZW50aXR5LCB0aGlzLmVuZ2luZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhwaSk7XG4gICAgICAgICAgICAgICAgLy8gZm9yd2FyZCBtZXRhZGF0YSBjaGFuZ2VkIGZvciB0aGUgbG9jYWwgcGFydGljaXBhbnRcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnRcbiAgICAgICAgICAgICAgICAgICAgLm9uKGV2ZW50c18yLlBhcnRpY2lwYW50RXZlbnQuTWV0YWRhdGFDaGFuZ2VkLCAobWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlJvb21FdmVudC5NZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbihldmVudHNfMi5QYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCAobWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlJvb21FdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKGV2ZW50c18yLlBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgKHB1YikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzIuUm9vbUV2ZW50LlRyYWNrTXV0ZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAub24oZXZlbnRzXzIuUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIChwdWIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlJvb21FdmVudC5UcmFja1VubXV0ZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAub24oZXZlbnRzXzIuUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCAocHViKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbihldmVudHNfMi5QYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgKHB1YikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzIuUm9vbUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbihldmVudHNfMi5QYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgKHF1YWxpdHkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlJvb21FdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHF1YWxpdHksIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKGV2ZW50c18yLlBhcnRpY2lwYW50RXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHBvcHVsYXRlIHJlbW90ZSBwYXJ0aWNpcGFudHMsIHRoZXNlIHNob3VsZCBub3QgdHJpZ2dlciBuZXcgZXZlbnRzXG4gICAgICAgICAgICAgICAgam9pblJlc3BvbnNlLm90aGVyUGFydGljaXBhbnRzLmZvckVhY2goKGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPckNyZWF0ZVBhcnRpY2lwYW50KGluZm8uc2lkLCBpbmZvKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBqb2luUmVzcG9uc2Uucm9vbS5uYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuc2lkID0gam9pblJlc3BvbnNlLnJvb20uc2lkO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEgPSBqb2luUmVzcG9uc2Uucm9vbS5tZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHJldHVybiB1bnRpbCBJQ0UgY29ubmVjdGVkXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcnNfMS5Db25uZWN0aW9uRXJyb3IoJ2NvdWxkIG5vdCBjb25uZWN0IGFmdGVyIHRpbWVvdXQnKSk7XG4gICAgICAgICAgICAgICAgfSwgUlRDRW5naW5lXzEubWF4SUNFQ29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lLm9uY2UoZXZlbnRzXzIuRW5naW5lRXZlbnQuQ29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gaG9vayB1bmxvYWQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMub25CZWZvcmVVbmxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZWNoYW5nZScsIHRoaXMuaGFuZGxlRGV2aWNlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRpc2Nvbm5lY3RzIHRoZSByb29tLCBlbWl0cyBbW1Jvb21FdmVudC5EaXNjb25uZWN0ZWRdXVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNjb25uZWN0ID0gKHN0b3BUcmFja3MgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgICAvLyBzZW5kIGxlYXZlXG4gICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZExlYXZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdChzdG9wVHJhY2tzKTtcbiAgICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICAgIHRoaXMuZW5naW5lID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQmVmb3JlVW5sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzdGFydGluZyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBSb29tU3RhdGUuUmVjb25uZWN0aW5nO1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlJvb21FdmVudC5SZWNvbm5lY3RpbmcpO1xuICAgICAgICAgICAgLy8gYWxzbyB1bndpbmQgZXhpc3RpbmcgcGFydGljaXBhbnRzICYgZXhpc3Rpbmcgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChwLnNpZCwgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzdGFydGVkID0gKGpvaW5SZXNwb25zZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFJvb21TdGF0ZS5Db25uZWN0ZWQ7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzIuUm9vbUV2ZW50LlJlY29ubmVjdGVkKTtcbiAgICAgICAgICAgIC8vIHJlaHlkcmF0ZSBwYXJ0aWNpcGFudHNcbiAgICAgICAgICAgIGlmIChqb2luUmVzcG9uc2UucGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgICAgICAvLyB3aXRoIGEgcmVzdGFydCwgdGhlIHNpZCB3aWxsIGhhdmUgY2hhbmdlZCwgd2UnbGwgbWFwIG91ciB1bmRlcnN0YW5kaW5nIHRvIGl0XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudC5zaWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMoW2pvaW5SZXNwb25zZS5wYXJ0aWNpcGFudF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMoam9pblJlc3BvbnNlLm90aGVyUGFydGljaXBhbnRzKTtcbiAgICAgICAgICAgIC8vIHVucHVibGlzaCAmIHJlcHVibGlzaCB0cmFja3NcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsUHVicyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnRyYWNrcy5mb3JFYWNoKChwdWIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUHVicy5wdXNoKHB1Yik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChsb2NhbFB1YnMubWFwKChwdWIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjayA9IHB1Yi50cmFjaztcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudW5wdWJsaXNoVHJhY2sodHJhY2ssIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHRyYWNrLCBwdWIub3B0aW9ucyk7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMgPSAocGFydGljaXBhbnRJbmZvcykgPT4ge1xuICAgICAgICAgICAgLy8gaGFuZGxlIGNoYW5nZXMgdG8gcGFydGljaXBhbnQgc3RhdGUsIGFuZCBzZW5kIGV2ZW50c1xuICAgICAgICAgICAgcGFydGljaXBhbnRJbmZvcy5mb3JFYWNoKChpbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uc2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkXG4gICAgICAgICAgICAgICAgICAgIHx8IGluZm8uaWRlbnRpdHkgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVtb3RlUGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQoaW5mby5zaWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzTmV3UGFydGljaXBhbnQgPSAhcmVtb3RlUGFydGljaXBhbnQ7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHBhcnRpY2lwYW50IGlmIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICAgICByZW1vdGVQYXJ0aWNpcGFudCA9IHRoaXMuZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudChpbmZvLnNpZCwgaW5mbyk7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBpdCdzIGRpc2Nvbm5lY3RlZCwgc2VuZCB1cGRhdGVzXG4gICAgICAgICAgICAgICAgaWYgKGluZm8uc3RhdGUgPT09IGxpdmVraXRfbW9kZWxzXzEuUGFydGljaXBhbnRJbmZvX1N0YXRlLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKGluZm8uc2lkLCByZW1vdGVQYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTmV3UGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZSBjb25uZWN0ZWQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlJvb21FdmVudC5QYXJ0aWNpcGFudENvbm5lY3RlZCwgcmVtb3RlUGFydGljaXBhbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCB1cGRhdGUsIG5vIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVQYXJ0aWNpcGFudC51cGRhdGVJbmZvKGluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyB1cGRhdGVzIGFyZSBzZW50IG9ubHkgd2hlbiB0aGVyZSdzIGEgY2hhbmdlIHRvIHNwZWFrZXIgb3JkZXJpbmdcbiAgICAgICAgdGhpcy5oYW5kbGVBY3RpdmVTcGVha2Vyc1VwZGF0ZSA9IChzcGVha2VycykgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlU3BlYWtlcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNlZW5TaWRzID0ge307XG4gICAgICAgICAgICBzcGVha2Vycy5mb3JFYWNoKChzcGVha2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VlblNpZHNbc3BlYWtlci5zaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYWtlci5zaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmF1ZGlvTGV2ZWwgPSBzcGVha2VyLmxldmVsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0SXNTcGVha2luZyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaCh0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMucGFydGljaXBhbnRzLmdldChzcGVha2VyLnNpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmF1ZGlvTGV2ZWwgPSBzcGVha2VyLmxldmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5zZXRJc1NwZWFraW5nKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFzZWVuU2lkc1t0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb0xldmVsID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0SXNTcGVha2luZyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2lwYW50cy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWVuU2lkc1twLnNpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcC5hdWRpb0xldmVsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcC5zZXRJc1NwZWFraW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBhY3RpdmVTcGVha2VycztcbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkLCBhY3RpdmVTcGVha2Vycyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHByb2Nlc3MgbGlzdCBvZiBjaGFuZ2VkIHNwZWFrZXJzXG4gICAgICAgIHRoaXMuaGFuZGxlU3BlYWtlcnNDaGFuZ2VkID0gKHNwZWFrZXJVcGRhdGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYXN0U3BlYWtlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgICAgICBsYXN0U3BlYWtlcnMuc2V0KHAuc2lkLCBwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3BlYWtlclVwZGF0ZXMuZm9yRWFjaCgoc3BlYWtlcikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHNwZWFrZXIuc2lkKTtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYWtlci5zaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMubG9jYWxQYXJ0aWNpcGFudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcC5hdWRpb0xldmVsID0gc3BlYWtlci5sZXZlbDtcbiAgICAgICAgICAgICAgICBwLnNldElzU3BlYWtpbmcoc3BlYWtlci5hY3RpdmUpO1xuICAgICAgICAgICAgICAgIGlmIChzcGVha2VyLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3BlYWtlcnMuc2V0KHNwZWFrZXIuc2lkLCBwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTcGVha2Vycy5kZWxldGUoc3BlYWtlci5zaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlU3BlYWtlcnMgPSBBcnJheS5mcm9tKGxhc3RTcGVha2Vycy52YWx1ZXMoKSk7XG4gICAgICAgICAgICBhY3RpdmVTcGVha2Vycy5zb3J0KChhLCBiKSA9PiBiLmF1ZGlvTGV2ZWwgLSBhLmF1ZGlvTGV2ZWwpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IGFjdGl2ZVNwZWFrZXJzO1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlJvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWQsIGFjdGl2ZVNwZWFrZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTdHJlYW1TdGF0ZVVwZGF0ZSA9IChzdHJlYW1TdGF0ZVVwZGF0ZSkgPT4ge1xuICAgICAgICAgICAgc3RyZWFtU3RhdGVVcGRhdGUuc3RyZWFtU3RhdGVzLmZvckVhY2goKHN0cmVhbVN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQoc3RyZWFtU3RhdGUucGFydGljaXBhbnRTaWQpO1xuICAgICAgICAgICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwdWIgPSBwYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uKHN0cmVhbVN0YXRlLnRyYWNrU2lkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXB1YiB8fCAhcHViLnRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHViLnRyYWNrLnN0cmVhbVN0YXRlID0gVHJhY2tfMS5UcmFjay5zdHJlYW1TdGF0ZUZyb21Qcm90byhzdHJlYW1TdGF0ZS5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgcGFydGljaXBhbnQuZW1pdChldmVudHNfMi5QYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkLCBwdWIsIHB1Yi50cmFjay5zdHJlYW1TdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsIHB1YiwgcHViLnRyYWNrLnN0cmVhbVN0YXRlLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gKHVwZGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQodXBkYXRlLnBhcnRpY2lwYW50U2lkKTtcbiAgICAgICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwdWIgPSBwYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uKHVwZGF0ZS50cmFja1NpZCk7XG4gICAgICAgICAgICBpZiAoIXB1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHB1Yi5fYWxsb3dlZCA9IHVwZGF0ZS5hbGxvd2VkO1xuICAgICAgICAgICAgcGFydGljaXBhbnQuZW1pdChldmVudHNfMi5QYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHB1YiwgcHViLnN1YnNjcmlwdGlvblN0YXR1cyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzIuUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCBwdWIsIHB1Yi5zdWJzY3JpcHRpb25TdGF0dXMsIHBhcnRpY2lwYW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEYXRhUGFja2V0ID0gKHVzZXJQYWNrZXQsIGtpbmQpID0+IHtcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIHBhcnRpY2lwYW50XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldCh1c2VyUGFja2V0LnBhcnRpY2lwYW50U2lkKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuRGF0YVJlY2VpdmVkLCB1c2VyUGFja2V0LnBheWxvYWQsIHBhcnRpY2lwYW50LCBraW5kKTtcbiAgICAgICAgICAgIC8vIGFsc28gZW1pdCBvbiB0aGUgcGFydGljaXBhbnRcbiAgICAgICAgICAgIHBhcnRpY2lwYW50ID09PSBudWxsIHx8IHBhcnRpY2lwYW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJ0aWNpcGFudC5lbWl0KGV2ZW50c18yLlBhcnRpY2lwYW50RXZlbnQuRGF0YVJlY2VpdmVkLCB1c2VyUGFja2V0LnBheWxvYWQsIGtpbmQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXVkaW9FbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQgPSAoZSkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC53YXJuKCdjb3VsZCBub3QgcGxheWJhY2sgYXVkaW8nLCBlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYW5QbGF5YmFja0F1ZGlvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdWRpb0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzIuUm9vbUV2ZW50Lk1lZGlhRGV2aWNlc0NoYW5nZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb29tVXBkYXRlID0gKHIpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEgPSByLm1ldGFkYXRhO1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlJvb21FdmVudC5Sb29tTWV0YWRhdGFDaGFuZ2VkLCByLm1ldGFkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSA9ICh1cGRhdGUpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZS51cGRhdGVzLmZvckVhY2goKGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5wYXJ0aWNpcGFudFNpZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0Q29ubmVjdGlvblF1YWxpdHkoaW5mby5xdWFsaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldChpbmZvLnBhcnRpY2lwYW50U2lkKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhbnQuc2V0Q29ubmVjdGlvblF1YWxpdHkoaW5mby5xdWFsaXR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wYXJ0aWNpcGFudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHNfMS5hdWRpb0RlZmF1bHRzKSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0c18xLnZpZGVvRGVmYXVsdHMpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMucHVibGlzaERlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0c18xLnB1Ymxpc2hEZWZhdWx0cyksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wdWJsaXNoRGVmYXVsdHMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUVuZ2luZSgpO1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQgPSBuZXcgTG9jYWxQYXJ0aWNpcGFudF8xLmRlZmF1bHQoJycsICcnLCB0aGlzLmVuZ2luZSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgY3JlYXRlRW5naW5lKCkge1xuICAgICAgICBpZiAodGhpcy5lbmdpbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZ2luZSA9IG5ldyBSVENFbmdpbmVfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZW5naW5lLmNsaWVudC5zaWduYWxMYXRlbmN5ID0gdGhpcy5vcHRpb25zLmV4cFNpZ25hbExhdGVuY3k7XG4gICAgICAgIHRoaXMuZW5naW5lLmNsaWVudC5vblBhcnRpY2lwYW50VXBkYXRlID0gdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXM7XG4gICAgICAgIHRoaXMuZW5naW5lLmNsaWVudC5vblJvb21VcGRhdGUgPSB0aGlzLmhhbmRsZVJvb21VcGRhdGU7XG4gICAgICAgIHRoaXMuZW5naW5lLmNsaWVudC5vblNwZWFrZXJzQ2hhbmdlZCA9IHRoaXMuaGFuZGxlU3BlYWtlcnNDaGFuZ2VkO1xuICAgICAgICB0aGlzLmVuZ2luZS5jbGllbnQub25TdHJlYW1TdGF0ZVVwZGF0ZSA9IHRoaXMuaGFuZGxlU3RyZWFtU3RhdGVVcGRhdGU7XG4gICAgICAgIHRoaXMuZW5naW5lLmNsaWVudC5vblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPSB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGU7XG4gICAgICAgIHRoaXMuZW5naW5lLmNsaWVudC5vbkNvbm5lY3Rpb25RdWFsaXR5ID0gdGhpcy5oYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZTtcbiAgICAgICAgdGhpcy5lbmdpbmVcbiAgICAgICAgICAgIC5vbihldmVudHNfMi5FbmdpbmVFdmVudC5NZWRpYVRyYWNrQWRkZWQsIChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihldmVudHNfMi5FbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKGV2ZW50c18yLkVuZ2luZUV2ZW50LkFjdGl2ZVNwZWFrZXJzVXBkYXRlLCB0aGlzLmhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlKVxuICAgICAgICAgICAgLm9uKGV2ZW50c18yLkVuZ2luZUV2ZW50LkRhdGFQYWNrZXRSZWNlaXZlZCwgdGhpcy5oYW5kbGVEYXRhUGFja2V0KVxuICAgICAgICAgICAgLm9uKGV2ZW50c18yLkVuZ2luZUV2ZW50LlJlc3VtaW5nLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gUm9vbVN0YXRlLlJlY29ubmVjdGluZztcbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuUmVjb25uZWN0aW5nKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihldmVudHNfMi5FbmdpbmVFdmVudC5SZXN1bWVkLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gUm9vbVN0YXRlLkNvbm5lY3RlZDtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuUmVjb25uZWN0ZWQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oZXZlbnRzXzIuRW5naW5lRXZlbnQuU2lnbmFsUmVzdW1lZCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFJvb21TdGF0ZS5SZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRTeW5jU3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihldmVudHNfMi5FbmdpbmVFdmVudC5SZXN0YXJ0aW5nLCB0aGlzLmhhbmRsZVJlc3RhcnRpbmcpXG4gICAgICAgICAgICAub24oZXZlbnRzXzIuRW5naW5lRXZlbnQuUmVzdGFydGVkLCB0aGlzLmhhbmRsZVJlc3RhcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldExvY2FsRGV2aWNlcyBhYnN0cmFjdHMgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzLlxuICAgICAqIEluIHBhcnRpY3VsYXIsIGl0IGhhbmRsZXMgQ2hyb21lJ3MgdW5pcXVlIGJlaGF2aW9yIG9mIGNyZWF0aW5nIGBkZWZhdWx0YFxuICAgICAqIGRldmljZXMuIFdoZW4gZW5jb3VudGVyZWQsIGl0J2xsIGJlIHJlbW92ZWQgZnJvbSB0aGUgbGlzdCBvZiBkZXZpY2VzLlxuICAgICAqIFRoZSBhY3R1YWwgZGVmYXVsdCBkZXZpY2Ugd2lsbCBiZSBwbGFjZWQgYXQgdG9wLlxuICAgICAqIEBwYXJhbSBraW5kXG4gICAgICogQHJldHVybnMgYSBsaXN0IG9mIGF2YWlsYWJsZSBsb2NhbCBkZXZpY2VzXG4gICAgICovXG4gICAgc3RhdGljIGdldExvY2FsRGV2aWNlcyhraW5kKSB7XG4gICAgICAgIHJldHVybiBEZXZpY2VNYW5hZ2VyXzEuZGVmYXVsdC5nZXRJbnN0YW5jZSgpLmdldERldmljZXMoa2luZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldHJpZXZlcyBhIHBhcnRpY2lwYW50IGJ5IGlkZW50aXR5XG4gICAgICogQHBhcmFtIGlkZW50aXR5XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBnZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkoaWRlbnRpdHkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbLCBwXSBvZiB0aGlzLnBhcnRpY2lwYW50cykge1xuICAgICAgICAgICAgaWYgKHAuaWRlbnRpdHkgPT09IGlkZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSA9PT0gaWRlbnRpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsUGFydGljaXBhbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIGZvciB0ZXN0aW5nXG4gICAgICovXG4gICAgc2ltdWxhdGVTY2VuYXJpbyhzY2VuYXJpbykge1xuICAgICAgICBsZXQgcmVxO1xuICAgICAgICBzd2l0Y2ggKHNjZW5hcmlvKSB7XG4gICAgICAgICAgICBjYXNlICdzcGVha2VyJzpcbiAgICAgICAgICAgICAgICByZXEgPSBsaXZla2l0X3J0Y18xLlNpbXVsYXRlU2NlbmFyaW8uZnJvbVBhcnRpYWwoe1xuICAgICAgICAgICAgICAgICAgICBzcGVha2VyVXBkYXRlOiAzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbm9kZS1mYWlsdXJlJzpcbiAgICAgICAgICAgICAgICByZXEgPSBsaXZla2l0X3J0Y18xLlNpbXVsYXRlU2NlbmFyaW8uZnJvbVBhcnRpYWwoe1xuICAgICAgICAgICAgICAgICAgICBub2RlRmFpbHVyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlcnZlci1sZWF2ZSc6XG4gICAgICAgICAgICAgICAgcmVxID0gbGl2ZWtpdF9ydGNfMS5TaW11bGF0ZVNjZW5hcmlvLmZyb21QYXJ0aWFsKHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyTGVhdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaWdyYXRpb24nOlxuICAgICAgICAgICAgICAgIHJlcSA9IGxpdmVraXRfcnRjXzEuU2ltdWxhdGVTY2VuYXJpby5mcm9tUGFydGlhbCh7XG4gICAgICAgICAgICAgICAgICAgIG1pZ3JhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRTaW11bGF0ZVNjZW5hcmlvKHJlcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvd3NlcnMgaGF2ZSBkaWZmZXJlbnQgcG9saWNpZXMgcmVnYXJkaW5nIGF1ZGlvIHBsYXliYWNrLiBNb3N0IHJlcXVpcmluZ1xuICAgICAqIHNvbWUgZm9ybSBvZiB1c2VyIGludGVyYWN0aW9uIChjbGljay90YXAvZXRjKS5cbiAgICAgKiBJbiB0aG9zZSBjYXNlcywgYXVkaW8gd2lsbCBiZSBzaWxlbnQgdW50aWwgYSBjbGljay90YXAgdHJpZ2dlcmluZyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgICAqIC0gYHN0YXJ0QXVkaW9gXG4gICAgICogLSBgZ2V0VXNlck1lZGlhYFxuICAgICAqL1xuICAgIHN0YXJ0QXVkaW8oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFjcXVpcmVBdWRpb0NvbnRleHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2lwYW50cy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgcC5hdWRpb1RyYWNrcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LnRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnRyYWNrLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKGVsZW1lbnRzLm1hcCgoZSkgPT4gZS5wbGF5KCkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkKGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGF1ZGlvIHBsYXliYWNrIGlzIGVuYWJsZWRcbiAgICAgKi9cbiAgICBnZXQgY2FuUGxheWJhY2tBdWRpbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9FbmFibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTd2l0Y2hlcyBhbGwgYWN0aXZlIGRldmljZSB1c2VkIGluIHRoaXMgcm9vbSB0byB0aGUgZ2l2ZW4gZGV2aWNlLlxuICAgICAqXG4gICAgICogTm90ZTogc2V0dGluZyBBdWRpb091dHB1dCBpcyBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMuIFNlZSBbc2V0U2lua0lkXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9zZXRTaW5rSWQjYnJvd3Nlcl9jb21wYXRpYmlsaXR5KVxuICAgICAqXG4gICAgICogQHBhcmFtIGtpbmQgdXNlIGB2aWRlb2lucHV0YCBmb3IgY2FtZXJhIHRyYWNrLFxuICAgICAqICBgYXVkaW9pbnB1dGAgZm9yIG1pY3JvcGhvbmUgdHJhY2ssXG4gICAgICogIGBhdWRpb291dHB1dGAgdG8gc2V0IHNwZWFrZXIgZm9yIGFsbCBpbmNvbWluZyBhdWRpbyB0cmFja3NcbiAgICAgKiBAcGFyYW0gZGV2aWNlSWRcbiAgICAgKi9cbiAgICBzd2l0Y2hBY3RpdmVEZXZpY2Uoa2luZCwgZGV2aWNlSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChraW5kID09PSAnYXVkaW9pbnB1dCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja3MgPSBBcnJheVxuICAgICAgICAgICAgICAgICAgICAuZnJvbSh0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9UcmFja3MudmFsdWVzKCkpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHRyYWNrKSA9PiB0cmFjay5zb3VyY2UgPT09IFRyYWNrXzEuVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHRyYWNrcy5tYXAoKHQpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdC5hdWRpb1RyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0RGV2aWNlSWQoZGV2aWNlSWQpOyB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gZGV2aWNlSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChraW5kID09PSAndmlkZW9pbnB1dCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja3MgPSBBcnJheVxuICAgICAgICAgICAgICAgICAgICAuZnJvbSh0aGlzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja3MudmFsdWVzKCkpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHRyYWNrKSA9PiB0cmFjay5zb3VyY2UgPT09IFRyYWNrXzEuVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwodHJhY2tzLm1hcCgodCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0LnZpZGVvVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXREZXZpY2VJZChkZXZpY2VJZCk7IH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtpbmQgPT09ICdhdWRpb291dHB1dCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGljaXBhbnRzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcC5hdWRpb1RyYWNrcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5pc1N1YnNjcmliZWQgJiYgdC50cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQudHJhY2suYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKGVsZW1lbnRzLm1hcCgoZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ3NldFNpbmtJZCcgaW4gZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgZS5zZXRTaW5rSWQoZGV2aWNlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gdXRpbHNfMS51bnBhY2tTdHJlYW1JZChzdHJlYW0uaWQpO1xuICAgICAgICBjb25zdCBwYXJ0aWNpcGFudElkID0gcGFydHNbMF07XG4gICAgICAgIGxldCB0cmFja0lkID0gcGFydHNbMV07XG4gICAgICAgIGlmICghdHJhY2tJZCB8fCB0cmFja0lkID09PSAnJylcbiAgICAgICAgICAgIHRyYWNrSWQgPSBtZWRpYVRyYWNrLmlkO1xuICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudChwYXJ0aWNpcGFudElkKTtcbiAgICAgICAgcGFydGljaXBhbnQuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2sobWVkaWFUcmFjaywgdHJhY2tJZCwgc3RyZWFtLCByZWNlaXZlciwgdGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtKTtcbiAgICB9XG4gICAgaGFuZGxlRGlzY29ubmVjdChzaG91bGRTdG9wVHJhY2tzID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gUm9vbVN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydGljaXBhbnRzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgIHAudHJhY2tzLmZvckVhY2goKHB1YikgPT4ge1xuICAgICAgICAgICAgICAgIHAudW5wdWJsaXNoVHJhY2socHViLnRyYWNrU2lkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnRyYWNrcy5mb3JFYWNoKChwdWIpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnVucHVibGlzaFRyYWNrKHB1Yi50cmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFRyYWNrcykge1xuICAgICAgICAgICAgICAgIChfYSA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgIChfYiA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFydGljaXBhbnRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMub25CZWZvcmVVbmxvYWQpO1xuICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RldmljZWNoYW5nZScsIHRoaXMuaGFuZGxlRGV2aWNlQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFJvb21TdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuRGlzY29ubmVjdGVkKTtcbiAgICB9XG4gICAgaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoc2lkLCBwYXJ0aWNpcGFudCkge1xuICAgICAgICAvLyByZW1vdmUgYW5kIHNlbmQgZXZlbnRcbiAgICAgICAgdGhpcy5wYXJ0aWNpcGFudHMuZGVsZXRlKHNpZCk7XG4gICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaCgocHVibGljYXRpb24pID0+IHtcbiAgICAgICAgICAgIHBhcnRpY2lwYW50LnVucHVibGlzaFRyYWNrKHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuUGFydGljaXBhbnREaXNjb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcbiAgICB9XG4gICAgYWNxdWlyZUF1ZGlvQ29udGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ5IHVzaW5nIGFuIEF1ZGlvQ29udGV4dCwgaXQgcmVkdWNlcyBsYWcgb24gYXVkaW8gZWxlbWVudHNcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTgxMTQyOS9odG1sNS1hdWRpby10YWctb24tc2FmYXJpLWhhcy1hLWRlbGF5LzU0MTE5ODU0IzU0MTE5ODU0XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xuICAgICAgICBpZiAoQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRPckNyZWF0ZVBhcnRpY2lwYW50KGlkLCBpbmZvKSB7XG4gICAgICAgIGxldCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldChpZCk7XG4gICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBSVEMgdHJhY2sgdG8gYXJyaXZlIGJlZm9yZSBzaWduYWxpbmcgZGF0YVxuICAgICAgICAgICAgLy8gd2hlbiB0aGlzIGhhcHBlbnMsIHdlJ2xsIGNyZWF0ZSB0aGUgcGFydGljaXBhbnQgYW5kIG1ha2UgdGhlIHRyYWNrIHdvcmtcbiAgICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgcGFydGljaXBhbnQgPSBSZW1vdGVQYXJ0aWNpcGFudF8xLmRlZmF1bHQuZnJvbVBhcnRpY2lwYW50SW5mbyh0aGlzLmVuZ2luZS5jbGllbnQsIGluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydGljaXBhbnQgPSBuZXcgUmVtb3RlUGFydGljaXBhbnRfMS5kZWZhdWx0KHRoaXMuZW5naW5lLmNsaWVudCwgaWQsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFydGljaXBhbnRzLnNldChpZCwgcGFydGljaXBhbnQpO1xuICAgICAgICAgICAgLy8gYWxzbyBmb3J3YXJkIGV2ZW50c1xuICAgICAgICAgICAgLy8gdHJhY2tQdWJsaXNoZWQgaXMgb25seSBmaXJlZCBmb3IgdHJhY2tzIGFkZGVkIGFmdGVyIGJvdGggbG9jYWwgcGFydGljaXBhbnRcbiAgICAgICAgICAgIC8vIGFuZCByZW1vdGUgcGFydGljaXBhbnQgam9pbmVkIHRoZSByb29tXG4gICAgICAgICAgICBwYXJ0aWNpcGFudFxuICAgICAgICAgICAgICAgIC5vbihldmVudHNfMi5QYXJ0aWNpcGFudEV2ZW50LlRyYWNrUHVibGlzaGVkLCAodHJhY2tQdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuVHJhY2tQdWJsaXNoZWQsIHRyYWNrUHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKGV2ZW50c18yLlBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpYmVkLCAodHJhY2ssIHB1YmxpY2F0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gbW9uaXRvciBwbGF5YmFjayBzdGF0dXNcbiAgICAgICAgICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2tfMS5UcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLm9uKGV2ZW50c18yLlRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja1N0YXJ0ZWQsIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5vbihldmVudHNfMi5UcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKGV2ZW50c18yLlBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCwgKHB1YmxpY2F0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlJvb21FdmVudC5UcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oZXZlbnRzXzIuUGFydGljaXBhbnRFdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgKHRyYWNrLCBwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oZXZlbnRzXzIuUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgKHNpZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHNpZCwgcGFydGljaXBhbnQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oZXZlbnRzXzIuUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCAocHViKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlJvb21FdmVudC5UcmFja011dGVkLCBwdWIsIHBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKGV2ZW50c18yLlBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbm11dGVkLCAocHViKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlJvb21FdmVudC5UcmFja1VubXV0ZWQsIHB1YiwgcGFydGljaXBhbnQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oZXZlbnRzXzIuUGFydGljaXBhbnRFdmVudC5NZXRhZGF0YUNoYW5nZWQsIChtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuTWV0YWRhdGFDaGFuZ2VkLCBtZXRhZGF0YSwgcGFydGljaXBhbnQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oZXZlbnRzXzIuUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgKG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlJvb21FdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEsIHBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKGV2ZW50c18yLlBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCAocXVhbGl0eSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5Sb29tRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5LCBwYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydGljaXBhbnQ7XG4gICAgfVxuICAgIHNlbmRTeW5jU3RhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuZW5naW5lLnN1YnNjcmliZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgfHwgdGhpcy5lbmdpbmUuc3Vic2NyaWJlci5wYy5sb2NhbERlc2NyaXB0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNTZHAgPSB0aGlzLmVuZ2luZS5zdWJzY3JpYmVyLnBjLmxvY2FsRGVzY3JpcHRpb247XG4gICAgICAgIC8qIDEuIGF1dG9zdWJzY3JpYmUgb24sIHNvIHN1YnNjcmliZWQgdHJhY2tzID0gYWxsIHRyYWNrcyAtIHVuc3ViIHRyYWNrcyxcbiAgICAgICAgICAgICAgaW4gdGhpcyBjYXNlLCB3ZSBzZW5kIHVuc3ViIHRyYWNrcywgc28gc2VydmVyIGFkZCBhbGwgdHJhY2tzIHRvIHRoaXNcbiAgICAgICAgICAgICAgc3Vic2NyaWJlIHBjIGFuZCB1bnN1YiBzcGVjaWFsIHRyYWNrcyBmcm9tIGl0LlxuICAgICAgICAgICAyLiBhdXRvc3Vic2NyaWJlIG9mZiwgd2Ugc2VuZCBzdWJzY3JpYmVkIHRyYWNrcy5cbiAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc2VuZFVuc3ViID0gKChfYSA9IHRoaXMuY29ubk9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdXRvU3Vic2NyaWJlKSB8fCBmYWxzZTtcbiAgICAgICAgY29uc3QgdHJhY2tTaWRzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMucGFydGljaXBhbnRzLmZvckVhY2goKHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgICAgICBwYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2suaXNTdWJzY3JpYmVkICE9PSBzZW5kVW5zdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tTaWRzLnB1c2godHJhY2sudHJhY2tTaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRTeW5jU3RhdGUoe1xuICAgICAgICAgICAgYW5zd2VyOiBTaWduYWxDbGllbnRfMS50b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgICAgICBzZHA6IHByZXZpb3VzU2RwLnNkcCxcbiAgICAgICAgICAgICAgICB0eXBlOiBwcmV2aW91c1NkcC50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzdWJzY3JpcHRpb246IHtcbiAgICAgICAgICAgICAgICB0cmFja1NpZHMsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlOiAhc2VuZFVuc3ViLFxuICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50VHJhY2tzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwdWJsaXNoVHJhY2tzOiB0aGlzLmxvY2FsUGFydGljaXBhbnQucHVibGlzaGVkVHJhY2tzSW5mbygpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgcmVzdW1pbmcsIHdlJ2xsIG5lZWQgdG8gbm90aWZ5IHRoZSBzZXJ2ZXIgb2YgdGhlIGN1cnJlbnRcbiAgICAgKiBzdWJzY3JpcHRpb24gc2V0dGluZ3MuXG4gICAgICovXG4gICAgdXBkYXRlU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHB1YiBvZiBwLnZpZGVvVHJhY2tzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHB1Yi5pc1N1YnNjcmliZWQgJiYgcHViIGluc3RhbmNlb2YgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHViLmVtaXRUcmFja1VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCdyb29tIGV2ZW50JywgZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUm9vbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJvb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lZGlhRGV2aWNlRmFpbHVyZSA9IGV4cG9ydHMuUHVibGlzaERhdGFFcnJvciA9IGV4cG9ydHMuVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSA9IGV4cG9ydHMuVW5zdXBwb3J0ZWRTZXJ2ZXIgPSBleHBvcnRzLlRyYWNrSW52YWxpZEVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBleHBvcnRzLkxpdmVraXRFcnJvciA9IHZvaWQgMDtcbmNsYXNzIExpdmVraXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgfHwgJ2FuIGVycm9yIGhhcyBvY2N1cmVkJyk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuZXhwb3J0cy5MaXZla2l0RXJyb3IgPSBMaXZla2l0RXJyb3I7XG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBDb25uZWN0aW9uRXJyb3I7XG5jbGFzcyBUcmFja0ludmFsaWRFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcigyMCwgbWVzc2FnZSB8fCAnVHJhY2sgaXMgaW52YWxpZCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhY2tJbnZhbGlkRXJyb3IgPSBUcmFja0ludmFsaWRFcnJvcjtcbmNsYXNzIFVuc3VwcG9ydGVkU2VydmVyIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKDEwLCBtZXNzYWdlIHx8ICdVbnN1cHBvcnRlZCBzZXJ2ZXInKTtcbiAgICB9XG59XG5leHBvcnRzLlVuc3VwcG9ydGVkU2VydmVyID0gVW5zdXBwb3J0ZWRTZXJ2ZXI7XG5jbGFzcyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKDEyLCBtZXNzYWdlIHx8ICdVbmV4cGVjdGVkIGNvbm5lY3Rpb24gc3RhdGUnKTtcbiAgICB9XG59XG5leHBvcnRzLlVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUgPSBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlO1xuY2xhc3MgUHVibGlzaERhdGFFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcigxMywgbWVzc2FnZSB8fCAnVW5hYmxlIHRvIHB1Ymxpc2ggZGF0YScpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHVibGlzaERhdGFFcnJvciA9IFB1Ymxpc2hEYXRhRXJyb3I7XG52YXIgTWVkaWFEZXZpY2VGYWlsdXJlO1xuKGZ1bmN0aW9uIChNZWRpYURldmljZUZhaWx1cmUpIHtcbiAgICAvLyB1c2VyIHJlamVjdGVkIHBlcm1pc3Npb25zXG4gICAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiUGVybWlzc2lvbkRlbmllZFwiXSA9IFwiUGVybWlzc2lvbkRlbmllZFwiO1xuICAgIC8vIGRldmljZSBpcyBub3QgYXZhaWxhYmxlXG4gICAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiTm90Rm91bmRcIl0gPSBcIk5vdEZvdW5kXCI7XG4gICAgLy8gZGV2aWNlIGlzIGluIHVzZS4gT24gV2luZG93cywgb25seSBhIHNpbmdsZSB0YWIgbWF5IGdldCBhY2Nlc3MgdG8gYSBkZXZpY2UgYXQgYSB0aW1lLlxuICAgIE1lZGlhRGV2aWNlRmFpbHVyZVtcIkRldmljZUluVXNlXCJdID0gXCJEZXZpY2VJblVzZVwiO1xuICAgIE1lZGlhRGV2aWNlRmFpbHVyZVtcIk90aGVyXCJdID0gXCJPdGhlclwiO1xufSkoTWVkaWFEZXZpY2VGYWlsdXJlID0gZXhwb3J0cy5NZWRpYURldmljZUZhaWx1cmUgfHwgKGV4cG9ydHMuTWVkaWFEZXZpY2VGYWlsdXJlID0ge30pKTtcbihmdW5jdGlvbiAoTWVkaWFEZXZpY2VGYWlsdXJlKSB7XG4gICAgZnVuY3Rpb24gZ2V0RmFpbHVyZShlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgJiYgJ25hbWUnIGluIGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdEZXZpY2VzTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLk5vdEZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdQZXJtaXNzaW9uRGVuaWVkRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5QZXJtaXNzaW9uRGVuaWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RSZWFkYWJsZUVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnVHJhY2tTdGFydEVycm9yJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuRGV2aWNlSW5Vc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLk90aGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1lZGlhRGV2aWNlRmFpbHVyZS5nZXRGYWlsdXJlID0gZ2V0RmFpbHVyZTtcbn0pKE1lZGlhRGV2aWNlRmFpbHVyZSA9IGV4cG9ydHMuTWVkaWFEZXZpY2VGYWlsdXJlIHx8IChleHBvcnRzLk1lZGlhRGV2aWNlRmFpbHVyZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYWNrRXZlbnQgPSBleHBvcnRzLkVuZ2luZUV2ZW50ID0gZXhwb3J0cy5QYXJ0aWNpcGFudEV2ZW50ID0gZXhwb3J0cy5Sb29tRXZlbnQgPSB2b2lkIDA7XG4vKipcbiAqIEV2ZW50cyBhcmUgdGhlIHByaW1hcnkgd2F5IExpdmVLaXQgbm90aWZpZXMgeW91ciBhcHBsaWNhdGlvbiBvZiBjaGFuZ2VzLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgYXJlIGV2ZW50cyBlbWl0dGVkIGJ5IFtbUm9vbV1dLCBsaXN0ZW4gdG8gcm9vbSBldmVudHMgbGlrZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHJvb20ub24oUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCAodHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCkgPT4ge30pXG4gKiBgYGBcbiAqL1xudmFyIFJvb21FdmVudDtcbihmdW5jdGlvbiAoUm9vbUV2ZW50KSB7XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIGhhcyBiZWVuIGludGVycnVwdGVkIGFuZCBpdCdzIGF0dGVtcHRpbmdcbiAgICAgKiB0byByZWNvbm5lY3QuXG4gICAgICovXG4gICAgUm9vbUV2ZW50W1wiUmVjb25uZWN0aW5nXCJdID0gXCJyZWNvbm5lY3RpbmdcIjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIGEgcmVjb25uZWN0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgUm9vbUV2ZW50W1wiUmVjb25uZWN0ZWRcIl0gPSBcInJlY29ubmVjdGVkXCI7XG4gICAgLyoqXG4gICAgICogV2hlbiBkaXNjb25uZWN0ZWQgZnJvbSByb29tLiBUaGlzIGZpcmVzIHdoZW4gcm9vbS5kaXNjb25uZWN0KCkgaXMgY2FsbGVkIG9yXG4gICAgICogd2hlbiBhbiB1bnJlY292ZXJhYmxlIGNvbm5lY3Rpb24gaXNzdWUgaGFkIG9jY3VyZWRcbiAgICAgKi9cbiAgICBSb29tRXZlbnRbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIC8qKlxuICAgICAqIFdoZW4gaW5wdXQgb3Igb3V0cHV0IGRldmljZXMgb24gdGhlIG1hY2hpbmUgaGF2ZSBjaGFuZ2VkLlxuICAgICAqL1xuICAgIFJvb21FdmVudFtcIk1lZGlhRGV2aWNlc0NoYW5nZWRcIl0gPSBcIm1lZGlhRGV2aWNlc0NoYW5nZWRcIjtcbiAgICAvKipcbiAgICAgKiBXaGVuIGEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGpvaW5zICphZnRlciogdGhlIGxvY2FsXG4gICAgICogcGFydGljaXBhbnQuIEl0IHdpbGwgbm90IGVtaXQgZXZlbnRzIGZvciBwYXJ0aWNpcGFudHMgdGhhdCBhcmUgYWxyZWFkeVxuICAgICAqIGluIHRoZSByb29tXG4gICAgICpcbiAgICAgKiBhcmdzOiAoW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgICAqL1xuICAgIFJvb21FdmVudFtcIlBhcnRpY2lwYW50Q29ubmVjdGVkXCJdID0gXCJwYXJ0aWNpcGFudENvbm5lY3RlZFwiO1xuICAgIC8qKlxuICAgICAqIFdoZW4gYSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gbGVhdmVzICphZnRlciogdGhlIGxvY2FsXG4gICAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC5cbiAgICAgKlxuICAgICAqIGFyZ3M6IChbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAgICovXG4gICAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnREaXNjb25uZWN0ZWRcIl0gPSBcInBhcnRpY2lwYW50RGlzY29ubmVjdGVkXCI7XG4gICAgLyoqXG4gICAgICogV2hlbiBhIG5ldyB0cmFjayBpcyBwdWJsaXNoZWQgdG8gcm9vbSAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuIEl0IHdpbGwgbm90IGZpcmUgZm9yIHRyYWNrcyB0aGF0IGFyZSBhbHJlYWR5IHB1Ymxpc2hlZC5cbiAgICAgKlxuICAgICAqIEEgdHJhY2sgcHVibGlzaGVkIGRvZXNuJ3QgbWVhbiB0aGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gaXQuIEl0J3NcbiAgICAgKiBzaW1wbHkgcmVmbGVjdGluZyB0aGUgc3RhdGUgb2YgdGhlIHJvb20uXG4gICAgICpcbiAgICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICAgKi9cbiAgICBSb29tRXZlbnRbXCJUcmFja1B1Ymxpc2hlZFwiXSA9IFwidHJhY2tQdWJsaXNoZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgW1tMb2NhbFBhcnRpY2lwYW50XV0gaGFzIHN1YnNjcmliZWQgdG8gYSBuZXcgdHJhY2suIFRoaXMgZXZlbnQgd2lsbCAqKmFsd2F5cyoqXG4gICAgICogZmlyZSBhcyBsb25nIGFzIG5ldyB0cmFja3MgYXJlIHJlYWR5IGZvciB1c2UuXG4gICAgICpcbiAgICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgICAqL1xuICAgIFJvb21FdmVudFtcIlRyYWNrU3Vic2NyaWJlZFwiXSA9IFwidHJhY2tTdWJzY3JpYmVkXCI7XG4gICAgLyoqXG4gICAgICogQ291bGQgbm90IHN1YnNjcmliZSB0byBhIHRyYWNrXG4gICAgICpcbiAgICAgKiBhcmdzOiAodHJhY2sgc2lkLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAgICovXG4gICAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkXCI7XG4gICAgLyoqXG4gICAgICogQSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gaGFzIHVucHVibGlzaGVkIGEgdHJhY2tcbiAgICAgKlxuICAgICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgICAqL1xuICAgIFJvb21FdmVudFtcIlRyYWNrVW5wdWJsaXNoZWRcIl0gPSBcInRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgICAvKipcbiAgICAgKiBBIHN1YnNjcmliZWQgdHJhY2sgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZS4gQ2xpZW50cyBzaG91bGQgbGlzdGVuIHRvIHRoaXNcbiAgICAgKiBldmVudCBhbmQgZW5zdXJlIHRoZXkgZGV0YWNoIHRyYWNrcy5cbiAgICAgKlxuICAgICAqIGFyZ3M6IChbW1RyYWNrXV0sIFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAgICovXG4gICAgUm9vbUV2ZW50W1wiVHJhY2tVbnN1YnNjcmliZWRcIl0gPSBcInRyYWNrVW5zdWJzY3JpYmVkXCI7XG4gICAgLyoqXG4gICAgICogQSB0cmFjayB0aGF0IHdhcyBtdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxuICAgICAqXG4gICAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1BhcnRpY2lwYW50XV0pXG4gICAgICovXG4gICAgUm9vbUV2ZW50W1wiVHJhY2tNdXRlZFwiXSA9IFwidHJhY2tNdXRlZFwiO1xuICAgIC8qKlxuICAgICAqIEEgdHJhY2sgdGhhdCB3YXMgdW5tdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxuICAgICAqXG4gICAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1BhcnRpY2lwYW50XV0pXG4gICAgICovXG4gICAgUm9vbUV2ZW50W1wiVHJhY2tVbm11dGVkXCJdID0gXCJ0cmFja1VubXV0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHRyYWNrIHdhcyBwdWJsaXNoZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vd1xuICAgICAqIHdoZW4gdG8gdXBkYXRlIHlvdXIgbG9jYWwgVUkgd2l0aCB0aGUgbmV3bHkgcHVibGlzaGVkIHRyYWNrLlxuICAgICAqXG4gICAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0sIFtbTG9jYWxQYXJ0aWNpcGFudF1dKVxuICAgICAqL1xuICAgIFJvb21FdmVudFtcIkxvY2FsVHJhY2tQdWJsaXNoZWRcIl0gPSBcImxvY2FsVHJhY2tQdWJsaXNoZWRcIjtcbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHRyYWNrIHdhcyB1bnB1Ymxpc2hlZC4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3cgd2hlbiB0byByZW1vdmVcbiAgICAgKiB0aGUgbG9jYWwgdHJhY2sgZnJvbSB5b3VyIFVJLlxuICAgICAqXG4gICAgICogV2hlbiBhIHVzZXIgc3RvcHMgc2hhcmluZyB0aGVpciBzY3JlZW4gYnkgcHJlc3NpbmcgXCJFbmRcIiBvbiB0aGUgYnJvd3NlciBVSSxcbiAgICAgKiB0aGlzIGV2ZW50IHdpbGwgYWxzbyBmaXJlLlxuICAgICAqXG4gICAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0sIFtbTG9jYWxQYXJ0aWNpcGFudF1dKVxuICAgICAqL1xuICAgIFJvb21FdmVudFtcIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1VucHVibGlzaGVkXCI7XG4gICAgLyoqXG4gICAgICogQWN0aXZlIHNwZWFrZXJzIGNoYW5nZWQuIExpc3Qgb2Ygc3BlYWtlcnMgYXJlIG9yZGVyZWQgYnkgdGhlaXIgYXVkaW8gbGV2ZWwuXG4gICAgICogbG91ZGVzdCBzcGVha2VycyBmaXJzdC4gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIExvY2FsUGFydGljaXBhbnQgdG9vLlxuICAgICAqXG4gICAgICogU3BlYWtlciB1cGRhdGVzIGFyZSBzZW50IG9ubHkgdG8gdGhlIHB1Ymxpc2hpbmcgcGFydGljaXBhbnQgYW5kIHRoZWlyIHN1YnNjcmliZXJzLlxuICAgICAqXG4gICAgICogYXJnczogKEFycmF5PFtbUGFydGljaXBhbnRdXT4pXG4gICAgICovXG4gICAgUm9vbUV2ZW50W1wiQWN0aXZlU3BlYWtlcnNDaGFuZ2VkXCJdID0gXCJhY3RpdmVTcGVha2Vyc0NoYW5nZWRcIjtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQgaW5zdGVhZFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFJvb21FdmVudFtcIk1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwibWV0YWRhdGFDaGFuZ2VkXCI7XG4gICAgLyoqXG4gICAgICogUGFydGljaXBhbnQgbWV0YWRhdGEgaXMgYSBzaW1wbGUgd2F5IGZvciBhcHAtc3BlY2lmaWMgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAgICogYWxsIHVzZXJzLlxuICAgICAqIFdoZW4gUm9vbVNlcnZpY2UuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcGFydGljaXBhbnQnc1xuICAgICAqIHN0YXRlLCAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxuICAgICAqXG4gICAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAgICpcbiAgICAgKi9cbiAgICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRNZXRhRGF0YUNoYW5nZWRcIjtcbiAgICAvKipcbiAgICAgKiBSb29tIG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgICAqIGFsbCB1c2Vycy5cbiAgICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVJvb21NZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcm9vbSdzIHN0YXRlLFxuICAgICAqICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXG4gICAgICpcbiAgICAgKiBhcmdzOiAoc3RyaW5nKVxuICAgICAqL1xuICAgIFJvb21FdmVudFtcIlJvb21NZXRhZGF0YUNoYW5nZWRcIl0gPSBcInJvb21NZXRhZGF0YUNoYW5nZWRcIjtcbiAgICAvKipcbiAgICAgKiBEYXRhIHJlY2VpdmVkIGZyb20gYW5vdGhlciBwYXJ0aWNpcGFudC5cbiAgICAgKiBEYXRhIHBhY2tldHMgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gdXNlIExpdmVLaXQgdG8gc2VuZC9yZWNlaXZlIGFyYml0cmFyeSBwYXlsb2Fkcy5cbiAgICAgKiBBbGwgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZXMgc2VudCB0byB0aGUgcm9vbS5cbiAgICAgKlxuICAgICAqIGFyZ3M6IChwYXlsb2FkOiBVaW50OEFycmF5LCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dLCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgICAqL1xuICAgIFJvb21FdmVudFtcIkRhdGFSZWNlaXZlZFwiXSA9IFwiZGF0YVJlY2VpdmVkXCI7XG4gICAgLyoqXG4gICAgICogQ29ubmVjdGlvbiBxdWFsaXR5IHdhcyBjaGFuZ2VkIGZvciBhIFBhcnRpY2lwYW50LiBJdCdsbCByZWNlaXZlIHVwZGF0ZXNcbiAgICAgKiBmcm9tIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCwgYXMgd2VsbCBhcyBhbnkgW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyB0aGF0IHdlIGFyZVxuICAgICAqIHN1YnNjcmliZWQgdG8uXG4gICAgICpcbiAgICAgKiBhcmdzOiAoY29ubmVjdGlvblF1YWxpdHk6IFtbQ29ubmVjdGlvblF1YWxpdHldXSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcbiAgICAgKi9cbiAgICBSb29tRXZlbnRbXCJDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcIl0gPSBcImNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFwiO1xuICAgIC8qKlxuICAgICAqIFN0cmVhbVN0YXRlIGluZGljYXRlcyBpZiBhIHN1YnNjcmliZWQgdHJhY2sgaGFzIGJlZW4gcGF1c2VkIGJ5IHRoZSBTRlVcbiAgICAgKiAodHlwaWNhbGx5IHRoaXMgaGFwcGVucyBiZWNhdXNlIG9mIHN1YnNjcmliZXIncyBiYW5kd2lkdGggY29uc3RyYWludHMpXG4gICAgICpcbiAgICAgKiBXaGVuIGJhbmR3aWR0aCBjb25kaXRpb25zIGFsbG93LCB0aGUgdHJhY2sgd2lsbCBiZSByZXN1bWVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICogVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQgd2lsbCBhbHNvIGJlIGVtaXR0ZWQgd2hlbiB0aGF0IGhhcHBlbnMuXG4gICAgICpcbiAgICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgc3RyZWFtU3RhdGU6IFtbVHJhY2suU3RyZWFtU3RhdGVdXSxcbiAgICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICAgKi9cbiAgICBSb29tRXZlbnRbXCJUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZFwiXSA9IFwidHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIjtcbiAgICAvKipcbiAgICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnRcbiAgICAgKiBwYXJ0aWNpcGFudC4gSWYgcGVybWlzc2lvbiB3YXMgcmV2b2tlZCwgdGhlbiB0aGUgdHJhY2sgd2lsbCBubyBsb25nZXJcbiAgICAgKiBiZSBzdWJzY3JpYmVkLiBJZiBwZXJtaXNzaW9uIHdhcyBncmFudGVkLCBhIFRyYWNrU3Vic2NyaWJlZCBldmVudCB3aWxsXG4gICAgICogYmUgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxuICAgICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXNdXSxcbiAgICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICAgKi9cbiAgICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCI7XG4gICAgLyoqXG4gICAgICogTGl2ZUtpdCB3aWxsIGF0dGVtcHQgdG8gYXV0b3BsYXkgYWxsIGF1ZGlvIHRyYWNrcyB3aGVuIHlvdSBhdHRhY2ggdGhlbSB0b1xuICAgICAqIGF1ZGlvIGVsZW1lbnRzLiBIb3dldmVyLCBpZiB0aGF0IGZhaWxzLCB3ZSdsbCBub3RpZnkgeW91IHZpYSBBdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZC5cbiAgICAgKiBgUm9vbS5jYW5QbGF5QXVkaW9gIHdpbGwgaW5kaWNhdGUgaWYgYXVkaW8gcGxheWJhY2sgaXMgcGVybWl0dGVkLlxuICAgICAqL1xuICAgIFJvb21FdmVudFtcIkF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkXCJdID0gXCJhdWRpb1BsYXliYWNrQ2hhbmdlZFwiO1xuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgaGF2ZSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBhIHRyYWNrLlxuICAgICAqIFRoZSBlcnJvcnMgdGFrZSBwbGFjZSBpbiBnZXRVc2VyTWVkaWEoKS5cbiAgICAgKiBVc2UgTWVkaWFEZXZpY2VGYWlsdXJlLmdldEZhaWx1cmUoZXJyb3IpIHRvIGdldCB0aGUgcmVhc29uIG9mIGZhaWx1cmUuXG4gICAgICogW1tnZXRBdWRpb0NyZWF0ZUVycm9yXV0gYW5kIFtbZ2V0VmlkZW9DcmVhdGVFcnJvcl1dIHdpbGwgaW5kaWNhdGUgaWYgaXQgaGFkXG4gICAgICogYW4gZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIGF1ZGlvIG9yIHZpZGVvIHRyYWNrIHJlc3BlY3RpdmVseS5cbiAgICAgKlxuICAgICAqIGFyZ3M6IChlcnJvcjogRXJyb3IpXG4gICAgICovXG4gICAgUm9vbUV2ZW50W1wiTWVkaWFEZXZpY2VzRXJyb3JcIl0gPSBcIm1lZGlhRGV2aWNlc0Vycm9yXCI7XG59KShSb29tRXZlbnQgPSBleHBvcnRzLlJvb21FdmVudCB8fCAoZXhwb3J0cy5Sb29tRXZlbnQgPSB7fSkpO1xudmFyIFBhcnRpY2lwYW50RXZlbnQ7XG4oZnVuY3Rpb24gKFBhcnRpY2lwYW50RXZlbnQpIHtcbiAgICAvKipcbiAgICAgKiBXaGVuIGEgbmV3IHRyYWNrIGlzIHB1Ymxpc2hlZCB0byByb29tICphZnRlciogdGhlIGxvY2FsXG4gICAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC4gSXQgd2lsbCBub3QgZmlyZSBmb3IgdHJhY2tzIHRoYXQgYXJlIGFscmVhZHkgcHVibGlzaGVkLlxuICAgICAqXG4gICAgICogQSB0cmFjayBwdWJsaXNoZWQgZG9lc24ndCBtZWFuIHRoZSBwYXJ0aWNpcGFudCBoYXMgc3Vic2NyaWJlZCB0byBpdC4gSXQnc1xuICAgICAqIHNpbXBseSByZWZsZWN0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgcm9vbS5cbiAgICAgKlxuICAgICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcbiAgICAgKi9cbiAgICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tQdWJsaXNoZWRcIl0gPSBcInRyYWNrUHVibGlzaGVkXCI7XG4gICAgLyoqXG4gICAgICogU3VjY2Vzc2Z1bGx5IHN1YnNjcmliZWQgdG8gdGhlIFtbUmVtb3RlUGFydGljaXBhbnRdXSdzIHRyYWNrLlxuICAgICAqIFRoaXMgZXZlbnQgd2lsbCAqKmFsd2F5cyoqIGZpcmUgYXMgbG9uZyBhcyBuZXcgdHJhY2tzIGFyZSByZWFkeSBmb3IgdXNlLlxuICAgICAqXG4gICAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAgICovXG4gICAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaWJlZFwiXSA9IFwidHJhY2tTdWJzY3JpYmVkXCI7XG4gICAgLyoqXG4gICAgICogQ291bGQgbm90IHN1YnNjcmliZSB0byBhIHRyYWNrXG4gICAgICpcbiAgICAgKiBhcmdzOiAodHJhY2sgc2lkKVxuICAgICAqL1xuICAgIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcIjtcbiAgICAvKipcbiAgICAgKiBBIFtbUmVtb3RlUGFydGljaXBhbnRdXSBoYXMgdW5wdWJsaXNoZWQgYSB0cmFja1xuICAgICAqXG4gICAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgICAqL1xuICAgIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1VucHVibGlzaGVkXCJdID0gXCJ0cmFja1VucHVibGlzaGVkXCI7XG4gICAgLyoqXG4gICAgICogQSBzdWJzY3JpYmVkIHRyYWNrIGlzIG5vIGxvbmdlciBhdmFpbGFibGUuIENsaWVudHMgc2hvdWxkIGxpc3RlbiB0byB0aGlzXG4gICAgICogZXZlbnQgYW5kIGVuc3VyZSB0aGV5IGRldGFjaCB0cmFja3MuXG4gICAgICpcbiAgICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcbiAgICAgKi9cbiAgICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tVbnN1YnNjcmliZWRcIl0gPSBcInRyYWNrVW5zdWJzY3JpYmVkXCI7XG4gICAgLyoqXG4gICAgICogQSB0cmFjayB0aGF0IHdhcyBtdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxuICAgICAqXG4gICAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgICAqL1xuICAgIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja011dGVkXCJdID0gXCJ0cmFja011dGVkXCI7XG4gICAgLyoqXG4gICAgICogQSB0cmFjayB0aGF0IHdhcyB1bm11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAgICpcbiAgICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAgICovXG4gICAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5tdXRlZFwiXSA9IFwidHJhY2tVbm11dGVkXCI7XG4gICAgLyoqXG4gICAgICogQSBsb2NhbCB0cmFjayB3YXMgcHVibGlzaGVkIHN1Y2Nlc3NmdWxseS4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3dcbiAgICAgKiB3aGVuIHRvIHVwZGF0ZSB5b3VyIGxvY2FsIFVJIHdpdGggdGhlIG5ld2x5IHB1Ymxpc2hlZCB0cmFjay5cbiAgICAgKlxuICAgICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgICAqL1xuICAgIFBhcnRpY2lwYW50RXZlbnRbXCJMb2NhbFRyYWNrUHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrUHVibGlzaGVkXCI7XG4gICAgLyoqXG4gICAgICogQSBsb2NhbCB0cmFjayB3YXMgdW5wdWJsaXNoZWQuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93IHdoZW4gdG8gcmVtb3ZlXG4gICAgICogdGhlIGxvY2FsIHRyYWNrIGZyb20geW91ciBVSS5cbiAgICAgKlxuICAgICAqIFdoZW4gYSB1c2VyIHN0b3BzIHNoYXJpbmcgdGhlaXIgc2NyZWVuIGJ5IHByZXNzaW5nIFwiRW5kXCIgb24gdGhlIGJyb3dzZXIgVUksXG4gICAgICogdGhpcyBldmVudCB3aWxsIGFsc28gZmlyZS5cbiAgICAgKlxuICAgICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgICAqL1xuICAgIFBhcnRpY2lwYW50RXZlbnRbXCJMb2NhbFRyYWNrVW5wdWJsaXNoZWRcIl0gPSBcImxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCBpbnN0ZWFkXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgUGFydGljaXBhbnRFdmVudFtcIk1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwibWV0YWRhdGFDaGFuZ2VkXCI7XG4gICAgLyoqXG4gICAgICogUGFydGljaXBhbnQgbWV0YWRhdGEgaXMgYSBzaW1wbGUgd2F5IGZvciBhcHAtc3BlY2lmaWMgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAgICogYWxsIHVzZXJzLlxuICAgICAqIFdoZW4gUm9vbVNlcnZpY2UuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcGFydGljaXBhbnQnc1xuICAgICAqIHN0YXRlLCAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxuICAgICAqIFRvIGFjY2VzcyB0aGUgY3VycmVudCBtZXRhZGF0YSwgc2VlIFtbUGFydGljaXBhbnQubWV0YWRhdGFdXS5cbiAgICAgKlxuICAgICAqIGFyZ3M6IChwcmV2TWV0YWRhdGE6IHN0cmluZylcbiAgICAgKlxuICAgICAqL1xuICAgIFBhcnRpY2lwYW50RXZlbnRbXCJQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWRcIjtcbiAgICAvKipcbiAgICAgKiBEYXRhIHJlY2VpdmVkIGZyb20gdGhpcyBwYXJ0aWNpcGFudCBhcyBzZW5kZXIuXG4gICAgICogRGF0YSBwYWNrZXRzIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIHVzZSBMaXZlS2l0IHRvIHNlbmQvcmVjZWl2ZSBhcmJpdHJhcnkgcGF5bG9hZHMuXG4gICAgICogQWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIHJlY2VpdmUgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIHJvb20uXG4gICAgICpcbiAgICAgKiBhcmdzOiAocGF5bG9hZDogVWludDhBcnJheSwga2luZDogW1tEYXRhUGFja2V0X0tpbmRdXSlcbiAgICAgKi9cbiAgICBQYXJ0aWNpcGFudEV2ZW50W1wiRGF0YVJlY2VpdmVkXCJdID0gXCJkYXRhUmVjZWl2ZWRcIjtcbiAgICAvKipcbiAgICAgKiBIYXMgc3BlYWtpbmcgc3RhdHVzIGNoYW5nZWQgZm9yIHRoZSBjdXJyZW50IHBhcnRpY2lwYW50XG4gICAgICpcbiAgICAgKiBhcmdzOiAoc3BlYWtpbmc6IGJvb2xlYW4pXG4gICAgICovXG4gICAgUGFydGljaXBhbnRFdmVudFtcIklzU3BlYWtpbmdDaGFuZ2VkXCJdID0gXCJpc1NwZWFraW5nQ2hhbmdlZFwiO1xuICAgIC8qKlxuICAgICAqIENvbm5lY3Rpb24gcXVhbGl0eSB3YXMgY2hhbmdlZCBmb3IgYSBQYXJ0aWNpcGFudC4gSXQnbGwgcmVjZWl2ZSB1cGRhdGVzXG4gICAgICogZnJvbSB0aGUgbG9jYWwgcGFydGljaXBhbnQsIGFzIHdlbGwgYXMgYW55IFtbUmVtb3RlUGFydGljaXBhbnRdXXMgdGhhdCB3ZSBhcmVcbiAgICAgKiBzdWJzY3JpYmVkIHRvLlxuICAgICAqXG4gICAgICogYXJnczogKGNvbm5lY3Rpb25RdWFsaXR5OiBbW0Nvbm5lY3Rpb25RdWFsaXR5XV0pXG4gICAgICovXG4gICAgUGFydGljaXBhbnRFdmVudFtcIkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCI7XG4gICAgLyoqXG4gICAgICogU3RyZWFtU3RhdGUgaW5kaWNhdGVzIGlmIGEgc3Vic2NyaWJlZCB0cmFjayBoYXMgYmVlbiBwYXVzZWQgYnkgdGhlIFNGVVxuICAgICAqICh0eXBpY2FsbHkgdGhpcyBoYXBwZW5zIGJlY2F1c2Ugb2Ygc3Vic2NyaWJlcidzIGJhbmR3aWR0aCBjb25zdHJhaW50cylcbiAgICAgKlxuICAgICAqIFdoZW4gYmFuZHdpZHRoIGNvbmRpdGlvbnMgYWxsb3csIHRoZSB0cmFjayB3aWxsIGJlIHJlc3VtZWQgYXV0b21hdGljYWxseS5cbiAgICAgKiBUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCB3aWxsIGFsc28gYmUgZW1pdHRlZCB3aGVuIHRoYXQgaGFwcGVucy5cbiAgICAgKlxuICAgICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBzdHJlYW1TdGF0ZTogW1tUcmFjay5TdHJlYW1TdGF0ZV1dKVxuICAgICAqL1xuICAgIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZFwiXSA9IFwidHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIjtcbiAgICAvKipcbiAgICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnRcbiAgICAgKiBwYXJ0aWNpcGFudC4gSWYgcGVybWlzc2lvbiB3YXMgcmV2b2tlZCwgdGhlbiB0aGUgdHJhY2sgd2lsbCBubyBsb25nZXJcbiAgICAgKiBiZSBzdWJzY3JpYmVkLiBJZiBwZXJtaXNzaW9uIHdhcyBncmFudGVkLCBhIFRyYWNrU3Vic2NyaWJlZCBldmVudCB3aWxsXG4gICAgICogYmUgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxuICAgICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXNdXSlcbiAgICAgKi9cbiAgICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiO1xuICAgIC8vIGZpcmVkIG9ubHkgb24gTG9jYWxQYXJ0aWNpcGFudFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBQYXJ0aWNpcGFudEV2ZW50W1wiTWVkaWFEZXZpY2VzRXJyb3JcIl0gPSBcIm1lZGlhRGV2aWNlc0Vycm9yXCI7XG59KShQYXJ0aWNpcGFudEV2ZW50ID0gZXhwb3J0cy5QYXJ0aWNpcGFudEV2ZW50IHx8IChleHBvcnRzLlBhcnRpY2lwYW50RXZlbnQgPSB7fSkpO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIEVuZ2luZUV2ZW50O1xuKGZ1bmN0aW9uIChFbmdpbmVFdmVudCkge1xuICAgIEVuZ2luZUV2ZW50W1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgICBFbmdpbmVFdmVudFtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gICAgRW5naW5lRXZlbnRbXCJSZXN1bWluZ1wiXSA9IFwicmVzdW1pbmdcIjtcbiAgICBFbmdpbmVFdmVudFtcIlJlc3VtZWRcIl0gPSBcInJlc3VtZWRcIjtcbiAgICBFbmdpbmVFdmVudFtcIlJlc3RhcnRpbmdcIl0gPSBcInJlc3RhcnRpbmdcIjtcbiAgICBFbmdpbmVFdmVudFtcIlJlc3RhcnRlZFwiXSA9IFwicmVzdGFydGVkXCI7XG4gICAgRW5naW5lRXZlbnRbXCJTaWduYWxSZXN1bWVkXCJdID0gXCJzaWduYWxSZXN1bWVkXCI7XG4gICAgRW5naW5lRXZlbnRbXCJNZWRpYVRyYWNrQWRkZWRcIl0gPSBcIm1lZGlhVHJhY2tBZGRlZFwiO1xuICAgIEVuZ2luZUV2ZW50W1wiQWN0aXZlU3BlYWtlcnNVcGRhdGVcIl0gPSBcImFjdGl2ZVNwZWFrZXJzVXBkYXRlXCI7XG4gICAgRW5naW5lRXZlbnRbXCJEYXRhUGFja2V0UmVjZWl2ZWRcIl0gPSBcImRhdGFQYWNrZXRSZWNlaXZlZFwiO1xufSkoRW5naW5lRXZlbnQgPSBleHBvcnRzLkVuZ2luZUV2ZW50IHx8IChleHBvcnRzLkVuZ2luZUV2ZW50ID0ge30pKTtcbnZhciBUcmFja0V2ZW50O1xuKGZ1bmN0aW9uIChUcmFja0V2ZW50KSB7XG4gICAgVHJhY2tFdmVudFtcIk1lc3NhZ2VcIl0gPSBcIm1lc3NhZ2VcIjtcbiAgICBUcmFja0V2ZW50W1wiTXV0ZWRcIl0gPSBcIm11dGVkXCI7XG4gICAgVHJhY2tFdmVudFtcIlVubXV0ZWRcIl0gPSBcInVubXV0ZWRcIjtcbiAgICBUcmFja0V2ZW50W1wiRW5kZWRcIl0gPSBcImVuZGVkXCI7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFRyYWNrRXZlbnRbXCJVcGRhdGVTZXR0aW5nc1wiXSA9IFwidXBkYXRlU2V0dGluZ3NcIjtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgVHJhY2tFdmVudFtcIlVwZGF0ZVN1YnNjcmlwdGlvblwiXSA9IFwidXBkYXRlU3Vic2NyaXB0aW9uXCI7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFRyYWNrRXZlbnRbXCJBdWRpb1BsYXliYWNrU3RhcnRlZFwiXSA9IFwiYXVkaW9QbGF5YmFja1N0YXJ0ZWRcIjtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgVHJhY2tFdmVudFtcIkF1ZGlvUGxheWJhY2tGYWlsZWRcIl0gPSBcImF1ZGlvUGxheWJhY2tGYWlsZWRcIjtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgVHJhY2tFdmVudFtcIlZpc2liaWxpdHlDaGFuZ2VkXCJdID0gXCJ2aXNpYmlsaXR5Q2hhbmdlZFwiO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBUcmFja0V2ZW50W1wiVmlkZW9EaW1lbnNpb25zQ2hhbmdlZFwiXSA9IFwidmlkZW9EaW1lbnNpb25zQ2hhbmdlZFwiO1xufSkoVHJhY2tFdmVudCA9IGV4cG9ydHMuVHJhY2tFdmVudCB8fCAoZXhwb3J0cy5UcmFja0V2ZW50ID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBsb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbG9nZ2VyXCIpKTtcbmNvbnN0IGxpdmVraXRfcnRjXzEgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbGl2ZWtpdF9ydGNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCIuLi9ldmVudHNcIik7XG5jb25zdCBMb2NhbEF1ZGlvVHJhY2tfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vdHJhY2svTG9jYWxBdWRpb1RyYWNrXCIpKTtcbmNvbnN0IExvY2FsVHJhY2tQdWJsaWNhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi90cmFjay9Mb2NhbFRyYWNrUHVibGljYXRpb25cIikpO1xuY29uc3QgTG9jYWxWaWRlb1RyYWNrXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3RyYWNrL0xvY2FsVmlkZW9UcmFja1wiKSk7XG5jb25zdCBvcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhY2svb3B0aW9uc1wiKTtcbmNvbnN0IFRyYWNrXzEgPSByZXF1aXJlKFwiLi4vdHJhY2svVHJhY2tcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3RyYWNrL3V0aWxzXCIpO1xuY29uc3QgUGFydGljaXBhbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9QYXJ0aWNpcGFudFwiKSk7XG5jb25zdCBQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbl8xID0gcmVxdWlyZShcIi4vUGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25cIik7XG5jb25zdCBwdWJsaXNoVXRpbHNfMSA9IHJlcXVpcmUoXCIuL3B1Ymxpc2hVdGlsc1wiKTtcbmNvbnN0IFJlbW90ZVBhcnRpY2lwYW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUmVtb3RlUGFydGljaXBhbnRcIikpO1xuY2xhc3MgTG9jYWxQYXJ0aWNpcGFudCBleHRlbmRzIFBhcnRpY2lwYW50XzEuZGVmYXVsdCB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdG9yKHNpZCwgaWRlbnRpdHksIGVuZ2luZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihzaWQsIGlkZW50aXR5KTtcbiAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLm9uVHJhY2tVbm11dGVkID0gKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uVHJhY2tNdXRlZCh0cmFjaywgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvLyB3aGVuIHRoZSBsb2NhbCB0cmFjayBjaGFuZ2VzIGluIG11dGUgc3RhdHVzLCB3ZSdsbCBub3RpZnkgc2VydmVyIGFzIHN1Y2hcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLm9uVHJhY2tNdXRlZCA9ICh0cmFjaywgbXV0ZWQpID0+IHtcbiAgICAgICAgICAgIGlmIChtdXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbXV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0cmFjay5zaWQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmVycm9yKCdjb3VsZCBub3QgdXBkYXRlIG11dGUgc3RhdHVzIGZvciB1bnB1Ymxpc2hlZCB0cmFjaycsIHRyYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS51cGRhdGVNdXRlU3RhdHVzKHRyYWNrLnNpZCwgbXV0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gKHVwZGF0ZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICghKChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5keW5hY2FzdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwdWIgPSB0aGlzLnZpZGVvVHJhY2tzLmdldCh1cGRhdGUudHJhY2tTaWQpO1xuICAgICAgICAgICAgaWYgKCFwdWIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0Lndhcm4oJ2hhbmRsZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlJywgJ3JlY2VpdmVkIHN1YnNjcmliZWQgcXVhbGl0eSB1cGRhdGUgZm9yIHVua25vd24gdHJhY2snLCB1cGRhdGUudHJhY2tTaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IHB1Yi52aWRlb1RyYWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2V0UHVibGlzaGluZ0xheWVycyh1cGRhdGUuc3Vic2NyaWJlZFF1YWxpdGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25UcmFja1VucHVibGlzaCA9ICh0cmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXVkaW9UcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudmlkZW9UcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudHJhY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgdGhpcy5yb29tT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuZW5naW5lLmNsaWVudC5vblJlbW90ZU11dGVDaGFuZ2VkID0gKHRyYWNrU2lkLCBtdXRlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHViID0gdGhpcy50cmFja3MuZ2V0KHRyYWNrU2lkKTtcbiAgICAgICAgICAgIGlmICghcHViIHx8ICFwdWIudHJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXV0ZWQpIHtcbiAgICAgICAgICAgICAgICBwdWIubXV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHViLnVubXV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVuZ2luZS5jbGllbnQub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IHRoaXMuaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGU7XG4gICAgfVxuICAgIGdldCBsYXN0Q2FtZXJhRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbWVyYUVycm9yO1xuICAgIH1cbiAgICBnZXQgbGFzdE1pY3JvcGhvbmVFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWljcm9waG9uZUVycm9yO1xuICAgIH1cbiAgICBnZXRUcmFjayhzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFjayhzb3VyY2UpO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUcmFja0J5TmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tCeU5hbWUobmFtZSk7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGEgcGFydGljaXBhbnQncyBjYW1lcmEgdHJhY2suXG4gICAgICpcbiAgICAgKiBJZiBhIHRyYWNrIGhhcyBhbHJlYWR5IHB1Ymxpc2hlZCwgaXQnbGwgbXV0ZSBvciB1bm11dGUgdGhlIHRyYWNrLlxuICAgICAqL1xuICAgIHNldENhbWVyYUVuYWJsZWQoZW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRUcmFja0VuYWJsZWQoVHJhY2tfMS5UcmFjay5Tb3VyY2UuQ2FtZXJhLCBlbmFibGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgYSBwYXJ0aWNpcGFudCdzIG1pY3JvcGhvbmUgdHJhY2suXG4gICAgICpcbiAgICAgKiBJZiBhIHRyYWNrIGhhcyBhbHJlYWR5IHB1Ymxpc2hlZCwgaXQnbGwgbXV0ZSBvciB1bm11dGUgdGhlIHRyYWNrLlxuICAgICAqL1xuICAgIHNldE1pY3JvcGhvbmVFbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VHJhY2tFbmFibGVkKFRyYWNrXzEuVHJhY2suU291cmNlLk1pY3JvcGhvbmUsIGVuYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBvciBzdG9wIHNoYXJpbmcgYSBwYXJ0aWNpcGFudCdzIHNjcmVlblxuICAgICAqL1xuICAgIHNldFNjcmVlblNoYXJlRW5hYmxlZChlbmFibGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFja18xLlRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgZW5hYmxlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHB1Ymxpc2hpbmcgZm9yIGEgdHJhY2sgYnkgc291cmNlLiBUaGlzIHNlcnZlcyBhcyBhIHNpbXBsZVxuICAgICAqIHdheSB0byBtYW5hZ2UgdGhlIGNvbW1vbiB0cmFja3MgKGNhbWVyYSwgbWljLCBvciBzY3JlZW4gc2hhcmUpXG4gICAgICovXG4gICAgc2V0VHJhY2tFbmFibGVkKHNvdXJjZSwgZW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZWJ1Zygnc2V0VHJhY2tFbmFibGVkJywgc291cmNlLCBlbmFibGVkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy5nZXRUcmFjayhzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdHJhY2sudW5tdXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbG9jYWxUcmFjaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuaW5mbygnc2tpcHBpbmcgZHVwbGljYXRlIHB1Ymxpc2hlZCBzb3VyY2UnLCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8tb3AgaXQncyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmFja18xLlRyYWNrLlNvdXJjZS5DYW1lcmE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtsb2NhbFRyYWNrXSA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmFja18xLlRyYWNrLlNvdXJjZS5NaWNyb3Bob25lOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbG9jYWxUcmFja10gPSB5aWVsZCB0aGlzLmNyZWF0ZVRyYWNrcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdWRpbzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhY2tfMS5UcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtsb2NhbFRyYWNrXSA9IHlpZWxkIHRoaXMuY3JlYXRlU2NyZWVuVHJhY2tzKHsgYXVkaW86IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVHJhY2tJbnZhbGlkRXJyb3Ioc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucHVibGlzaFRyYWNrKGxvY2FsVHJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmICEoZSBpbnN0YW5jZW9mIGVycm9yc18xLlRyYWNrSW52YWxpZEVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMS5QYXJ0aWNpcGFudEV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJhY2sgJiYgdHJhY2sudHJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBzY3JlZW5zaGFyZSBjYW5ub3QgYmUgbXV0ZWQsIHVucHVibGlzaCBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gVHJhY2tfMS5UcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjay50cmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0cmFjay5tdXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaCBib3RoIGNhbWVyYSBhbmQgbWljcm9waG9uZSBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICAgKiBkaXNwbGF5aW5nIGEgc2luZ2xlIFBlcm1pc3Npb24gRGlhbG9nIGJveCB0byB0aGUgZW5kIHVzZXIuXG4gICAgICovXG4gICAgZW5hYmxlQ2FtZXJhQW5kTWljcm9waG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmhhcyhUcmFja18xLlRyYWNrLlNvdXJjZS5DYW1lcmEpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoVHJhY2tfMS5UcmFjay5Tb3VyY2UuTWljcm9waG9uZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBuby1vcCBpdCdzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmFkZChUcmFja18xLlRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoVHJhY2tfMS5UcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHRyYWNrcy5tYXAoKHRyYWNrKSA9PiB0aGlzLnB1Ymxpc2hUcmFjayh0cmFjaykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKFRyYWNrXzEuVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5kZWxldGUoVHJhY2tfMS5UcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgbG9jYWwgY2FtZXJhIGFuZC9vciBtaWNyb3Bob25lIHRyYWNrc1xuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBjcmVhdGVUcmFja3Mob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IHV0aWxzXzEubWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCAoX2EgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXVkaW9DYXB0dXJlRGVmYXVsdHMsIChfYiA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52aWRlb0NhcHR1cmVEZWZhdWx0cyk7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHV0aWxzXzEuY29uc3RyYWludHNGb3JPcHRpb25zKG9wdHMpO1xuICAgICAgICAgICAgbGV0IHN0cmVhbTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludHMuYXVkaW8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWljcm9waG9uZUVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50cy52aWRlbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uc3RyYWludHMuYXVkaW8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pY3JvcGhvbmVFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50cy52aWRlbykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtLmdldFRyYWNrcygpLm1hcCgobWVkaWFTdHJlYW1UcmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXVkaW8gPSBtZWRpYVN0cmVhbVRyYWNrLmtpbmQgPT09ICdhdWRpbyc7XG4gICAgICAgICAgICAgICAgbGV0IHRyYWNrT3B0aW9ucyA9IGlzQXVkaW8gPyBvcHRpb25zLmF1ZGlvIDogb3B0aW9ucy52aWRlbztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyYWNrT3B0aW9ucyA9PT0gJ2Jvb2xlYW4nIHx8ICF0cmFja09wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tPcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0cmFja0NvbnN0cmFpbnRzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbk9yQm9vbCA9IGlzQXVkaW8gPyBjb25zdHJhaW50cy5hdWRpbyA6IGNvbnN0cmFpbnRzLnZpZGVvO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uT3JCb29sICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tDb25zdHJhaW50cyA9IGNvbk9yQm9vbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2sgPSBwdWJsaXNoVXRpbHNfMS5tZWRpYVRyYWNrVG9Mb2NhbFRyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIHRyYWNrQ29uc3RyYWludHMpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFja18xLlRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2tfMS5UcmFjay5Tb3VyY2UuQ2FtZXJhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFja18xLlRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2tfMS5UcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2NyZWVuIGNhcHR1cmUgdHJhY2tzIHdpdGggZ2V0RGlzcGxheU1lZGlhKCkuXG4gICAgICogQSBMb2NhbFZpZGVvVHJhY2sgaXMgYWx3YXlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICAgICAqIElmIHsgYXVkaW86IHRydWUgfSwgYW5kIHRoZSBicm93c2VyIHN1cHBvcnRzIGF1ZGlvIGNhcHR1cmUsIGEgTG9jYWxBdWRpb1RyYWNrIGlzIGFsc28gY3JlYXRlZC5cbiAgICAgKi9cbiAgICBjcmVhdGVTY3JlZW5UcmFja3Mob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZXNvbHV0aW9uID0gb3B0aW9uc18xLlZpZGVvUHJlc2V0cy5maGQucmVzb2x1dGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2aWRlb0NvbnN0cmFpbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24pIHtcbiAgICAgICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzID0ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lUmF0ZTogb3B0aW9ucy5yZXNvbHV0aW9uLmZyYW1lUmF0ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHlwZXNjcmlwdCBkZWZpbml0aW9uIGlzIG1pc3NpbmcgZ2V0RGlzcGxheU1lZGlhOiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzMzMjMyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSh7XG4gICAgICAgICAgICAgICAgYXVkaW86IChfYSA9IG9wdGlvbnMuYXVkaW8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZpZGVvOiB2aWRlb0NvbnN0cmFpbnRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgICAgIGlmICh0cmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlRyYWNrSW52YWxpZEVycm9yKCdubyB2aWRlbyB0cmFjayBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2NyZWVuVmlkZW8gPSBuZXcgTG9jYWxWaWRlb1RyYWNrXzEuZGVmYXVsdCh0cmFja3NbMF0pO1xuICAgICAgICAgICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2tfMS5UcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFRyYWNrcyA9IFtzY3JlZW5WaWRlb107XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlbkF1ZGlvID0gbmV3IExvY2FsQXVkaW9UcmFja18xLmRlZmF1bHQoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0pO1xuICAgICAgICAgICAgICAgIHNjcmVlbkF1ZGlvLnNvdXJjZSA9IFRyYWNrXzEuVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW87XG4gICAgICAgICAgICAgICAgbG9jYWxUcmFja3MucHVzaChzY3JlZW5BdWRpbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxUcmFja3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGEgbmV3IHRyYWNrIHRvIHRoZSByb29tXG4gICAgICogQHBhcmFtIHRyYWNrXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBwdWJsaXNoVHJhY2sodHJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgcmF3IG1lZGlhIHRyYWNrIGludG8gYXVkaW8gb3IgdmlkZW8gdHJhY2tcbiAgICAgICAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRyYWNrLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2sgPSBuZXcgTG9jYWxBdWRpb1RyYWNrXzEuZGVmYXVsdCh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2sgPSBuZXcgTG9jYWxWaWRlb1RyYWNrXzEuZGVmYXVsdCh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5UcmFja0ludmFsaWRFcnJvcihgdW5zdXBwb3J0ZWQgTWVkaWFTdHJlYW1UcmFjayBraW5kICR7dHJhY2sua2luZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpcyBpdCBhbHJlYWR5IHB1Ymxpc2hlZD8gaWYgc28gc2tpcFxuICAgICAgICAgICAgbGV0IGV4aXN0aW5nUHVibGljYXRpb247XG4gICAgICAgICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHVibGljYXRpb24udHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHVibGljYXRpb24udHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nUHVibGljYXRpb24gPSBwdWJsaWNhdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1B1YmxpY2F0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ1B1YmxpY2F0aW9uO1xuICAgICAgICAgICAgaWYgKG9wdHMuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdHJhY2suc291cmNlID0gb3B0cy5zb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5zdG9wTWljVHJhY2tPbk11dGUgJiYgdHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2tfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdHJhY2suc3RvcE9uTXV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgdHJhY2sgYWN0aW9uc1xuICAgICAgICAgICAgdHJhY2sub24oZXZlbnRzXzEuVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5vblRyYWNrTXV0ZWQpO1xuICAgICAgICAgICAgdHJhY2sub24oZXZlbnRzXzEuVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLm9uVHJhY2tVbm11dGVkKTtcbiAgICAgICAgICAgIHRyYWNrLm9uKGV2ZW50c18xLlRyYWNrRXZlbnQuRW5kZWQsIHRoaXMub25UcmFja1VucHVibGlzaCk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgdHJhY2sgcHVibGljYXRpb24gZnJvbSB0cmFja1xuICAgICAgICAgICAgY29uc3QgcmVxID0gbGl2ZWtpdF9ydGNfMS5BZGRUcmFja1JlcXVlc3QuZnJvbVBhcnRpYWwoe1xuICAgICAgICAgICAgICAgIC8vIGdldCBsb2NhbCB0cmFjayBpZCBmb3IgdXNlIGR1cmluZyBwdWJsaXNoaW5nXG4gICAgICAgICAgICAgICAgY2lkOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IFRyYWNrXzEuVHJhY2sua2luZFRvUHJvdG8odHJhY2sua2luZCksXG4gICAgICAgICAgICAgICAgbXV0ZWQ6IHRyYWNrLmlzTXV0ZWQsXG4gICAgICAgICAgICAgICAgc291cmNlOiBUcmFja18xLlRyYWNrLnNvdXJjZVRvUHJvdG8odHJhY2suc291cmNlKSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlRHR4OiAhKChfYiA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5kdHgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBjb21wdXRlIGVuY29kaW5ncyBhbmQgbGF5ZXJzIGZvciB2aWRlb1xuICAgICAgICAgICAgbGV0IGVuY29kaW5ncztcbiAgICAgICAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFja18xLlRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IHJlYWN0IG5hdGl2ZSwgd2hpY2ggZG9lc24ndCBleHBvc2UgZ2V0U2V0dGluZ3NcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IChfYyA9IHNldHRpbmdzLndpZHRoKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2QgPSB0cmFjay5kaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Qud2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gKF9lID0gc2V0dGluZ3MuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAoX2YgPSB0cmFjay5kaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgc2hvdWxkIGJlIGRlZmluZWQgZm9yIHZpZGVvXG4gICAgICAgICAgICAgICAgcmVxLndpZHRoID0gd2lkdGggIT09IG51bGwgJiYgd2lkdGggIT09IHZvaWQgMCA/IHdpZHRoIDogMDtcbiAgICAgICAgICAgICAgICByZXEuaGVpZ2h0ID0gaGVpZ2h0ICE9PSBudWxsICYmIGhlaWdodCAhPT0gdm9pZCAwID8gaGVpZ2h0IDogMDtcbiAgICAgICAgICAgICAgICBlbmNvZGluZ3MgPSBwdWJsaXNoVXRpbHNfMS5jb21wdXRlVmlkZW9FbmNvZGluZ3ModHJhY2suc291cmNlID09PSBUcmFja18xLlRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgb3B0cyk7XG4gICAgICAgICAgICAgICAgcmVxLmxheWVycyA9IExvY2FsVmlkZW9UcmFja18xLnZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyhyZXEud2lkdGgsIHJlcS5oZWlnaHQsIGVuY29kaW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFja18xLlRyYWNrLktpbmQuQXVkaW8gJiYgb3B0cy5hdWRpb0JpdHJhdGUpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZ3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEJpdHJhdGU6IG9wdHMuYXVkaW9CaXRyYXRlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aSA9IHlpZWxkIHRoaXMuZW5naW5lLmFkZFRyYWNrKHJlcSk7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb25fMS5kZWZhdWx0KHRyYWNrLmtpbmQsIHRpLCB0cmFjayk7XG4gICAgICAgICAgICB0cmFjay5zaWQgPSB0aS5zaWQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZW5naW5lLnB1Ymxpc2hlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKGBwdWJsaXNoaW5nICR7dHJhY2sua2luZH0gd2l0aCBlbmNvZGluZ3NgLCBlbmNvZGluZ3MsIHRpKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdCA9IHsgZGlyZWN0aW9uOiAnc2VuZG9ubHknIH07XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXJJbml0LnNlbmRFbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuZW5naW5lLnB1Ymxpc2hlci5wYy5hZGRUcmFuc2NlaXZlcih0cmFjay5tZWRpYVN0cmVhbVRyYWNrLCB0cmFuc2NlaXZlckluaXQpO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XG4gICAgICAgICAgICAvLyBzdG9yZSBSVFBTZW5kZXJcbiAgICAgICAgICAgIHRyYWNrLnNlbmRlciA9IHRyYW5zY2VpdmVyLnNlbmRlcjtcbiAgICAgICAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIExvY2FsVmlkZW9UcmFja18xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNhYmxlTGF5ZXJQYXVzZSA9IChfaCA9IChfZyA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5leHBEaXNhYmxlTGF5ZXJQYXVzZSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgdHJhY2suc3RhcnRNb25pdG9yKHRoaXMuZW5naW5lLmNsaWVudCwgZGlzYWJsZUxheWVyUGF1c2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2tfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdHJhY2suc3RhcnRNb25pdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy52aWRlb0NvZGVjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcmVmZXJyZWRDb2RlYyh0cmFuc2NlaXZlciwgdHJhY2sua2luZCwgb3B0cy52aWRlb0NvZGVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XG4gICAgICAgICAgICAvLyBzZW5kIGV2ZW50IGZvciBwdWJsaWNhdGlvblxuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18xLlBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW5wdWJsaXNoVHJhY2sodHJhY2ssIHN0b3BPblVucHVibGlzaCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBsb29rIHRocm91Z2ggYWxsIHB1Ymxpc2hlZCB0cmFja3MgdG8gZmluZCB0aGUgcmlnaHQgb25lc1xuICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHRoaXMuZ2V0UHVibGljYXRpb25Gb3JUcmFjayh0cmFjayk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVidWcoJ3VucHVibGlzaFRyYWNrJywgJ3VucHVibGlzaGluZyB0cmFjaycsIHRyYWNrKTtcbiAgICAgICAgaWYgKCFwdWJsaWNhdGlvbiB8fCAhcHVibGljYXRpb24udHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQud2FybigndW5wdWJsaXNoVHJhY2snLCAndHJhY2sgd2FzIG5vdCB1bnB1Ymxpc2hlZCBiZWNhdXNlIG5vIHB1YmxpY2F0aW9uIHdhcyBmb3VuZCcsIHRyYWNrKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrID0gcHVibGljYXRpb24udHJhY2s7XG4gICAgICAgIHRyYWNrLm9mZihldmVudHNfMS5UcmFja0V2ZW50Lk11dGVkLCB0aGlzLm9uVHJhY2tNdXRlZCk7XG4gICAgICAgIHRyYWNrLm9mZihldmVudHNfMS5UcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xuICAgICAgICB0cmFjay5vZmYoZXZlbnRzXzEuVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5vblRyYWNrVW5wdWJsaXNoKTtcbiAgICAgICAgaWYgKHN0b3BPblVucHVibGlzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdG9wT25VbnB1Ymxpc2ggPSAoX2IgPSAoX2EgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcE9uVW5wdWJsaXNoKSB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBtZWRpYVN0cmVhbVRyYWNrIH0gPSB0cmFjaztcbiAgICAgICAgaWYgKHRoaXMuZW5naW5lLnB1Ymxpc2hlcikge1xuICAgICAgICAgICAgY29uc3Qgc2VuZGVycyA9IHRoaXMuZW5naW5lLnB1Ymxpc2hlci5wYy5nZXRTZW5kZXJzKCk7XG4gICAgICAgICAgICBzZW5kZXJzLmZvckVhY2goKHNlbmRlcikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoc2VuZGVyLnRyYWNrID09PSBtZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmVuZ2luZS5wdWJsaXNoZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQud2FybigndW5wdWJsaXNoVHJhY2snLCAnZmFpbGVkIHRvIHJlbW92ZSB0cmFjaycsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGZyb20gb3VyIG1hcHNcbiAgICAgICAgdGhpcy50cmFja3MuZGVsZXRlKHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgc3dpdGNoIChwdWJsaWNhdGlvbi5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFRyYWNrXzEuVHJhY2suS2luZC5BdWRpbzpcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvVHJhY2tzLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRyYWNrXzEuVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvVHJhY2tzLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHB1YmxpY2F0aW9uLnNldFRyYWNrKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuZW1pdChldmVudHNfMS5QYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgICAgICByZXR1cm4gcHVibGljYXRpb247XG4gICAgfVxuICAgIHVucHVibGlzaFRyYWNrcyh0cmFja3MpIHtcbiAgICAgICAgY29uc3QgcHVibGljYXRpb25zID0gW107XG4gICAgICAgIHRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHViID0gdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgICAgICAgICBpZiAocHViKSB7XG4gICAgICAgICAgICAgICAgcHVibGljYXRpb25zLnB1c2gocHViKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwdWJsaWNhdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggYSBuZXcgZGF0YSBwYXlsb2FkIHRvIHRoZSByb29tLiBEYXRhIHdpbGwgYmUgZm9yd2FyZGVkIHRvIGVhY2hcbiAgICAgKiBwYXJ0aWNpcGFudCBpbiB0aGUgcm9vbSBpZiB0aGUgZGVzdGluYXRpb24gYXJndW1lbnQgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIFVpbnQ4QXJyYXkgb2YgdGhlIHBheWxvYWQuIFRvIHNlbmQgc3RyaW5nIGRhdGEsIHVzZSBUZXh0RW5jb2Rlci5lbmNvZGVcbiAgICAgKiBAcGFyYW0ga2luZCB3aGV0aGVyIHRvIHNlbmQgdGhpcyBhcyByZWxpYWJsZSBvciBsb3NzeS5cbiAgICAgKiBGb3IgZGF0YSB0aGF0IHlvdSBuZWVkIGRlbGl2ZXJ5IGd1YXJhbnRlZSAoc3VjaCBhcyBjaGF0IG1lc3NhZ2VzKSwgdXNlIFJlbGlhYmxlLlxuICAgICAqIEZvciBkYXRhIHRoYXQgc2hvdWxkIGFycml2ZSBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLCBidXQgeW91IGFyZSBvayB3aXRoIGRyb3BwZWRcbiAgICAgKiBwYWNrZXRzLCB1c2UgTG9zc3kuXG4gICAgICogQHBhcmFtIGRlc3RpbmF0aW9uIHRoZSBwYXJ0aWNpcGFudHMgd2hvIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZVxuICAgICAqL1xuICAgIHB1Ymxpc2hEYXRhKGRhdGEsIGtpbmQsIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkZXN0ID0gW107XG4gICAgICAgICAgICBpZiAoZGVzdGluYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgUmVtb3RlUGFydGljaXBhbnRfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0LnB1c2godmFsLnNpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0LnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudFNpZDogdGhpcy5zaWQsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uU2lkczogZGVzdCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwga2luZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb250cm9sIHdobyBjYW4gc3Vic2NyaWJlIHRvIExvY2FsUGFydGljaXBhbnQncyBwdWJsaXNoZWQgdHJhY2tzLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgYWxsIHBhcnRpY2lwYW50cyBjYW4gc3Vic2NyaWJlLiBUaGlzIGFsbG93cyBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyXG4gICAgICogd2hvIGlzIGFibGUgdG8gc3Vic2NyaWJlIGF0IGEgcGFydGljaXBhbnQgYW5kIHRyYWNrIGxldmVsLlxuICAgICAqXG4gICAgICogTm90ZTogaWYgYWNjZXNzIGlzIGdpdmVuIGF0IGEgdHJhY2stbGV2ZWwgKGkuZS4gYm90aCBbYWxsUGFydGljaXBhbnRzQWxsb3dlZF0gYW5kXG4gICAgICogW1BhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uLmFsbFRyYWNrc0FsbG93ZWRdIGFyZSBmYWxzZSksIGFueSBuZXdlciBwdWJsaXNoZWQgdHJhY2tzXG4gICAgICogd2lsbCBub3QgZ3JhbnQgcGVybWlzc2lvbnMgdG8gYW55IHBhcnRpY2lwYW50cyBhbmQgd2lsbCByZXF1aXJlIGEgc3Vic2VxdWVudFxuICAgICAqIHBlcm1pc3Npb25zIHVwZGF0ZSB0byBhbGxvdyBzdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWxsUGFydGljaXBhbnRzQWxsb3dlZCBBbGxvd3MgYWxsIHBhcnRpY2lwYW50cyB0byBzdWJzY3JpYmUgYWxsIHRyYWNrcy5cbiAgICAgKiAgVGFrZXMgcHJlY2VkZW5jZSBvdmVyIFtbcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zXV0gaWYgc2V0IHRvIHRydWUuXG4gICAgICogIEJ5IGRlZmF1bHQgdGhpcyBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0gcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zIEZ1bGwgbGlzdCBvZiBpbmRpdmlkdWFsIHBlcm1pc3Npb25zIHBlclxuICAgICAqICBwYXJ0aWNpcGFudC90cmFjay4gQW55IG9taXR0ZWQgcGFydGljaXBhbnRzIHdpbGwgbm90IHJlY2VpdmUgYW55IHBlcm1pc3Npb25zLlxuICAgICAqL1xuICAgIHNldFRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoYWxsUGFydGljaXBhbnRzQWxsb3dlZCwgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zID0gW10pIHtcbiAgICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyhhbGxQYXJ0aWNpcGFudHNBbGxvd2VkLCBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMubWFwKChwKSA9PiBQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbl8xLnRyYWNrUGVybWlzc2lvblRvUHJvdG8ocCkpKTtcbiAgICB9XG4gICAgZ2V0UHVibGljYXRpb25Gb3JUcmFjayh0cmFjaykge1xuICAgICAgICBsZXQgcHVibGljYXRpb247XG4gICAgICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHB1YikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxUcmFjayA9IHB1Yi50cmFjaztcbiAgICAgICAgICAgIGlmICghbG9jYWxUcmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgbG9va3Mgb3Zlcmx5IGNvbXBsaWNhdGVkIGR1ZSB0byB0aGlzIG9iamVjdCB0cmVlXG4gICAgICAgICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsVHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2tfMS5kZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIHx8IGxvY2FsVHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2tfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFRyYWNrLm1lZGlhU3RyZWFtVHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNhdGlvbiA9IHB1YjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRyYWNrID09PSBsb2NhbFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgcHVibGljYXRpb24gPSBwdWI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHVibGljYXRpb247XG4gICAgfVxuICAgIHNldFByZWZlcnJlZENvZGVjKHRyYW5zY2VpdmVyLCBraW5kLCB2aWRlb0NvZGVjKSB7XG4gICAgICAgIGlmICghKCdnZXRDYXBhYmlsaXRpZXMnIGluIFJUQ1J0cFNlbmRlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXAgPSBSVENSdHBTZW5kZXIuZ2V0Q2FwYWJpbGl0aWVzKGtpbmQpO1xuICAgICAgICBpZiAoIWNhcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBjYXAuY29kZWNzLmZpbmQoKGMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlc1ZpZGVvQ29kZWMgPSBjb2RlYyA9PT0gYHZpZGVvLyR7dmlkZW9Db2RlY31gO1xuICAgICAgICAgICAgLy8gZm9yIGgyNjQgY29kZWNzIHRoYXQgaGF2ZSBzZHBGbXRwTGluZSBhdmFpbGFibGUsIHVzZSBvbmx5IGlmIHRoZVxuICAgICAgICAgICAgLy8gcHJvZmlsZS1sZXZlbC1pZCBpcyA0MmUwMWYgZm9yIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgaWYgKHZpZGVvQ29kZWMgPT09ICdoMjY0JyAmJiBjLnNkcEZtdHBMaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNWaWRlb0NvZGVjICYmIGMuc2RwRm10cExpbmUuaW5jbHVkZXMoJ3Byb2ZpbGUtbGV2ZWwtaWQ9NDJlMDFmJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1ZpZGVvQ29kZWMgfHwgY29kZWMgPT09ICdhdWRpby9vcHVzJztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzZWxlY3RlZCAmJiAnc2V0Q29kZWNQcmVmZXJlbmNlcycgaW4gdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNldENvZGVjUHJlZmVyZW5jZXMoW3NlbGVjdGVkXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHB1Ymxpc2hlZFRyYWNrc0luZm8oKSB7XG4gICAgICAgIGNvbnN0IGluZm9zID0gW107XG4gICAgICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJhY2sudHJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGluZm9zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjaWQ6IHRyYWNrLnRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrOiB0cmFjay50cmFja0luZm8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5mb3M7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTG9jYWxQYXJ0aWNpcGFudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvY2FsUGFydGljaXBhbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbm5lY3Rpb25RdWFsaXR5ID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgbGl2ZWtpdF9tb2RlbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9saXZla2l0X21vZGVsc1wiKTtcbmNvbnN0IGV2ZW50c18yID0gcmVxdWlyZShcIi4uL2V2ZW50c1wiKTtcbmNvbnN0IFRyYWNrXzEgPSByZXF1aXJlKFwiLi4vdHJhY2svVHJhY2tcIik7XG52YXIgQ29ubmVjdGlvblF1YWxpdHk7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25RdWFsaXR5KSB7XG4gICAgQ29ubmVjdGlvblF1YWxpdHlbXCJFeGNlbGxlbnRcIl0gPSBcImV4Y2VsbGVudFwiO1xuICAgIENvbm5lY3Rpb25RdWFsaXR5W1wiR29vZFwiXSA9IFwiZ29vZFwiO1xuICAgIENvbm5lY3Rpb25RdWFsaXR5W1wiUG9vclwiXSA9IFwicG9vclwiO1xuICAgIENvbm5lY3Rpb25RdWFsaXR5W1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xufSkoQ29ubmVjdGlvblF1YWxpdHkgPSBleHBvcnRzLkNvbm5lY3Rpb25RdWFsaXR5IHx8IChleHBvcnRzLkNvbm5lY3Rpb25RdWFsaXR5ID0ge30pKTtcbmZ1bmN0aW9uIHF1YWxpdHlGcm9tUHJvdG8ocSkge1xuICAgIHN3aXRjaCAocSkge1xuICAgICAgICBjYXNlIGxpdmVraXRfbW9kZWxzXzEuQ29ubmVjdGlvblF1YWxpdHkuRVhDRUxMRU5UOlxuICAgICAgICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LkV4Y2VsbGVudDtcbiAgICAgICAgY2FzZSBsaXZla2l0X21vZGVsc18xLkNvbm5lY3Rpb25RdWFsaXR5LkdPT0Q6XG4gICAgICAgICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuR29vZDtcbiAgICAgICAgY2FzZSBsaXZla2l0X21vZGVsc18xLkNvbm5lY3Rpb25RdWFsaXR5LlBPT1I6XG4gICAgICAgICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuUG9vcjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Vbmtub3duO1xuICAgIH1cbn1cbmNsYXNzIFBhcnRpY2lwYW50IGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3RydWN0b3Ioc2lkLCBpZGVudGl0eSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKiogYXVkaW8gbGV2ZWwgYmV0d2VlbiAwLTEuMCwgMSBiZWluZyBsb3VkZXN0LCAwIGJlaW5nIHNvZnRlc3QgKi9cbiAgICAgICAgdGhpcy5hdWRpb0xldmVsID0gMDtcbiAgICAgICAgLyoqIGlmIHBhcnRpY2lwYW50IGlzIGN1cnJlbnRseSBzcGVha2luZyAqL1xuICAgICAgICB0aGlzLmlzU3BlYWtpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkgPSBDb25uZWN0aW9uUXVhbGl0eS5Vbmtub3duO1xuICAgICAgICB0aGlzLnNpZCA9IHNpZDtcbiAgICAgICAgdGhpcy5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgICAgICB0aGlzLmF1ZGlvVHJhY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnZpZGVvVHJhY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnRyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZ2V0VHJhY2tzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnRyYWNrcy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdGhlIHNvdXJjZSBmaWx0ZXIsIGZvciBleGFtcGxlLCBnZXR0aW5nXG4gICAgICogdGhlIHVzZXIncyBjYW1lcmEgdHJhY2sgd2l0aCBnZXRUcmFja0J5U291cmNlKFRyYWNrLlNvdXJjZS5DYW1lcmEpLlxuICAgICAqIEBwYXJhbSBzb3VyY2VcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGdldFRyYWNrKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlID09PSBUcmFja18xLlRyYWNrLlNvdXJjZS5Vbmtub3duKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbLCBwdWJdIG9mIHRoaXMudHJhY2tzKSB7XG4gICAgICAgICAgICBpZiAocHViLnNvdXJjZSA9PT0gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1YjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwdWIuc291cmNlID09PSBUcmFja18xLlRyYWNrLlNvdXJjZS5Vbmtub3duKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gVHJhY2tfMS5UcmFjay5Tb3VyY2UuTWljcm9waG9uZSAmJiBwdWIua2luZCA9PT0gVHJhY2tfMS5UcmFjay5LaW5kLkF1ZGlvICYmIHB1Yi50cmFja05hbWUgIT09ICdzY3JlZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwdWI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IFRyYWNrXzEuVHJhY2suU291cmNlLkNhbWVyYSAmJiBwdWIua2luZCA9PT0gVHJhY2tfMS5UcmFjay5LaW5kLlZpZGVvICYmIHB1Yi50cmFja05hbWUgIT09ICdzY3JlZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwdWI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IFRyYWNrXzEuVHJhY2suU291cmNlLlNjcmVlblNoYXJlICYmIHB1Yi5raW5kID09PSBUcmFja18xLlRyYWNrLktpbmQuVmlkZW8gJiYgcHViLnRyYWNrTmFtZSA9PT0gJ3NjcmVlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1YjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gVHJhY2tfMS5UcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyAmJiBwdWIua2luZCA9PT0gVHJhY2tfMS5UcmFjay5LaW5kLkF1ZGlvICYmIHB1Yi50cmFja05hbWUgPT09ICdzY3JlZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwdWI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdGhlIHRyYWNrJ3MgbmFtZS5cbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0VHJhY2tCeU5hbWUobmFtZSkge1xuICAgICAgICBmb3IgKGNvbnN0IFssIHB1Yl0gb2YgdGhpcy50cmFja3MpIHtcbiAgICAgICAgICAgIGlmIChwdWIudHJhY2tOYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1YjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY29ubmVjdGlvblF1YWxpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eTtcbiAgICB9XG4gICAgZ2V0IGlzQ2FtZXJhRW5hYmxlZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2soVHJhY2tfMS5UcmFjay5Tb3VyY2UuQ2FtZXJhKTtcbiAgICAgICAgcmV0dXJuICEoKF9hID0gdHJhY2sgPT09IG51bGwgfHwgdHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrLmlzTXV0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUpO1xuICAgIH1cbiAgICBnZXQgaXNNaWNyb3Bob25lRW5hYmxlZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2soVHJhY2tfMS5UcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgICAgIHJldHVybiAhKChfYSA9IHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5pc011dGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcbiAgICB9XG4gICAgZ2V0IGlzU2NyZWVuU2hhcmVFbmFibGVkKCkge1xuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2soVHJhY2tfMS5UcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUpO1xuICAgICAgICByZXR1cm4gISF0cmFjaztcbiAgICB9XG4gICAgLyoqIHdoZW4gcGFydGljaXBhbnQgam9pbmVkIHRoZSByb29tICovXG4gICAgZ2V0IGpvaW5lZEF0KCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWNpcGFudEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnBhcnRpY2lwYW50SW5mby5qb2luZWRBdCAqIDEwMDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgdXBkYXRlSW5mbyhpbmZvKSB7XG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSBpbmZvLmlkZW50aXR5O1xuICAgICAgICB0aGlzLnNpZCA9IGluZm8uc2lkO1xuICAgICAgICB0aGlzLm5hbWUgPSBpbmZvLm5hbWU7XG4gICAgICAgIHRoaXMuc2V0TWV0YWRhdGEoaW5mby5tZXRhZGF0YSk7XG4gICAgICAgIC8vIHNldCB0aGlzIGxhc3Qgc28gc2V0TWV0YWRhdGEgY2FuIGRldGVjdCBjaGFuZ2VzXG4gICAgICAgIHRoaXMucGFydGljaXBhbnRJbmZvID0gaW5mbztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHNldE1ldGFkYXRhKG1kKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSAhdGhpcy5wYXJ0aWNpcGFudEluZm8gfHwgdGhpcy5wYXJ0aWNpcGFudEluZm8ubWV0YWRhdGEgIT09IG1kO1xuICAgICAgICBjb25zdCBwcmV2TWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWQ7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzIuUGFydGljaXBhbnRFdmVudC5NZXRhZGF0YUNoYW5nZWQsIHByZXZNZXRhZGF0YSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzIuUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgcHJldk1ldGFkYXRhLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc2V0SXNTcGVha2luZyhzcGVha2luZykge1xuICAgICAgICBpZiAoc3BlYWtpbmcgPT09IHRoaXMuaXNTcGVha2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTcGVha2luZyA9IHNwZWFraW5nO1xuICAgICAgICBpZiAoc3BlYWtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFNwb2tlQXQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5QYXJ0aWNpcGFudEV2ZW50LklzU3BlYWtpbmdDaGFuZ2VkLCBzcGVha2luZyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzZXRDb25uZWN0aW9uUXVhbGl0eShxKSB7XG4gICAgICAgIGNvbnN0IHByZXZRdWFsaXR5ID0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5ID0gcXVhbGl0eUZyb21Qcm90byhxKTtcbiAgICAgICAgaWYgKHByZXZRdWFsaXR5ICE9PSB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbikge1xuICAgICAgICAvLyBmb3J3YXJkIHB1YmxpY2F0aW9uIGRyaXZlbiBldmVudHNcbiAgICAgICAgcHVibGljYXRpb24ub24oZXZlbnRzXzIuVHJhY2tFdmVudC5NdXRlZCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgcHVibGljYXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcHVibGljYXRpb24ub24oZXZlbnRzXzIuVHJhY2tFdmVudC5Vbm11dGVkLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzIuUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHB1YiA9IHB1YmxpY2F0aW9uO1xuICAgICAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICAgICAgICBwdWIudHJhY2suc2lkID0gcHVibGljYXRpb24udHJhY2tTaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja3Muc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xuICAgICAgICAgICAgY2FzZSBUcmFja18xLlRyYWNrLktpbmQuQXVkaW86XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb1RyYWNrcy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVHJhY2tfMS5UcmFjay5LaW5kLlZpZGVvOlxuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9UcmFja3Muc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUGFydGljaXBhbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXJ0aWNpcGFudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHJhY2tQZXJtaXNzaW9uVG9Qcm90byA9IHZvaWQgMDtcbmZ1bmN0aW9uIHRyYWNrUGVybWlzc2lvblRvUHJvdG8ocGVybXMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFwZXJtcy5wYXJ0aWNpcGFudFNpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhY2sgcGVybWlzc2lvbiwgbWlzc2luZyBwYXJ0aWNpcGFudFNpZCcpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXJ0aWNpcGFudFNpZDogcGVybXMucGFydGljaXBhbnRTaWQsXG4gICAgICAgIGFsbFRyYWNrczogKF9hID0gcGVybXMuYWxsb3dBbGwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICB0cmFja1NpZHM6IHBlcm1zLmFsbG93ZWRUcmFja1NpZHMgfHwgW10sXG4gICAgfTtcbn1cbmV4cG9ydHMudHJhY2tQZXJtaXNzaW9uVG9Qcm90byA9IHRyYWNrUGVybWlzc2lvblRvUHJvdG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGxvZ2dlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9sb2dnZXJcIikpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xuY29uc3QgUmVtb3RlQXVkaW9UcmFja18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi90cmFjay9SZW1vdGVBdWRpb1RyYWNrXCIpKTtcbmNvbnN0IFJlbW90ZVRyYWNrUHVibGljYXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vdHJhY2svUmVtb3RlVHJhY2tQdWJsaWNhdGlvblwiKSk7XG5jb25zdCBSZW1vdGVWaWRlb1RyYWNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3RyYWNrL1JlbW90ZVZpZGVvVHJhY2tcIikpO1xuY29uc3QgVHJhY2tfMSA9IHJlcXVpcmUoXCIuLi90cmFjay9UcmFja1wiKTtcbmNvbnN0IFBhcnRpY2lwYW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUGFydGljaXBhbnRcIikpO1xuY2xhc3MgUmVtb3RlUGFydGljaXBhbnQgZXh0ZW5kcyBQYXJ0aWNpcGFudF8xLmRlZmF1bHQge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdHJ1Y3RvcihzaWduYWxDbGllbnQsIGlkLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKGlkLCBuYW1lIHx8ICcnKTtcbiAgICAgICAgdGhpcy5zaWduYWxDbGllbnQgPSBzaWduYWxDbGllbnQ7XG4gICAgICAgIHRoaXMudHJhY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmF1ZGlvVHJhY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnZpZGVvVHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGZyb21QYXJ0aWNpcGFudEluZm8oc2lnbmFsQ2xpZW50LCBwaSkge1xuICAgICAgICBjb25zdCBycCA9IG5ldyBSZW1vdGVQYXJ0aWNpcGFudChzaWduYWxDbGllbnQsIHBpLnNpZCwgcGkuaWRlbnRpdHkpO1xuICAgICAgICBycC51cGRhdGVJbmZvKHBpKTtcbiAgICAgICAgcmV0dXJuIHJwO1xuICAgIH1cbiAgICBhZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKSB7XG4gICAgICAgIHN1cGVyLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuICAgICAgICAvLyByZWdpc3RlciBhY3Rpb24gZXZlbnRzXG4gICAgICAgIHB1YmxpY2F0aW9uLm9uKGV2ZW50c18xLlRyYWNrRXZlbnQuVXBkYXRlU2V0dGluZ3MsIChzZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zaWduYWxDbGllbnQuc2VuZFVwZGF0ZVRyYWNrU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHVibGljYXRpb24ub24oZXZlbnRzXzEuVHJhY2tFdmVudC5VcGRhdGVTdWJzY3JpcHRpb24sIChzdWIpID0+IHtcbiAgICAgICAgICAgIHN1Yi5wYXJ0aWNpcGFudFRyYWNrcy5mb3JFYWNoKChwdCkgPT4ge1xuICAgICAgICAgICAgICAgIHB0LnBhcnRpY2lwYW50U2lkID0gdGhpcy5zaWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsQ2xpZW50LnNlbmRVcGRhdGVTdWJzY3JpcHRpb24oc3ViKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHB1YmxpY2F0aW9uLm9uKGV2ZW50c18xLlRyYWNrRXZlbnQuRW5kZWQsICh0cmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18xLlBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUcmFjayhzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFjayhzb3VyY2UpO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUcmFja0J5TmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tCeU5hbWUobmFtZSk7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBhZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhtZWRpYVRyYWNrLCBzaWQsIG1lZGlhU3RyZWFtLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW0sIHRyaWVzTGVmdCkge1xuICAgICAgICAvLyBmaW5kIHRoZSB0cmFjayBwdWJsaWNhdGlvblxuICAgICAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgbWVkaWEgdHJhY2sgdG8gYXJyaXZlIGJlZm9yZSBwYXJ0aWNpcGFudCBpbmZvXG4gICAgICAgIGxldCBwdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihzaWQpO1xuICAgICAgICAvLyBpdCdzIGFsc28gcG9zc2libGUgdGhhdCB0aGUgYnJvd3NlciBkaWRuJ3QgaG9ub3Igb3VyIG9yaWdpbmFsIHRyYWNrIGlkXG4gICAgICAgIC8vIEZpcmVGb3ggd291bGQgdXNlIGl0cyBvd24gbG9jYWwgdXVpZCBpbnN0ZWFkIG9mIHNlcnZlciB0cmFjayBpZFxuICAgICAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXNpZC5zdGFydHNXaXRoKCdUUicpKSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIHR5cGVcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHVibGljYXRpb24gJiYgbWVkaWFUcmFjay5raW5kID09PSBwLmtpbmQudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljYXRpb24gPSBwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hlbiB3ZSBjb3VsZG4ndCBsb2NhdGUgdGhlIHRyYWNrLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIG1ldGFkYXRhIGhhc24ndFxuICAgICAgICAvLyB5ZXQgYXJyaXZlZC4gV2FpdCBhIGJpdCBsb25nZXIgZm9yIGl0IHRvIGFycml2ZSwgb3IgZmlyZSBhbiBlcnJvclxuICAgICAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHJpZXNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5lcnJvcignY291bGQgbm90IGZpbmQgcHVibGlzaGVkIHRyYWNrJywgdGhpcy5zaWQsIHNpZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18xLlBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHNpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyaWVzTGVmdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRyaWVzTGVmdCA9IDIwO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhtZWRpYVRyYWNrLCBzaWQsIG1lZGlhU3RyZWFtLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW0sIHRyaWVzTGVmdCAtIDEpO1xuICAgICAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1ZpZGVvID0gbWVkaWFUcmFjay5raW5kID09PSAndmlkZW8nO1xuICAgICAgICBsZXQgdHJhY2s7XG4gICAgICAgIGlmIChpc1ZpZGVvKSB7XG4gICAgICAgICAgICB0cmFjayA9IG5ldyBSZW1vdGVWaWRlb1RyYWNrXzEuZGVmYXVsdChtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmFjayA9IG5ldyBSZW1vdGVBdWRpb1RyYWNrXzEuZGVmYXVsdChtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdHJhY2sgaW5mb1xuICAgICAgICB0cmFjay5zb3VyY2UgPSBwdWJsaWNhdGlvbi5zb3VyY2U7XG4gICAgICAgIC8vIGtlZXAgcHVibGljYXRpb24ncyBtdXRlZCBzdGF0dXNcbiAgICAgICAgdHJhY2suaXNNdXRlZCA9IHB1YmxpY2F0aW9uLmlzTXV0ZWQ7XG4gICAgICAgIHRyYWNrLnNldE1lZGlhU3RyZWFtKG1lZGlhU3RyZWFtKTtcbiAgICAgICAgdHJhY2suc3RhcnQoKTtcbiAgICAgICAgcHVibGljYXRpb24uc2V0VHJhY2sodHJhY2spO1xuICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzEuUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGdldCBoYXNNZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5wYXJ0aWNpcGFudEluZm87XG4gICAgfVxuICAgIGdldFRyYWNrUHVibGljYXRpb24oc2lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrcy5nZXQoc2lkKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHVwZGF0ZUluZm8oaW5mbykge1xuICAgICAgICBjb25zdCBhbHJlYWR5SGFzTWV0YWRhdGEgPSB0aGlzLmhhc01ldGFkYXRhO1xuICAgICAgICBzdXBlci51cGRhdGVJbmZvKGluZm8pO1xuICAgICAgICAvLyB3ZSBhcmUgZ2V0dGluZyBhIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSB0cmFja3MsIHJlY29uY2lsZSBpbiBoZXJlXG4gICAgICAgIC8vIGFuZCBzZW5kIG91dCBldmVudHMgZm9yIGNoYW5nZXNcbiAgICAgICAgLy8gcmVjb25jaWxlIHRyYWNrIHB1YmxpY2F0aW9ucywgcHVibGlzaCBldmVudHMgb25seSBpZiBtZXRhZGF0YSBpcyBhbHJlYWR5IHRoZXJlXG4gICAgICAgIC8vIGkuZS4gY2hhbmdlcyBzaW5jZSB0aGUgbG9jYWwgcGFydGljaXBhbnQgaGFzIGpvaW5lZFxuICAgICAgICBjb25zdCB2YWxpZFRyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgbmV3VHJhY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICBpbmZvLnRyYWNrcy5mb3JFYWNoKCh0aSkgPT4ge1xuICAgICAgICAgICAgbGV0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKHRpLnNpZCk7XG4gICAgICAgICAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV3IHB1YmxpY2F0aW9uXG4gICAgICAgICAgICAgICAgY29uc3Qga2luZCA9IFRyYWNrXzEuVHJhY2sua2luZEZyb21Qcm90byh0aS50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwdWJsaWNhdGlvbiA9IG5ldyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXzEuZGVmYXVsdChraW5kLCB0aS5zaWQsIHRpLm5hbWUpO1xuICAgICAgICAgICAgICAgIHB1YmxpY2F0aW9uLnVwZGF0ZUluZm8odGkpO1xuICAgICAgICAgICAgICAgIG5ld1RyYWNrcy5zZXQodGkuc2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1YmxpY2F0aW9uLnVwZGF0ZUluZm8odGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRUcmFja3Muc2V0KHRpLnNpZCwgcHVibGljYXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gc2VuZCBuZXcgdHJhY2tzXG4gICAgICAgIGlmIChhbHJlYWR5SGFzTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIG5ld1RyYWNrcy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMS5QYXJ0aWNpcGFudEV2ZW50LlRyYWNrUHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZXRlY3QgcmVtb3ZlZCB0cmFja3NcbiAgICAgICAgdGhpcy50cmFja3MuZm9yRWFjaCgocHVibGljYXRpb24pID0+IHtcbiAgICAgICAgICAgIGlmICghdmFsaWRUcmFja3MuaGFzKHB1YmxpY2F0aW9uLnRyYWNrU2lkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2tTaWQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHVucHVibGlzaFRyYWNrKHNpZCwgc2VuZFVucHVibGlzaCkge1xuICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHRoaXMudHJhY2tzLmdldChzaWQpO1xuICAgICAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja3MuZGVsZXRlKHNpZCk7XG4gICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSByaWdodCB0eXBlIG1hcFxuICAgICAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhY2tfMS5UcmFjay5LaW5kLkF1ZGlvOlxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9UcmFja3MuZGVsZXRlKHNpZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRyYWNrXzEuVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvVHJhY2tzLmRlbGV0ZShzaWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBhbHNvIHNlbmQgdW5zdWJzY3JpYmUsIGlmIHRyYWNrIGlzIGFjdGl2ZWx5IHN1YnNjcmliZWRcbiAgICAgICAgY29uc3QgeyB0cmFjayB9ID0gcHVibGljYXRpb247XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgY29uc3QgeyBpc1N1YnNjcmliZWQgfSA9IHB1YmxpY2F0aW9uO1xuICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgcHVibGljYXRpb24uc2V0VHJhY2sodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIC8vIGFsd2F5cyBzZW5kIHVuc3Vic2NyaWJlZCwgc2luY2UgYXBwcyBtYXkgcmVseSBvbiB0aGlzXG4gICAgICAgICAgICBpZiAoaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18xLlBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbmRVbnB1Ymxpc2gpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMS5QYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LnRyYWNlKCdwYXJ0aWNpcGFudCBldmVudCcsIHRoaXMuc2lkLCBldmVudCwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBSZW1vdGVQYXJ0aWNpcGFudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbW90ZVBhcnRpY2lwYW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcmVzZXRzRm9yUmVzb2x1dGlvbiA9IGV4cG9ydHMuZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyA9IGV4cG9ydHMuY29tcHV0ZVZpZGVvRW5jb2RpbmdzID0gZXhwb3J0cy5wcmVzZXRzU2NyZWVuU2hhcmUgPSBleHBvcnRzLnByZXNldHM0MyA9IGV4cG9ydHMucHJlc2V0czE2OSA9IGV4cG9ydHMubWVkaWFUcmFja1RvTG9jYWxUcmFjayA9IHZvaWQgMDtcbmNvbnN0IGxvZ2dlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9sb2dnZXJcIikpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgTG9jYWxBdWRpb1RyYWNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3RyYWNrL0xvY2FsQXVkaW9UcmFja1wiKSk7XG5jb25zdCBMb2NhbFZpZGVvVHJhY2tfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vdHJhY2svTG9jYWxWaWRlb1RyYWNrXCIpKTtcbmNvbnN0IG9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFjay9vcHRpb25zXCIpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gbWVkaWFUcmFja1RvTG9jYWxUcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cykge1xuICAgIHN3aXRjaCAobWVkaWFTdHJlYW1UcmFjay5raW5kKSB7XG4gICAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9jYWxBdWRpb1RyYWNrXzEuZGVmYXVsdChtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cyk7XG4gICAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9jYWxWaWRlb1RyYWNrXzEuZGVmYXVsdChtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVHJhY2tJbnZhbGlkRXJyb3IoYHVuc3VwcG9ydGVkIHRyYWNrIHR5cGU6ICR7bWVkaWFTdHJlYW1UcmFjay5raW5kfWApO1xuICAgIH1cbn1cbmV4cG9ydHMubWVkaWFUcmFja1RvTG9jYWxUcmFjayA9IG1lZGlhVHJhY2tUb0xvY2FsVHJhY2s7XG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydHMucHJlc2V0czE2OSA9IFtcbiAgICBvcHRpb25zXzEuVmlkZW9QcmVzZXRzLnF2Z2EsXG4gICAgb3B0aW9uc18xLlZpZGVvUHJlc2V0cy52Z2EsXG4gICAgb3B0aW9uc18xLlZpZGVvUHJlc2V0cy5xaGQsXG4gICAgb3B0aW9uc18xLlZpZGVvUHJlc2V0cy5oZCxcbiAgICBvcHRpb25zXzEuVmlkZW9QcmVzZXRzLmZoZCxcbl07XG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydHMucHJlc2V0czQzID0gW1xuICAgIG9wdGlvbnNfMS5WaWRlb1ByZXNldHM0My5xdmdhLFxuICAgIG9wdGlvbnNfMS5WaWRlb1ByZXNldHM0My52Z2EsXG4gICAgb3B0aW9uc18xLlZpZGVvUHJlc2V0czQzLnFoZCxcbiAgICBvcHRpb25zXzEuVmlkZW9QcmVzZXRzNDMuaGQsXG4gICAgb3B0aW9uc18xLlZpZGVvUHJlc2V0czQzLmZoZCxcbl07XG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydHMucHJlc2V0c1NjcmVlblNoYXJlID0gW1xuICAgIG9wdGlvbnNfMS5TY3JlZW5TaGFyZVByZXNldHMudmdhLFxuICAgIG9wdGlvbnNfMS5TY3JlZW5TaGFyZVByZXNldHMuaGRfOCxcbiAgICBvcHRpb25zXzEuU2NyZWVuU2hhcmVQcmVzZXRzLmhkXzE1LFxuICAgIG9wdGlvbnNfMS5TY3JlZW5TaGFyZVByZXNldHMuZmhkXzE1LFxuICAgIG9wdGlvbnNfMS5TY3JlZW5TaGFyZVByZXNldHMuZmhkXzMwLFxuXTtcbmNvbnN0IHZpZGVvUmlkcyA9IFsncScsICdoJywgJ2YnXTtcbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICBsZXQgdmlkZW9FbmNvZGluZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb0VuY29kaW5nO1xuICAgIGlmIChpc1NjcmVlblNoYXJlKSB7XG4gICAgICAgIHZpZGVvRW5jb2RpbmcgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NyZWVuU2hhcmVFbmNvZGluZztcbiAgICB9XG4gICAgY29uc3QgdXNlU2ltdWxjYXN0ID0gIWlzU2NyZWVuU2hhcmUgJiYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaW11bGNhc3QpO1xuICAgIGlmICgoIXZpZGVvRW5jb2RpbmcgJiYgIXVzZVNpbXVsY2FzdCkgfHwgIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgLy8gd2hlbiB3ZSBhcmVuJ3Qgc2ltdWxjYXN0aW5nLCB3aWxsIG5lZWQgdG8gcmV0dXJuIGEgc2luZ2xlIGVuY29kaW5nIHdpdGhvdXRcbiAgICAgICAgLy8gY2FwcGluZyBiYW5kd2lkdGguIHdlIGFsd2F5cyByZXF1aXJlIGEgZW5jb2RpbmcgZm9yIGR5bmFjYXN0XG4gICAgICAgIHJldHVybiBbe31dO1xuICAgIH1cbiAgICBpZiAoIXZpZGVvRW5jb2RpbmcpIHtcbiAgICAgICAgLy8gZmluZCB0aGUgcmlnaHQgZW5jb2RpbmcgYmFzZWQgb24gd2lkdGgvaGVpZ2h0XG4gICAgICAgIHZpZGVvRW5jb2RpbmcgPSBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCd1c2luZyB2aWRlbyBlbmNvZGluZycsIHZpZGVvRW5jb2RpbmcpO1xuICAgIH1cbiAgICBpZiAoIXVzZVNpbXVsY2FzdCkge1xuICAgICAgICByZXR1cm4gW3ZpZGVvRW5jb2RpbmddO1xuICAgIH1cbiAgICBjb25zdCBwcmVzZXRzID0gcHJlc2V0c0ZvclJlc29sdXRpb24oaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgbGV0IG1pZFByZXNldDtcbiAgICBjb25zdCBsb3dQcmVzZXQgPSBwcmVzZXRzWzBdO1xuICAgIGlmIChwcmVzZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgWywgbWlkUHJlc2V0XSA9IHByZXNldHM7XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsID0gbmV3IG9wdGlvbnNfMS5WaWRlb1ByZXNldCh3aWR0aCwgaGVpZ2h0LCB2aWRlb0VuY29kaW5nLm1heEJpdHJhdGUsIHZpZGVvRW5jb2RpbmcubWF4RnJhbWVyYXRlKTtcbiAgICAvLyBOT1RFOlxuICAgIC8vICAgMS4gT3JkZXJpbmcgb2YgdGhlc2UgZW5jb2RpbmdzIGlzIGltcG9ydGFudC4gQ2hyb21lIHNlZW1zXG4gICAgLy8gICAgICB0byB1c2UgdGhlIGluZGV4IGludG8gZW5jb2RpbmdzIHRvIGRlY2lkZSB3aGljaCBsYXllclxuICAgIC8vICAgICAgdG8gZGlzYWJsZSB3aGVuIENQVSBjb25zdHJhaW5lZC5cbiAgICAvLyAgICAgIFNvIGVuY29kaW5ncyBzaG91bGQgYmUgb3JkZXJlZCBpbiBpbmNyZWFzaW5nIHNwYXRpYWxcbiAgICAvLyAgICAgIHJlc29sdXRpb24gb3JkZXIuXG4gICAgLy8gICAyLiBpb24tc2Z1IHRyYW5zbGF0ZXMgcmlkcyBpbnRvIGxheWVycy4gU28sIGFsbCBlbmNvZGluZ3NcbiAgICAvLyAgICAgIHNob3VsZCBoYXZlIHRoZSBiYXNlIGxheWVyIGBxYCBhbmQgdGhlbiBtb3JlIGFkZGVkXG4gICAgLy8gICAgICBiYXNlZCBvbiBvdGhlciBjb25kaXRpb25zLlxuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoc2l6ZSA+PSA5NjAgJiYgbWlkUHJlc2V0KSB7XG4gICAgICAgIHJldHVybiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBbXG4gICAgICAgICAgICBsb3dQcmVzZXQsIG1pZFByZXNldCwgb3JpZ2luYWwsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA+PSA1MDApIHtcbiAgICAgICAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtcbiAgICAgICAgICAgIGxvd1ByZXNldCwgb3JpZ2luYWwsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgW1xuICAgICAgICBvcmlnaW5hbCxcbiAgICBdKTtcbn1cbmV4cG9ydHMuY29tcHV0ZVZpZGVvRW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzO1xuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBwcmVzZXRzID0gcHJlc2V0c0ZvclJlc29sdXRpb24oaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgbGV0IHsgZW5jb2RpbmcgfSA9IHByZXNldHNbMF07XG4gICAgLy8gaGFuZGxlIHBvcnRyYWl0IGJ5IHN3YXBwaW5nIGRpbWVuc2lvbnNcbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVzZXRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHByZXNldCA9IHByZXNldHNbaV07XG4gICAgICAgIGVuY29kaW5nID0gcHJlc2V0LmVuY29kaW5nO1xuICAgICAgICBpZiAocHJlc2V0LndpZHRoID49IHNpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGluZztcbn1cbmV4cG9ydHMuZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyA9IGRldGVybWluZUFwcHJvcHJpYXRlRW5jb2Rpbmc7XG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHByZXNldHNGb3JSZXNvbHV0aW9uKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5wcmVzZXRzU2NyZWVuU2hhcmU7XG4gICAgfVxuICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoID4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBoZWlnaHQgLyB3aWR0aDtcbiAgICBpZiAoTWF0aC5hYnMoYXNwZWN0IC0gMTYuMCAvIDkpIDwgTWF0aC5hYnMoYXNwZWN0IC0gNC4wIC8gMykpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucHJlc2V0czE2OTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMucHJlc2V0czQzO1xufVxuZXhwb3J0cy5wcmVzZXRzRm9yUmVzb2x1dGlvbiA9IHByZXNldHNGb3JSZXNvbHV0aW9uO1xuLy8gcHJlc2V0cyBzaG91bGQgYmUgb3JkZXJlZCBieSBsb3csIG1lZGl1bSwgaGlnaFxuZnVuY3Rpb24gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgcHJlc2V0cykge1xuICAgIGNvbnN0IGVuY29kaW5ncyA9IFtdO1xuICAgIHByZXNldHMuZm9yRWFjaCgocHJlc2V0LCBpZHgpID0+IHtcbiAgICAgICAgaWYgKGlkeCA+PSB2aWRlb1JpZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCByaWQgPSB2aWRlb1JpZHNbaWR4XTtcbiAgICAgICAgZW5jb2RpbmdzLnB1c2goe1xuICAgICAgICAgICAgcmlkLFxuICAgICAgICAgICAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiBzaXplIC8gTWF0aC5taW4ocHJlc2V0LndpZHRoLCBwcmVzZXQuaGVpZ2h0KSxcbiAgICAgICAgICAgIG1heEJpdHJhdGU6IHByZXNldC5lbmNvZGluZy5tYXhCaXRyYXRlLFxuICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgICAgbWF4RnJhbWVyYXRlOiBwcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZW5jb2RpbmdzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaFV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21wdXRlQml0cmF0ZSA9IGV4cG9ydHMubW9uaXRvckZyZXF1ZW5jeSA9IHZvaWQgMDtcbmV4cG9ydHMubW9uaXRvckZyZXF1ZW5jeSA9IDIwMDA7XG5mdW5jdGlvbiBjb21wdXRlQml0cmF0ZShjdXJyZW50U3RhdHMsIHByZXZTdGF0cykge1xuICAgIGlmICghcHJldlN0YXRzKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgYnl0ZXNOb3c7XG4gICAgbGV0IGJ5dGVzUHJldjtcbiAgICBpZiAoJ2J5dGVzUmVjZWl2ZWQnIGluIGN1cnJlbnRTdGF0cykge1xuICAgICAgICBieXRlc05vdyA9IGN1cnJlbnRTdGF0cy5ieXRlc1JlY2VpdmVkO1xuICAgICAgICBieXRlc1ByZXYgPSBwcmV2U3RhdHMuYnl0ZXNSZWNlaXZlZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2J5dGVzU2VudCcgaW4gY3VycmVudFN0YXRzKSB7XG4gICAgICAgIGJ5dGVzTm93ID0gY3VycmVudFN0YXRzLmJ5dGVzU2VudDtcbiAgICAgICAgYnl0ZXNQcmV2ID0gcHJldlN0YXRzLmJ5dGVzU2VudDtcbiAgICB9XG4gICAgaWYgKGJ5dGVzTm93ID09PSB1bmRlZmluZWQgfHwgYnl0ZXNQcmV2ID09PSB1bmRlZmluZWRcbiAgICAgICAgfHwgY3VycmVudFN0YXRzLnRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkIHx8IHByZXZTdGF0cy50aW1lc3RhbXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuICgoYnl0ZXNOb3cgLSBieXRlc1ByZXYpICogOCAqIDEwMDApIC8gKGN1cnJlbnRTdGF0cy50aW1lc3RhbXAgLSBwcmV2U3RhdHMudGltZXN0YW1wKTtcbn1cbmV4cG9ydHMuY29tcHV0ZUJpdHJhdGUgPSBjb21wdXRlQml0cmF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBsb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbG9nZ2VyXCIpKTtcbmNvbnN0IHN0YXRzXzEgPSByZXF1aXJlKFwiLi4vc3RhdHNcIik7XG5jb25zdCBMb2NhbFRyYWNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTG9jYWxUcmFja1wiKSk7XG5jb25zdCBUcmFja18xID0gcmVxdWlyZShcIi4vVHJhY2tcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jbGFzcyBMb2NhbEF1ZGlvVHJhY2sgZXh0ZW5kcyBMb2NhbFRyYWNrXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgY29uc3RyYWludHMpIHtcbiAgICAgICAgc3VwZXIobWVkaWFUcmFjaywgVHJhY2tfMS5UcmFjay5LaW5kLkF1ZGlvLCBjb25zdHJhaW50cyk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5zdG9wT25NdXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW9uaXRvclNlbmRlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLmdldFNlbmRlclN0YXRzKCk7XG4gICAgICAgICAgICBpZiAoc3RhdHMgJiYgdGhpcy5wcmV2U3RhdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IHN0YXRzXzEuY29tcHV0ZUJpdHJhdGUoc3RhdHMsIHRoaXMucHJldlN0YXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vbml0b3JTZW5kZXIoKTtcbiAgICAgICAgICAgIH0sIHN0YXRzXzEubW9uaXRvckZyZXF1ZW5jeSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXREZXZpY2VJZChkZXZpY2VJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3RyYWludHMuZGV2aWNlSWQgPT09IGRldmljZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cy5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnRUcmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXV0ZSgpIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBtdXRlOiB7IGdldDogKCkgPT4gc3VwZXIubXV0ZSB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gZGlzYWJsZWQgc3BlY2lhbCBoYW5kbGluZyBhcyBpdCB3aWxsIGNhdXNlIEJUIGhlYWRzZXRzIHRvIHN3aXRjaCBjb21tdW5pY2F0aW9uIG1vZGVzXG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrXzEuVHJhY2suU291cmNlLk1pY3JvcGhvbmUgJiYgdGhpcy5zdG9wT25NdXRlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZWJ1Zygnc3RvcHBpbmcgbWljIHRyYWNrJyk7XG4gICAgICAgICAgICAgICAgLy8gYWxzbyBzdG9wIHRoZSB0cmFjaywgc28gdGhhdCBtaWNyb3Bob25lIGluZGljYXRvciBpcyB0dXJuZWQgb2ZmXG4gICAgICAgICAgICAgICAgdGhpcy5tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIF9zdXBlci5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVubXV0ZSgpIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICB1bm11dGU6IHsgZ2V0OiAoKSA9PiBzdXBlci51bm11dGUgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2tfMS5UcmFjay5Tb3VyY2UuTWljcm9waG9uZSAmJiB0aGlzLnN0b3BPbk11dGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCdyZWFjcXVpcmluZyBtaWMgdHJhY2snKTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnRUcmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgX3N1cGVyLnVubXV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXN0YXJ0VHJhY2sob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGNvbnN0cmFpbnRzO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IHV0aWxzXzEuY29uc3RyYWludHNGb3JPcHRpb25zKHsgYXVkaW86IG9wdGlvbnMgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW1Db25zdHJhaW50cy5hdWRpbyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gc3RyZWFtQ29uc3RyYWludHMuYXVkaW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0KGNvbnN0cmFpbnRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qIEBpbnRlcm5hbCAqL1xuICAgIHN0YXJ0TW9uaXRvcigpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1vbml0b3JTZW5kZXIoKTtcbiAgICAgICAgfSwgc3RhdHNfMS5tb25pdG9yRnJlcXVlbmN5KTtcbiAgICB9XG4gICAgZ2V0U2VuZGVyU3RhdHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICAgICAgICAgIGxldCBhdWRpb1N0YXRzO1xuICAgICAgICAgICAgc3RhdHMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvU3RhdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRzU2VudDogdi5wYWNrZXRzU2VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2tldHNMb3N0OiB2LnBhY2tldHNMb3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZFRyaXBUaW1lOiB2LnJvdW5kVHJpcFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvU3RhdHM7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IExvY2FsQXVkaW9UcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvY2FsQXVkaW9UcmFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbG9nZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2xvZ2dlclwiKSk7XG5jb25zdCBEZXZpY2VNYW5hZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL0RldmljZU1hbmFnZXJcIikpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xuY29uc3QgVHJhY2tfMSA9IHJlcXVpcmUoXCIuL1RyYWNrXCIpO1xuY2xhc3MgTG9jYWxUcmFjayBleHRlbmRzIFRyYWNrXzEuVHJhY2sge1xuICAgIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGtpbmQsIGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHN1cGVyKG1lZGlhVHJhY2ssIGtpbmQpO1xuICAgICAgICB0aGlzLmhhbmRsZUVuZGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18xLlRyYWNrRXZlbnQuRW5kZWQsIHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzICE9PSBudWxsICYmIGNvbnN0cmFpbnRzICE9PSB2b2lkIDAgPyBjb25zdHJhaW50cyA6IG1lZGlhVHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmlkO1xuICAgIH1cbiAgICBnZXQgZGltZW5zaW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMua2luZCAhPT0gVHJhY2tfMS5UcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBEZXZpY2VJRCBvZiB0aGUgZGV2aWNlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHVzZWQgZm9yIHRoaXMgdHJhY2tcbiAgICAgKi9cbiAgICBnZXREZXZpY2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHNjcmVlbiBzaGFyZSBkb2Vzbid0IGhhdmUgYSB1c2FibGUgZGV2aWNlIGlkXG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrXzEuVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkZXZpY2VJZCwgZ3JvdXBJZCB9ID0gdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICBjb25zdCBraW5kID0gdGhpcy5raW5kID09PSBUcmFja18xLlRyYWNrLktpbmQuQXVkaW8gPyAnYXVkaW9pbnB1dCcgOiAndmlkZW9pbnB1dCc7XG4gICAgICAgICAgICByZXR1cm4gRGV2aWNlTWFuYWdlcl8xLmRlZmF1bHQuZ2V0SW5zdGFuY2UoKS5ub3JtYWxpemVEZXZpY2VJZChraW5kLCBkZXZpY2VJZCwgZ3JvdXBJZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdXRlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRUcmFja011dGVkKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bm11dGUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNldFRyYWNrTXV0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXN0YXJ0KGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlRyYWNrSW52YWxpZEVycm9yKCd1bmFibGUgdG8gcmVzdGFydCBhbiB1bnB1Ymxpc2hlZCB0cmFjaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25zdHJhaW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVidWcoJ3Jlc3RhcnRpbmcgdHJhY2sgd2l0aCBjb25zdHJhaW50cycsIGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbUNvbnN0cmFpbnRzID0ge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2aWRlbzogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2tfMS5UcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtQ29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZXRhY2hcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgICAgICAgIFRyYWNrXzEuZGV0YWNoVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgICAgICAgLy8gb24gU2FmYXJpLCB0aGUgb2xkIGF1ZGlvIHRyYWNrIG11c3QgYmUgc3RvcHBlZCBiZWZvcmUgYXR0ZW1wdGluZyB0byBhY3F1aXJlXG4gICAgICAgICAgICAvLyB0aGUgbmV3IHRyYWNrLCBvdGhlcndpc2UgdGhlIG5ldyB0cmFjayB3aWxsIHN0b3Agd2l0aFxuICAgICAgICAgICAgLy8gJ0EgTWVkaWFTdHJlYW1UcmFjayBlbmRlZCBkdWUgdG8gYSBjYXB0dXJlIGZhaWx1cmVgXG4gICAgICAgICAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyB0cmFjayBhbmQgYXR0YWNoXG4gICAgICAgICAgICBjb25zdCBtZWRpYVN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHN0cmVhbUNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RyYWNrID0gbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKClbMF07XG4gICAgICAgICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZWJ1ZygncmUtYWNxdWlyZWQgTWVkaWFTdHJlYW1UcmFjaycpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKG5ld1RyYWNrKTtcbiAgICAgICAgICAgIHRoaXMubWVkaWFTdHJlYW1UcmFjayA9IG5ld1RyYWNrO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICAgICAgVHJhY2tfMS5hdHRhY2hUb0VsZW1lbnQobmV3VHJhY2ssIGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRUcmFja011dGVkKG11dGVkKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTXV0ZWQgPT09IG11dGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc011dGVkID0gbXV0ZWQ7XG4gICAgICAgIHRoaXMubWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIW11dGVkO1xuICAgICAgICB0aGlzLmVtaXQobXV0ZWQgPyBldmVudHNfMS5UcmFja0V2ZW50Lk11dGVkIDogZXZlbnRzXzEuVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBMb2NhbFRyYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9jYWxUcmFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xuY29uc3QgVHJhY2tQdWJsaWNhdGlvbl8xID0gcmVxdWlyZShcIi4vVHJhY2tQdWJsaWNhdGlvblwiKTtcbmNsYXNzIExvY2FsVHJhY2tQdWJsaWNhdGlvbiBleHRlbmRzIFRyYWNrUHVibGljYXRpb25fMS5UcmFja1B1YmxpY2F0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihraW5kLCB0aSwgdHJhY2spIHtcbiAgICAgICAgc3VwZXIoa2luZCwgdGkuc2lkLCB0aS5uYW1lKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUcmFja0VuZGVkID0gKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzEuVHJhY2tFdmVudC5FbmRlZCwgdHJhY2spO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUluZm8odGkpO1xuICAgICAgICB0aGlzLnNldFRyYWNrKHRyYWNrKTtcbiAgICB9XG4gICAgc2V0VHJhY2sodHJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2sub2ZmKGV2ZW50c18xLlRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc2V0VHJhY2sodHJhY2spO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIHRyYWNrLm9uKGV2ZW50c18xLlRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzTXV0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFjay5pc011dGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5pc011dGVkO1xuICAgIH1cbiAgICBnZXQgYXVkaW9UcmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmF1ZGlvVHJhY2s7XG4gICAgfVxuICAgIGdldCB2aWRlb1RyYWNrKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIudmlkZW9UcmFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXV0ZSB0aGUgdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb25cbiAgICAgKi9cbiAgICBtdXRlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm11dGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubXV0ZSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvblxuICAgICAqL1xuICAgIHVubXV0ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm11dGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTG9jYWxUcmFja1B1YmxpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9jYWxUcmFja1B1YmxpY2F0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyA9IGV4cG9ydHMudmlkZW9RdWFsaXR5Rm9yUmlkID0gdm9pZCAwO1xuY29uc3QgbG9nZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2xvZ2dlclwiKSk7XG5jb25zdCBsaXZla2l0X21vZGVsc18xID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzXCIpO1xuY29uc3Qgc3RhdHNfMSA9IHJlcXVpcmUoXCIuLi9zdGF0c1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBMb2NhbFRyYWNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTG9jYWxUcmFja1wiKSk7XG5jb25zdCBUcmFja18xID0gcmVxdWlyZShcIi4vVHJhY2tcIik7XG5jb25zdCB1dGlsc18yID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vLyBkZWxheSBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGdyYWRlXG5jb25zdCBRVUFMSVRZX1VQR1JBREVfREVMQVkgPSA2MCAqIDEwMDA7XG4vLyBhdm9pZCBkb3duZ3JhZGluZyB0b28gcXVpY2tseVxuY29uc3QgUVVBTElUWV9ET1dOR1JBREVfREVMQVkgPSA1ICogMTAwMDtcbmNvbnN0IHJpZE9yZGVyID0gWydxJywgJ2gnLCAnZiddO1xuY2xhc3MgTG9jYWxWaWRlb1RyYWNrIGV4dGVuZHMgTG9jYWxUcmFja18xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHN1cGVyKG1lZGlhVHJhY2ssIFRyYWNrXzEuVHJhY2suS2luZC5WaWRlbywgY29uc3RyYWludHMpO1xuICAgICAgICB0aGlzLm1vbml0b3JTZW5kZXIgPSAoZGlzYWJsZUxheWVyUGF1c2UpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLmdldFNlbmRlclN0YXRzKCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0c01hcCA9IG5ldyBNYXAoc3RhdHMubWFwKChzKSA9PiBbcy5yaWQsIHNdKSk7XG4gICAgICAgICAgICBpZiAoIWRpc2FibGVMYXllclBhdXNlICYmIHRoaXMucHJldlN0YXRzICYmIHRoaXMuaXNTaW11bGNhc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQW5kVXBkYXRlU2ltdWxjYXN0KHN0YXRzTWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZTdGF0cykge1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbEJpdHJhdGUgPSAwO1xuICAgICAgICAgICAgICAgIHN0YXRzTWFwLmZvckVhY2goKHMsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSAoX2EgPSB0aGlzLnByZXZTdGF0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbEJpdHJhdGUgKz0gc3RhdHNfMS5jb21wdXRlQml0cmF0ZShzLCBwcmV2KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IHRvdGFsQml0cmF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHNNYXA7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vbml0b3JTZW5kZXIoZGlzYWJsZUxheWVyUGF1c2UpO1xuICAgICAgICAgICAgfSwgc3RhdHNfMS5tb25pdG9yRnJlcXVlbmN5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpc1NpbXVsY2FzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VuZGVyICYmIHRoaXMuc2VuZGVyLmdldFBhcmFtZXRlcnMoKS5lbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKiBAaW50ZXJuYWwgKi9cbiAgICBzdGFydE1vbml0b3Ioc2lnbmFsQ2xpZW50LCBkaXNhYmxlTGF5ZXJQYXVzZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuc2lnbmFsQ2xpZW50ID0gc2lnbmFsQ2xpZW50O1xuICAgICAgICAvLyBzYXZlIG9yaWdpbmFsIGVuY29kaW5nc1xuICAgICAgICBjb25zdCBwYXJhbXMgPSAoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGluZ3MgPSBwYXJhbXMuZW5jb2RpbmdzO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb25pdG9yU2VuZGVyKGRpc2FibGVMYXllclBhdXNlKTtcbiAgICAgICAgfSwgc3RhdHNfMS5tb25pdG9yRnJlcXVlbmN5KTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zZW5kZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWVkaWFTdHJlYW1UcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgICAgICBzdXBlci5zdG9wKCk7XG4gICAgfVxuICAgIG11dGUoKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgbXV0ZTogeyBnZXQ6ICgpID0+IHN1cGVyLm11dGUgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2tfMS5UcmFjay5Tb3VyY2UuQ2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZWJ1Zygnc3RvcHBpbmcgY2FtZXJhIHRyYWNrJyk7XG4gICAgICAgICAgICAgICAgLy8gYWxzbyBzdG9wIHRoZSB0cmFjaywgc28gdGhhdCBjYW1lcmEgaW5kaWNhdG9yIGlzIHR1cm5lZCBvZmZcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgX3N1cGVyLm11dGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW5tdXRlKCkge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHVubXV0ZTogeyBnZXQ6ICgpID0+IHN1cGVyLnVubXV0ZSB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFja18xLlRyYWNrLlNvdXJjZS5DYW1lcmEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCdyZWFjcXVpcmluZyBjYW1lcmEgdHJhY2snKTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnRUcmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgX3N1cGVyLnVubXV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRTZW5kZXJTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgICAgICAgc3RhdHMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAodi50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1JZDogdi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSGVpZ2h0OiB2LmZyYW1lSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVXaWR0aDogdi5mcmFtZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyQ291bnQ6IHYuZmlyQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGlDb3VudDogdi5wbGlDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hY2tDb3VudDogdi5uYWNrQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRzU2VudDogdi5wYWNrZXRzU2VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzU2VudDogdi5ieXRlc1NlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZXNTZW50OiB2LmZyYW1lc1NlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlkOiAoX2EgPSB2LnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyYW5zbWl0dGVkUGFja2V0c1NlbnQ6IHYucmV0cmFuc21pdHRlZFBhY2tldHNTZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZWFzb246IHYucXVhbGl0eUxpbWl0YXRpb25SZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlc29sdXRpb25DaGFuZ2VzOiB2LnF1YWxpdHlMaW1pdGF0aW9uUmVzb2x1dGlvbkNoYW5nZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvY2F0ZSB0aGUgYXBwcm9wcmlhdGUgcmVtb3RlLWluYm91bmQtcnRwIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IHN0YXRzLmdldCh2LnJlbW90ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZzLmppdHRlciA9IHIuaml0dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdnMucGFja2V0c0xvc3QgPSByLnBhY2tldHNMb3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdnMucm91bmRUcmlwVGltZSA9IHIucm91bmRUcmlwVGltZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHZzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldFB1Ymxpc2hpbmdRdWFsaXR5KG1heFF1YWxpdHkpIHtcbiAgICAgICAgY29uc3QgcXVhbGl0aWVzID0gW107XG4gICAgICAgIGZvciAobGV0IHEgPSBsaXZla2l0X21vZGVsc18xLlZpZGVvUXVhbGl0eS5MT1c7IHEgPD0gbGl2ZWtpdF9tb2RlbHNfMS5WaWRlb1F1YWxpdHkuSElHSDsgcSArPSAxKSB7XG4gICAgICAgICAgICBxdWFsaXRpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcSxcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBxIDw9IG1heFF1YWxpdHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCdzZXR0aW5nIHB1Ymxpc2hpbmcgcXVhbGl0eS4gbWF4IHF1YWxpdHknLCBtYXhRdWFsaXR5KTtcbiAgICAgICAgdGhpcy5zZXRQdWJsaXNoaW5nTGF5ZXJzKHF1YWxpdGllcyk7XG4gICAgfVxuICAgIHNldERldmljZUlkKGRldmljZUlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdHJhaW50cy5kZXZpY2VJZCA9PT0gZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzLmRldmljZUlkID0gZGV2aWNlSWQ7XG4gICAgICAgICAgICAvLyB3aGVuIHZpZGVvIGlzIG11dGVkLCB1bmRlcmx5aW5nIG1lZGlhIHN0cmVhbSB0cmFjayBpcyBzdG9wcGVkIGFuZFxuICAgICAgICAgICAgLy8gd2lsbCBiZSByZXN0YXJ0ZWQgbGF0ZXJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3RhcnRUcmFjayhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgY29uc3RyYWludHM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbUNvbnN0cmFpbnRzID0gdXRpbHNfMi5jb25zdHJhaW50c0Zvck9wdGlvbnMoeyB2aWRlbzogb3B0aW9ucyB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0cmVhbUNvbnN0cmFpbnRzLnZpZGVvICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMgPSBzdHJlYW1Db25zdHJhaW50cy52aWRlbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoY29uc3RyYWludHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogU2V0cyBsYXllcnMgdGhhdCBzaG91bGQgYmUgcHVibGlzaGluZ1xuICAgICAqL1xuICAgIHNldFB1Ymxpc2hpbmdMYXllcnMocXVhbGl0aWVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCdzZXR0aW5nIHB1Ymxpc2hpbmcgbGF5ZXJzJywgcXVhbGl0aWVzKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZW5kZXIgfHwgIXRoaXMuZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICAgICAgY29uc3QgeyBlbmNvZGluZ3MgfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmICghZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuY29kaW5ncy5sZW5ndGggIT09IHRoaXMuZW5jb2RpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQud2FybignY2Fubm90IHNldCBwdWJsaXNoaW5nIGxheWVycywgZW5jb2RpbmdzIG1pc21hdGNoJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3RpdmVRdWFsaXRpZXMgPSBxdWFsaXRpZXM7XG4gICAgICAgICAgICBsZXQgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgbGV0IHJpZCA9IChfYSA9IGVuY29kaW5nLnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgICAgICAgICAgaWYgKHJpZCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlkID0gJ3EnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBxdWFsaXR5ID0gdmlkZW9RdWFsaXR5Rm9yUmlkKHJpZCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlZFF1YWxpdHkgPSBxdWFsaXRpZXMuZmluZCgocSkgPT4gcS5xdWFsaXR5ID09PSBxdWFsaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmliZWRRdWFsaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nLmFjdGl2ZSAhPT0gc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZWJ1Zyhgc2V0dGluZyBsYXllciAke3N1YnNjcmliZWRRdWFsaXR5LnF1YWxpdHl9IHRvICR7ZW5jb2RpbmcuYWN0aXZlID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJ31gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZUZveCBkb2VzIG5vdCBzdXBwb3J0IHNldHRpbmcgZW5jb2RpbmcuYWN0aXZlIHRvIGZhbHNlLCBzbyB3ZVxuICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIGEgd29ya2Fyb3VuZCBvZiBsb3dlcmluZyBpdHMgYml0cmF0ZSBhbmQgcmVzb2x1dGlvbiB0byB0aGUgbWluLlxuICAgICAgICAgICAgICAgICAgICBpZiAodXRpbHNfMS5pc0ZpcmVGb3goKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZWRRdWFsaXR5LmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSB0aGlzLmVuY29kaW5nc1tpZHhdLnNjYWxlUmVzb2x1dGlvbkRvd25CeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gdGhpcy5lbmNvZGluZ3NbaWR4XS5tYXhCaXRyYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhGcmFtZVJhdGUgPSB0aGlzLmVuY29kaW5nc1tpZHhdLm1heEZyYW1lUmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhGcmFtZVJhdGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hlY2tBbmRVcGRhdGVTaW11bGNhc3Qoc3RhdHNNYXApIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLnNlbmRlciB8fCB0aGlzLmlzTXV0ZWQgfHwgIXRoaXMuZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJlc3RFbmNvZGluZztcbiAgICAgICAgY29uc3QgeyBlbmNvZGluZ3MgfSA9IHRoaXMuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nKSA9PiB7XG4gICAgICAgICAgICAvLyBza2lwIGluYWN0aXZlIGVuY29kaW5nc1xuICAgICAgICAgICAgaWYgKCFlbmNvZGluZy5hY3RpdmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGJlc3RFbmNvZGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYmVzdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZXN0RW5jb2RpbmcucmlkXG4gICAgICAgICAgICAgICAgJiYgZW5jb2RpbmcucmlkXG4gICAgICAgICAgICAgICAgJiYgcmlkT3JkZXIuaW5kZXhPZihiZXN0RW5jb2RpbmcucmlkKSA8IHJpZE9yZGVyLmluZGV4T2YoZW5jb2RpbmcucmlkKSkge1xuICAgICAgICAgICAgICAgIGJlc3RFbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVzdEVuY29kaW5nLm1heEJpdHJhdGUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICYmIGVuY29kaW5nLm1heEJpdHJhdGUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICYmIGJlc3RFbmNvZGluZy5tYXhCaXRyYXRlIDwgZW5jb2RpbmcubWF4Qml0cmF0ZSkge1xuICAgICAgICAgICAgICAgIGJlc3RFbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFiZXN0RW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByaWQgPSAoX2EgPSBiZXN0RW5jb2RpbmcucmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgY29uc3Qgc2VuZFN0YXRzID0gc3RhdHNNYXAuZ2V0KHJpZCk7XG4gICAgICAgIGNvbnN0IGxhc3RTdGF0cyA9IChfYiA9IHRoaXMucHJldlN0YXRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KHJpZCk7XG4gICAgICAgIGlmICghc2VuZFN0YXRzIHx8ICFsYXN0U3RhdHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50UXVhbGl0eSA9IHZpZGVvUXVhbGl0eUZvclJpZChyaWQpO1xuICAgICAgICAvLyBhZGFwdGl2ZSBzaW11bGNhc3QgYWxnb3JpdGhtIG5vdGVzIChkYXZpZHpoYW8pXG4gICAgICAgIC8vIENocm9tZSAoYW5kIG90aGVyIGJyb3dzZXJzKSB3aWxsIGF1dG9tYXRpY2FsbHkgcGF1c2UgdGhlIGhpZ2hlc3QgbGF5ZXJcbiAgICAgICAgLy8gd2hlbiBpdCBydW5zIGludG8gYmFuZHdpZHRoIGxpbWl0YXRpb25zLiBXaGVuIHRoYXQgaGFwcGVucywgaXQgd291bGQgbm90XG4gICAgICAgIC8vIGJlIGFibGUgdG8gc2VuZCBhbnkgbmV3IGZyYW1lcyBiZXR3ZWVuIHRoZSB0d28gc3RhdHMgY2hlY2tzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHNldCB0aGF0IGxheWVyIHRvIGluYWN0aXZlIGludGVudGlvbmFsbHksIGJlY2F1c2UgY2hyb21lIHRlbmRzXG4gICAgICAgIC8vIHRvIGZsaWNrZXIsIG1lYW5pbmcgaXQgd2lsbCBhdHRlbXB0IHRvIHNlbmQgdGhhdCBsYXllciBhZ2FpbiBzaG9ydGx5XG4gICAgICAgIC8vIGFmdGVyd2FyZHMsIGZsaXAtZmxvcHBpbmcgZXZlcnkgZmV3IHNlY29uZHMuIFdlIHdhbnQgdG8gYXZvaWQgdGhhdC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZTogZXZlbiBhZnRlciBiYW5kd2lkdGggcmVjb3ZlcnMsIHRoZSBmbGlwLWZsb3BwaW5nIGJlaGF2aW9yIGNvbnRpbnVlc1xuICAgICAgICAvLyB0aGlzIGlzIHBvc3NpYmx5IGR1ZSB0byBTRlUtc2lkZSBQTEkgZ2VuZXJhdGlvbiBhbmQgaW1wZXJmZWN0IGJhbmR3aWR0aCBlc3RpbWF0aW9uXG4gICAgICAgIGlmIChzZW5kU3RhdHMucXVhbGl0eUxpbWl0YXRpb25SZXNvbHV0aW9uQ2hhbmdlc1xuICAgICAgICAgICAgLSBsYXN0U3RhdHMucXVhbGl0eUxpbWl0YXRpb25SZXNvbHV0aW9uQ2hhbmdlcyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFF1YWxpdHlDaGFuZ2UgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2cuZGVidWcoJ2ZyYW1lU2VudCcsIHNlbmRTdGF0cy5mcmFtZXNTZW50LCAnbGFzdFNlbnQnLCBsYXN0U3RhdHMuZnJhbWVzU2VudCxcbiAgICAgICAgLy8gICAnZWxhcHNlZCcsIHNlbmRTdGF0cy50aW1lc3RhbXAgLSBsYXN0U3RhdHMudGltZXN0YW1wKTtcbiAgICAgICAgaWYgKHNlbmRTdGF0cy5mcmFtZXNTZW50IC0gbGFzdFN0YXRzLmZyYW1lc1NlbnQgPiAwKSB7XG4gICAgICAgICAgICAvLyBmcmFtZXMgaGF2ZSBiZWVuIHNlbmRpbmcgb2ssIGNvbnNpZGVyIHVwZ3JhZGluZyBxdWFsaXR5XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1YWxpdHkgPT09IGxpdmVraXRfbW9kZWxzXzEuVmlkZW9RdWFsaXR5LkhJR0ggfHwgIXRoaXMubGFzdFF1YWxpdHlDaGFuZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgbmV4dFF1YWxpdHkgPSBjdXJyZW50UXVhbGl0eSArIDE7XG4gICAgICAgICAgICBpZiAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHRoaXMubGFzdFF1YWxpdHlDaGFuZ2UgPCBRVUFMSVRZX1VQR1JBREVfREVMQVkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVRdWFsaXRpZXNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmFjdGl2ZVF1YWxpdGllcy5zb21lKChxKSA9PiBxLnF1YWxpdHkgPT09IG5leHRRdWFsaXR5ICYmICFxLmVuYWJsZWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gcXVhbGl0eSBoYXMgYmVlbiBkaXNhYmxlZCBieSB0aGUgc2VydmVyLCBzbyB3ZSBzaG91bGQgc2tpcFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGFyZSBhbHJlYWR5IGF0IHRoZSBoaWdoZXN0IGxheWVyXG4gICAgICAgICAgICBsZXQgYmVzdFF1YWxpdHkgPSBsaXZla2l0X21vZGVsc18xLlZpZGVvUXVhbGl0eS5MT1c7XG4gICAgICAgICAgICBlbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVhbGl0eSA9IHZpZGVvUXVhbGl0eUZvclJpZCgoX2EgPSBlbmNvZGluZy5yaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgICAgICAgICBpZiAocXVhbGl0eSA+IGJlc3RRdWFsaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RRdWFsaXR5ID0gcXVhbGl0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChuZXh0UXVhbGl0eSA+IGJlc3RRdWFsaXR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZWJ1ZygndXBncmFkaW5nIHZpZGVvIHF1YWxpdHkgdG8nLCBuZXh0UXVhbGl0eSk7XG4gICAgICAgICAgICB0aGlzLnNldFB1Ymxpc2hpbmdRdWFsaXR5KG5leHRRdWFsaXR5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBiZXN0IGxheWVyIGhhcyBub3Qgc2VudCBhbnl0aGluZywgZG8gbm90IGRvd25ncmFkZSB0aWxsIHRoZVxuICAgICAgICAvLyBiZXN0IGxheWVyIHN0YXJ0cyBzZW5kaW5nIHNvbWV0aGluZy4gSXQgaXMgcG9zc2libGUgdGhhdCB0aGVcbiAgICAgICAgLy8gYnJvd3NlciBoYXMgbm90IHN0YXJ0ZWQgc29tZSBsYXllcihzKSBkdWUgdG8gY3B1L2JhbmR3aWR0aFxuICAgICAgICAvLyBjb25zdHJhaW50c1xuICAgICAgICBpZiAoc2VuZFN0YXRzLmZyYW1lc1NlbnQgPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGlmIHdlJ3ZlIHVwZ3JhZGVkIG9yIGRvd25ncmFkZWQgcmVjZW50bHksIGdpdmUgaXQgYSBiaXQgb2YgdGltZSBiZWZvcmVcbiAgICAgICAgLy8gZG93bmdyYWRpbmcgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMubGFzdEV4cGxpY2l0UXVhbGl0eUNoYW5nZVxuICAgICAgICAgICAgJiYgKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RFeHBsaWNpdFF1YWxpdHlDaGFuZ2UpIDwgUVVBTElUWV9ET1dOR1JBREVfREVMQVkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFF1YWxpdHkgPT09IGxpdmVraXRfbW9kZWxzXzEuVmlkZW9RdWFsaXR5LlVOUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50UXVhbGl0eSA9PT0gbGl2ZWtpdF9tb2RlbHNfMS5WaWRlb1F1YWxpdHkuTE9XKSB7XG4gICAgICAgICAgICAvLyBhbHJlYWR5IHRoZSBsb3dlc3QgcXVhbGl0eSwgbm90aGluZyB3ZSBjYW4gZG9cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlYnVnKCdkb3duZ3JhZGluZyB2aWRlbyBxdWFsaXR5IHRvJywgY3VycmVudFF1YWxpdHkgLSAxKTtcbiAgICAgICAgdGhpcy5zZXRQdWJsaXNoaW5nUXVhbGl0eShjdXJyZW50UXVhbGl0eSAtIDEpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IExvY2FsVmlkZW9UcmFjaztcbmZ1bmN0aW9uIHZpZGVvUXVhbGl0eUZvclJpZChyaWQpIHtcbiAgICBzd2l0Y2ggKHJpZCkge1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIHJldHVybiBsaXZla2l0X21vZGVsc18xLlZpZGVvUXVhbGl0eS5ISUdIO1xuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIHJldHVybiBsaXZla2l0X21vZGVsc18xLlZpZGVvUXVhbGl0eS5NRURJVU07XG4gICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgcmV0dXJuIGxpdmVraXRfbW9kZWxzXzEuVmlkZW9RdWFsaXR5LkxPVztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBsaXZla2l0X21vZGVsc18xLlZpZGVvUXVhbGl0eS5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0cy52aWRlb1F1YWxpdHlGb3JSaWQgPSB2aWRlb1F1YWxpdHlGb3JSaWQ7XG5mdW5jdGlvbiB2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3Mod2lkdGgsIGhlaWdodCwgZW5jb2RpbmdzKSB7XG4gICAgLy8gZGVmYXVsdCB0byBhIHNpbmdsZSBsYXllciwgSFFcbiAgICBpZiAoIWVuY29kaW5ncykge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICBxdWFsaXR5OiBsaXZla2l0X21vZGVsc18xLlZpZGVvUXVhbGl0eS5ISUdILFxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICAgICAgICAgIHNzcmM6IDAsXG4gICAgICAgICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kaW5ncy5tYXAoKGVuY29kaW5nKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBzY2FsZSA9IChfYSA9IGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcbiAgICAgICAgbGV0IHF1YWxpdHkgPSB2aWRlb1F1YWxpdHlGb3JSaWQoKF9iID0gZW5jb2RpbmcucmlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyk7XG4gICAgICAgIGlmIChxdWFsaXR5ID09PSBsaXZla2l0X21vZGVsc18xLlZpZGVvUXVhbGl0eS5VTlJFQ09HTklaRUQgJiYgZW5jb2RpbmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcXVhbGl0eSA9IGxpdmVraXRfbW9kZWxzXzEuVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHF1YWxpdHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGggLyBzY2FsZSxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC8gc2NhbGUsXG4gICAgICAgICAgICBiaXRyYXRlOiAoX2MgPSBlbmNvZGluZy5tYXhCaXRyYXRlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwLFxuICAgICAgICAgICAgc3NyYzogMCxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmV4cG9ydHMudmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzID0gdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9jYWxWaWRlb1RyYWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBzdGF0c18xID0gcmVxdWlyZShcIi4uL3N0YXRzXCIpO1xuY29uc3QgUmVtb3RlVHJhY2tfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9SZW1vdGVUcmFja1wiKSk7XG5jb25zdCBUcmFja18xID0gcmVxdWlyZShcIi4vVHJhY2tcIik7XG5jbGFzcyBSZW1vdGVBdWRpb1RyYWNrIGV4dGVuZHMgUmVtb3RlVHJhY2tfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyKSB7XG4gICAgICAgIHN1cGVyKG1lZGlhVHJhY2ssIHNpZCwgVHJhY2tfMS5UcmFjay5LaW5kLkF1ZGlvLCByZWNlaXZlcik7XG4gICAgICAgIHRoaXMubW9uaXRvclJlY2VpdmVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5nZXRSZWNlaXZlclN0YXRzKCk7XG4gICAgICAgICAgICBpZiAoc3RhdHMgJiYgdGhpcy5wcmV2U3RhdHMgJiYgdGhpcy5yZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gc3RhdHNfMS5jb21wdXRlQml0cmF0ZShzdGF0cywgdGhpcy5wcmV2U3RhdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubW9uaXRvclJlY2VpdmVyKCk7XG4gICAgICAgICAgICB9LCBzdGF0c18xLm1vbml0b3JGcmVxdWVuY3kpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UmVjZWl2ZXJTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgICAgICAgICAgbGV0IHJlY2VpdmVyU3RhdHM7XG4gICAgICAgICAgICBzdGF0cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlclN0YXRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNSZWNlaXZlZDogdi5ieXRlc1JlY2VpdmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uY2VhbGVkU2FtcGxlczogdi5jb25jZWFsZWRTYW1wbGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uY2VhbG1lbnRFdmVudHM6IHYuY29uY2VhbG1lbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWxlbnRDb25jZWFsZWRTYW1wbGVzOiB2LnNpbGVudENvbmNlYWxlZFNhbXBsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWxlbnRDb25jZWFsbWVudEV2ZW50czogdi5zaWxlbnRDb25jZWFsbWVudEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsQXVkaW9FbmVyZ3k6IHYudG90YWxBdWRpb0VuZXJneSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU2FtcGxlc0R1cmF0aW9uOiB2LnRvdGFsU2FtcGxlc0R1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVyU3RhdHM7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJlbW90ZUF1ZGlvVHJhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW1vdGVBdWRpb1RyYWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xuY29uc3Qgc3RhdHNfMSA9IHJlcXVpcmUoXCIuLi9zdGF0c1wiKTtcbmNvbnN0IFRyYWNrXzEgPSByZXF1aXJlKFwiLi9UcmFja1wiKTtcbmNsYXNzIFJlbW90ZVRyYWNrIGV4dGVuZHMgVHJhY2tfMS5UcmFjayB7XG4gICAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCBraW5kLCByZWNlaXZlcikge1xuICAgICAgICBzdXBlcihtZWRpYVRyYWNrLCBraW5kKTtcbiAgICAgICAgdGhpcy5zaWQgPSBzaWQ7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHNldE11dGVkKG11dGVkKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTXV0ZWQgIT09IG11dGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzTXV0ZWQgPSBtdXRlZDtcbiAgICAgICAgICAgIHRoaXMuZW1pdChtdXRlZCA/IGV2ZW50c18xLlRyYWNrRXZlbnQuTXV0ZWQgOiBldmVudHNfMS5UcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzZXRNZWRpYVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYWNrIGlzIGZpbmlzaGVkXG4gICAgICAgIC8vIHdlIHNlbmQgZWFjaCB0cmFjayBkb3duIGluIGl0cyBvd24gTWVkaWFTdHJlYW0sIHNvIHdlIGNhbiBhc3N1bWUgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgdHJhY2sgaXMgdGhlIG9ubHkgb25lIHRoYXQgY2FuIGJlIHJlbW92ZWQuXG4gICAgICAgIHN0cmVhbS5vbnJlbW92ZXRyYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMS5UcmFja0V2ZW50LkVuZGVkLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRNb25pdG9yKCk7XG4gICAgICAgIC8vIHVzZSBgZW5hYmxlZGAgb2YgdHJhY2sgdG8gZW5hYmxlIHJlLXVzZSBvZiB0cmFuc2NlaXZlclxuICAgICAgICBzdXBlci5lbmFibGUoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgLy8gdXNlIGBlbmFibGVkYCBvZiB0cmFjayB0byBlbmFibGUgcmUtdXNlIG9mIHRyYW5zY2VpdmVyXG4gICAgICAgIHN1cGVyLmRpc2FibGUoKTtcbiAgICB9XG4gICAgLyogQGludGVybmFsICovXG4gICAgc3RhcnRNb25pdG9yKCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubW9uaXRvclJlY2VpdmVyKCk7XG4gICAgICAgIH0sIHN0YXRzXzEubW9uaXRvckZyZXF1ZW5jeSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUmVtb3RlVHJhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW1vdGVUcmFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGxvZ2dlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9sb2dnZXJcIikpO1xuY29uc3QgbGl2ZWtpdF9tb2RlbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9saXZla2l0X21vZGVsc1wiKTtcbmNvbnN0IGxpdmVraXRfcnRjXzEgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbGl2ZWtpdF9ydGNcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCIuLi9ldmVudHNcIik7XG5jb25zdCBSZW1vdGVWaWRlb1RyYWNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUmVtb3RlVmlkZW9UcmFja1wiKSk7XG5jb25zdCBUcmFja1B1YmxpY2F0aW9uXzEgPSByZXF1aXJlKFwiLi9UcmFja1B1YmxpY2F0aW9uXCIpO1xuY2xhc3MgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiBleHRlbmRzIFRyYWNrUHVibGljYXRpb25fMS5UcmFja1B1YmxpY2F0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9hbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgPSBsaXZla2l0X21vZGVsc18xLlZpZGVvUXVhbGl0eS5ISUdIO1xuICAgICAgICB0aGlzLmhhbmRsZUVuZGVkID0gKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzEuVHJhY2tFdmVudC5FbmRlZCwgdHJhY2spO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSAodmlzaWJsZSkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZWJ1ZygnYWRhcHRpdmVzdHJlYW0gdmlkZW8gdmlzaWJpbGl0eScsIHRoaXMudHJhY2tTaWQsIGB2aXNpYmxlPSR7dmlzaWJsZX1gKTtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWQgPSAhdmlzaWJsZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlID0gKGRpbWVuc2lvbnMpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVidWcoJ2FkYXB0aXZlc3RyZWFtIHZpZGVvIGRpbWVuc2lvbnMnLCB0aGlzLnRyYWNrU2lkLCBgJHtkaW1lbnNpb25zLndpZHRofXgke2RpbWVuc2lvbnMuaGVpZ2h0fWApO1xuICAgICAgICAgICAgdGhpcy52aWRlb0RpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgICAgICAgICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHRvIHRoaXMgcmVtb3RlIHRyYWNrXG4gICAgICogQHBhcmFtIHN1YnNjcmliZWQgdHJ1ZSB0byBzdWJzY3JpYmUgdG8gYSB0cmFjaywgZmFsc2UgdG8gdW5zdWJzY3JpYmVcbiAgICAgKi9cbiAgICBzZXRTdWJzY3JpYmVkKHN1YnNjcmliZWQpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gc3Vic2NyaWJlZDtcbiAgICAgICAgY29uc3Qgc3ViID0ge1xuICAgICAgICAgICAgdHJhY2tTaWRzOiBbdGhpcy50cmFja1NpZF0sXG4gICAgICAgICAgICBzdWJzY3JpYmU6IHRoaXMuc3Vic2NyaWJlZCxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50VHJhY2tzOiBbe1xuICAgICAgICAgICAgICAgICAgICAvLyBzZW5kaW5nIGFuIGVtcHR5IHBhcnRpY2lwYW50IGlkIHNpbmNlIFRyYWNrUHVibGljYXRpb24gZG9lc24ndCBrZWVwIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgZmlsbGVkIGluIGJ5IHRoZSBwYXJ0aWNpcGFudCB0aGF0IHJlY2VpdmVzIHRoaXMgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudFNpZDogJycsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzEuVHJhY2tFdmVudC5VcGRhdGVTdWJzY3JpcHRpb24sIHN1Yik7XG4gICAgfVxuICAgIGdldCBzdWJzY3JpcHRpb25TdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliZWQgPT09IGZhbHNlIHx8ICFzdXBlci5pc1N1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uXzEuVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMuVW5zdWJzY3JpYmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fYWxsb3dlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb25fMS5UcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5Ob3RBbGxvd2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uXzEuVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMuU3Vic2NyaWJlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRyYWNrIGlzIHN1YnNjcmliZWQsIGFuZCByZWFkeSBmb3IgcGxheWJhY2tcbiAgICAgKi9cbiAgICBnZXQgaXNTdWJzY3JpYmVkKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fYWxsb3dlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5pc1N1YnNjcmliZWQ7XG4gICAgfVxuICAgIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGlzYWJsZSBzZXJ2ZXIgZnJvbSBzZW5kaW5nIGRvd24gZGF0YSBmb3IgdGhpcyB0cmFjay4gdGhpcyBpcyB1c2VmdWwgd2hlblxuICAgICAqIHRoZSBwYXJ0aWNpcGFudCBpcyBvZmYgc2NyZWVuLCB5b3UgbWF5IGRpc2FibGUgc3RyZWFtaW5nIGRvd24gdGhlaXIgdmlkZW9cbiAgICAgKiB0byByZWR1Y2UgYmFuZHdpZHRoIHJlcXVpcmVtZW50c1xuICAgICAqIEBwYXJhbSBlbmFibGVkXG4gICAgICovXG4gICAgc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSB8fCB0aGlzLmRpc2FibGVkID09PSAhZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSAhZW5hYmxlZDtcbiAgICAgICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZm9yIHRyYWNrcyB0aGF0IHN1cHBvcnQgc2ltdWxjYXN0aW5nLCBhZGp1c3Qgc3Vic2NyaWJlZCBxdWFsaXR5XG4gICAgICpcbiAgICAgKiBUaGlzIGluZGljYXRlcyB0aGUgaGlnaGVzdCBxdWFsaXR5IHRoZSBjbGllbnQgY2FuIGFjY2VwdC4gaWYgbmV0d29ya1xuICAgICAqIGJhbmR3aWR0aCBkb2VzIG5vdCBhbGxvdywgc2VydmVyIHdpbGwgYXV0b21hdGljYWxseSByZWR1Y2UgcXVhbGl0eSB0b1xuICAgICAqIG9wdGltaXplIGZvciB1bmludGVycnVwdGVkIHZpZGVvXG4gICAgICovXG4gICAgc2V0VmlkZW9RdWFsaXR5KHF1YWxpdHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpIHx8IHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9PT0gcXVhbGl0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9IHF1YWxpdHk7XG4gICAgICAgIHRoaXMudmlkZW9EaW1lbnNpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICAgIH1cbiAgICBzZXRWaWRlb0RpbWVuc2lvbnMoZGltZW5zaW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfYSA9IHRoaXMudmlkZW9EaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2lkdGgpID09PSBkaW1lbnNpb25zLndpZHRoXG4gICAgICAgICAgICAmJiAoKF9iID0gdGhpcy52aWRlb0RpbWVuc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHQpID09PSBkaW1lbnNpb25zLmhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYWNrIGluc3RhbmNlb2YgUmVtb3RlVmlkZW9UcmFja18xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9EaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gICAgfVxuICAgIGdldCB2aWRlb1F1YWxpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHk7XG4gICAgfVxuICAgIHNldFRyYWNrKHRyYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICAgICAgICAvLyB1bnJlZ2lzdGVyIGxpc3RlbmVyXG4gICAgICAgICAgICB0aGlzLnRyYWNrLm9mZihldmVudHNfMS5UcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2sub2ZmKGV2ZW50c18xLlRyYWNrRXZlbnQuVmlzaWJpbGl0eUNoYW5nZWQsIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrLm9mZihldmVudHNfMS5UcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5zZXRUcmFjayh0cmFjayk7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgdHJhY2suc2lkID0gdGhpcy50cmFja1NpZDtcbiAgICAgICAgICAgIHRyYWNrLm9uKGV2ZW50c18xLlRyYWNrRXZlbnQuVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCwgdGhpcy5oYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UpO1xuICAgICAgICAgICAgdHJhY2sub24oZXZlbnRzXzEuVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgICAgICAgIHRyYWNrLm9uKGV2ZW50c18xLlRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlci51cGRhdGVJbmZvKGluZm8pO1xuICAgICAgICB0aGlzLm1ldGFkYXRhTXV0ZWQgPSBpbmZvLm11dGVkO1xuICAgICAgICAoX2EgPSB0aGlzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0TXV0ZWQoaW5mby5tdXRlZCk7XG4gICAgfVxuICAgIGlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBZGFwdGl2ZVN0cmVhbSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC53YXJuKCdhZGFwdGl2ZSBzdHJlYW0gaXMgZW5hYmxlZCwgY2Fubm90IGNoYW5nZSB0cmFjayBzZXR0aW5ncycsIHRoaXMudHJhY2tTaWQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1N1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQud2FybignY2Fubm90IHVwZGF0ZSB0cmFjayBzZXR0aW5ncyB3aGVuIG5vdCBzdWJzY3JpYmVkJywgdGhpcy50cmFja1NpZCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBpc0FkYXB0aXZlU3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFjayBpbnN0YW5jZW9mIFJlbW90ZVZpZGVvVHJhY2tfMS5kZWZhdWx0ICYmIHRoaXMudHJhY2suaXNBZGFwdGl2ZVN0cmVhbTtcbiAgICB9XG4gICAgLyogQGludGVybmFsICovXG4gICAgZW1pdFRyYWNrVXBkYXRlKCkge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGxpdmVraXRfcnRjXzEuVXBkYXRlVHJhY2tTZXR0aW5ncy5mcm9tUGFydGlhbCh7XG4gICAgICAgICAgICB0cmFja1NpZHM6IFt0aGlzLnRyYWNrU2lkXSxcbiAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMudmlkZW9EaW1lbnNpb25zKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy53aWR0aCA9IHRoaXMudmlkZW9EaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgc2V0dGluZ3MuaGVpZ2h0ID0gdGhpcy52aWRlb0RpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5xdWFsaXR5ID0gdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVmYXVsdHMgdG8gaGlnaCBxdWFsaXR5XG4gICAgICAgICAgICBzZXR0aW5ncy5xdWFsaXR5ID0gbGl2ZWtpdF9tb2RlbHNfMS5WaWRlb1F1YWxpdHkuSElHSDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzEuVHJhY2tFdmVudC5VcGRhdGVTZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJlbW90ZVRyYWNrUHVibGljYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW1vdGVUcmFja1B1YmxpY2F0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c19kZWJvdW5jZV8xID0gcmVxdWlyZShcInRzLWRlYm91bmNlXCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xuY29uc3Qgc3RhdHNfMSA9IHJlcXVpcmUoXCIuLi9zdGF0c1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBSZW1vdGVUcmFja18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1JlbW90ZVRyYWNrXCIpKTtcbmNvbnN0IFRyYWNrXzEgPSByZXF1aXJlKFwiLi9UcmFja1wiKTtcbmNvbnN0IFJFQUNUSU9OX0RFTEFZID0gMTAwO1xuY2xhc3MgUmVtb3RlVmlkZW9UcmFjayBleHRlbmRzIFJlbW90ZVRyYWNrXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW0pIHtcbiAgICAgICAgc3VwZXIobWVkaWFUcmFjaywgc2lkLCBUcmFja18xLlRyYWNrLktpbmQuVmlkZW8sIHJlY2VpdmVyKTtcbiAgICAgICAgdGhpcy5lbGVtZW50SW5mb3MgPSBbXTtcbiAgICAgICAgdGhpcy5tb25pdG9yUmVjZWl2ZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLmdldFJlY2VpdmVyU3RhdHMoKTtcbiAgICAgICAgICAgIGlmIChzdGF0cyAmJiB0aGlzLnByZXZTdGF0cyAmJiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSBzdGF0c18xLmNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb25pdG9yUmVjZWl2ZXIoKTtcbiAgICAgICAgICAgIH0sIHN0YXRzXzEubW9uaXRvckZyZXF1ZW5jeSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkID0gKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHRhcmdldCwgaXNJbnRlcnNlY3RpbmcgfSA9IGVudHJ5O1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudEluZm8gPSB0aGlzLmVsZW1lbnRJbmZvcy5maW5kKChpbmZvKSA9PiBpbmZvLmVsZW1lbnQgPT09IHRhcmdldCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudEluZm8pIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50SW5mby52aXNpYmxlID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAgICAgZWxlbWVudEluZm8udmlzaWJpbGl0eUNoYW5nZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRIYW5kbGVSZXNpemUgPSB0c19kZWJvdW5jZV8xLmRlYm91bmNlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICB9LCBSRUFDVElPTl9ERUxBWSk7XG4gICAgICAgIHRoaXMuYWRhcHRpdmVTdHJlYW0gPSBhZGFwdGl2ZVN0cmVhbTtcbiAgICB9XG4gICAgZ2V0IGlzQWRhcHRpdmVTdHJlYW0oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuYWRhcHRpdmVTdHJlYW0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc2V0TXV0ZWQobXV0ZWQpIHtcbiAgICAgICAgc3VwZXIuc2V0TXV0ZWQobXV0ZWQpO1xuICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgLy8gZGV0YWNoIG9yIGF0dGFjaFxuICAgICAgICAgICAgaWYgKG11dGVkKSB7XG4gICAgICAgICAgICAgICAgVHJhY2tfMS5kZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgVHJhY2tfMS5hdHRhY2hUb0VsZW1lbnQodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF0dGFjaChlbGVtZW50KSB7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHN1cGVyLmF0dGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIuYXR0YWNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0J3MgcG9zc2libGUgYXR0YWNoIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBvbiBhbiBlbGVtZW50LiBXaGVuIHRoYXQnc1xuICAgICAgICAvLyB0aGUgY2FzZSwgd2UnZCB3YW50IHRvIGF2b2lkIGFkZGluZyBkdXBsaWNhdGUgZWxlbWVudEluZm9zXG4gICAgICAgIGlmICh0aGlzLmFkYXB0aXZlU3RyZWFtXG4gICAgICAgICAgICAmJiB0aGlzLmVsZW1lbnRJbmZvcy5maW5kKChpbmZvKSA9PiBpbmZvLmVsZW1lbnQgPT09IGVsZW1lbnQpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudEluZm9zLnB1c2goe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSwgLy8gZGVmYXVsdCB2aXNpYmxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAuaGFuZGxlUmVzaXplID0gdGhpcy5kZWJvdW5jZWRIYW5kbGVSZXNpemU7XG4gICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAgICAgLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkID0gdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZDtcbiAgICAgICAgICAgIHV0aWxzXzEuZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKS5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgdXRpbHNfMS5nZXRSZXNpemVPYnNlcnZlcigpLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdCByZXNpemUgdXBkYXRlIGN5Y2xlXG4gICAgICAgICAgICAvLyBpZiB0aGUgdGFiIGlzIGJhY2tncm91bmRlZCwgdGhlIGluaXRpYWwgcmVzaXplIGV2ZW50IGRvZXMgbm90IGZpcmUgdW50aWxcbiAgICAgICAgICAgIC8vIHRoZSB0YWIgY29tZXMgaW50byBmb2N1cyBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBkZXRhY2goZWxlbWVudCkge1xuICAgICAgICBsZXQgZGV0YWNoZWRFbGVtZW50cyA9IFtdO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5kZXRhY2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWNoZWRFbGVtZW50cyA9IHN1cGVyLmRldGFjaCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZGV0YWNoZWRFbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGV0YWNoZWRFbGVtZW50cztcbiAgICB9XG4gICAgZ2V0UmVjZWl2ZXJTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgICAgICAgICAgbGV0IHJlY2VpdmVyU3RhdHM7XG4gICAgICAgICAgICBzdGF0cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlclN0YXRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lc0RlY29kZWQ6IHYuZnJhbWVzRGVjb2RlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lc0Ryb3BwZWQ6IHYuZnJhbWVzRHJvcHBlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lc1JlY2VpdmVkOiB2LmZyYW1lc1JlY2VpdmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0c1JlY2VpdmVkOiB2LnBhY2tldHNSZWNlaXZlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2tldHNMb3N0OiB2LnBhY2tldHNMb3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVXaWR0aDogdi5mcmFtZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVIZWlnaHQ6IHYuZnJhbWVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGlDb3VudDogdi5wbGlDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpckNvdW50OiB2LmZpckNvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFja0NvdW50OiB2Lm5hY2tDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGppdHRlcjogdi5qaXR0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNSZWNlaXZlZDogdi5ieXRlc1JlY2VpdmVkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVyU3RhdHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9wT2JzZXJ2aW5nRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYSA9IHV0aWxzXzEuZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgKF9iID0gdXRpbHNfMS5nZXRSZXNpemVPYnNlcnZlcigpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLmVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcigoaW5mbykgPT4gaW5mby5lbGVtZW50ICE9PSBlbGVtZW50KTtcbiAgICB9XG4gICAgdXBkYXRlVmlzaWJpbGl0eSgpIHtcbiAgICAgICAgY29uc3QgbGFzdFZpc2liaWxpdHlDaGFuZ2UgPSB0aGlzLmVsZW1lbnRJbmZvcy5yZWR1Y2UoKHByZXYsIGluZm8pID0+IE1hdGgubWF4KHByZXYsIGluZm8udmlzaWJpbGl0eUNoYW5nZWRBdCB8fCAwKSwgMCk7XG4gICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IHRoaXMuZWxlbWVudEluZm9zLnNvbWUoKGluZm8pID0+IGluZm8udmlzaWJsZSk7XG4gICAgICAgIGlmICh0aGlzLmxhc3RWaXNpYmxlID09PSBpc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmlzaWJsZSAmJiBEYXRlLm5vdygpIC0gbGFzdFZpc2liaWxpdHlDaGFuZ2UgPCBSRUFDVElPTl9ERUxBWSkge1xuICAgICAgICAgICAgLy8gZGVsYXkgaGlkZGVuIGV2ZW50c1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICAgICAgICB9LCBSRUFDVElPTl9ERUxBWSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0VmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18xLlRyYWNrRXZlbnQuVmlzaWJpbGl0eUNoYW5nZWQsIGlzVmlzaWJsZSwgdGhpcyk7XG4gICAgfVxuICAgIHVwZGF0ZURpbWVuc2lvbnMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBtYXhXaWR0aCA9IDA7XG4gICAgICAgIGxldCBtYXhIZWlnaHQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGluZm8gb2YgdGhpcy5lbGVtZW50SW5mb3MpIHtcbiAgICAgICAgICAgIGlmIChpbmZvLmVsZW1lbnQuY2xpZW50V2lkdGggKyBpbmZvLmVsZW1lbnQuY2xpZW50SGVpZ2h0ID4gbWF4V2lkdGggKyBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IGluZm8uZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBpbmZvLmVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5sYXN0RGltZW5zaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpZHRoKSA9PT0gbWF4V2lkdGggJiYgKChfYiA9IHRoaXMubGFzdERpbWVuc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHQpID09PSBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3REaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgd2lkdGg6IG1heFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBtYXhIZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdChldmVudHNfMS5UcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMubGFzdERpbWVuc2lvbnMsIHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJlbW90ZVZpZGVvVHJhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW1vdGVWaWRlb1RyYWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXRhY2hUcmFjayA9IGV4cG9ydHMuYXR0YWNoVG9FbGVtZW50ID0gZXhwb3J0cy5UcmFjayA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGxpdmVraXRfbW9kZWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbGl2ZWtpdF9tb2RlbHNcIik7XG5jb25zdCBsaXZla2l0X3J0Y18xID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL2xpdmVraXRfcnRjXCIpO1xuY29uc3QgZXZlbnRzXzIgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbi8vIGtlZXAgb2xkIGF1ZGlvIGVsZW1lbnRzIHdoZW4gZGV0YWNoZWQsIHdlIHdvdWxkIHJlLXVzZSB0aGVtIHNpbmNlIG9uIGlPU1xuLy8gU2FmYXJpIHRyYWNrcyB3aGljaCBhdWRpbyBlbGVtZW50cyBoYXZlIGJlZW4gXCJibGVzc2VkXCIgYnkgdGhlIHVzZXIuXG5jb25zdCByZWN5Y2xlZEVsZW1lbnRzID0gW107XG5jbGFzcyBUcmFjayBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IobWVkaWFUcmFjaywga2luZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5pc011dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RyZWFtU3RhdGUgPSBUcmFjay5TdHJlYW1TdGF0ZS5BY3RpdmU7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgdGhpcy5tZWRpYVN0cmVhbVRyYWNrID0gbWVkaWFUcmFjaztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuVW5rbm93bjtcbiAgICB9XG4gICAgLyoqIGN1cnJlbnQgcmVjZWl2ZSBiaXRzIHBlciBzZWNvbmQgKi9cbiAgICBnZXQgY3VycmVudEJpdHJhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50Qml0cmF0ZTtcbiAgICB9XG4gICAgYXR0YWNoKGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IGVsZW1lbnRUeXBlID0gJ2F1ZGlvJztcbiAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICAgICAgZWxlbWVudFR5cGUgPSAndmlkZW8nO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnBhcmVudEVsZW1lbnQgPT09IG51bGwgJiYgIWVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gcG9vbFxuICAgICAgICAgICAgICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLnNwbGljZShyZWN5Y2xlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYXR0YWNoZWRFbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXZlbiBpZiB3ZSBiZWxpZXZlIGl0J3MgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudCwgaXQncyBwb3NzaWJsZVxuICAgICAgICAvLyB0aGUgZWxlbWVudCdzIHNyY09iamVjdCB3YXMgc2V0IHRvIHNvbWV0aGluZyBlbHNlIG91dCBvZiBiYW5kLlxuICAgICAgICAvLyB3ZSdsbCB3YW50IHRvIHJlLWF0dGFjaCBpdCBpbiB0aGF0IGNhc2VcbiAgICAgICAgYXR0YWNoVG9FbGVtZW50KHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEF1ZGlvRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gbWFudWFsbHkgcGxheSBhdWRpbyB0byBkZXRlY3QgYXVkaW8gcGxheWJhY2sgc3RhdHVzXG4gICAgICAgICAgICBlbGVtZW50LnBsYXkoKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRzXzIuVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrU3RhcnRlZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5UcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGRldGFjaChlbGVtZW50KSB7XG4gICAgICAgIC8vIGRldGFjaCBmcm9tIGEgc2luZ2xlIGVsZW1lbnRcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLmF0dGFjaGVkRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY3ljbGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGV0YWNoZWQgPSBbXTtcbiAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goKGVsbSkgPT4ge1xuICAgICAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbG0pO1xuICAgICAgICAgICAgZGV0YWNoZWQucHVzaChlbG0pO1xuICAgICAgICAgICAgdGhpcy5yZWN5Y2xlRWxlbWVudChlbG0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCB0cmFja3NcbiAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzID0gW107XG4gICAgICAgIHJldHVybiBkZXRhY2hlZDtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICB9XG4gICAgZW5hYmxlKCkge1xuICAgICAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMubWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJlY3ljbGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQXVkaW9FbGVtZW50KSB7XG4gICAgICAgICAgICAvLyB3ZSBvbmx5IG5lZWQgdG8gcmUtdXNlIGEgc2luZ2xlIGVsZW1lbnRcbiAgICAgICAgICAgIGxldCBzaG91bGRDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICBlbGVtZW50LnBhdXNlKCk7XG4gICAgICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWUucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRDYWNoZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNob3VsZENhY2hlKSB7XG4gICAgICAgICAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UcmFjayA9IFRyYWNrO1xuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gYXR0YWNoVG9FbGVtZW50KHRyYWNrLCBlbGVtZW50KSB7XG4gICAgbGV0IG1lZGlhU3RyZWFtO1xuICAgIGlmIChlbGVtZW50LnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XG4gICAgICAgIG1lZGlhU3RyZWFtID0gZWxlbWVudC5zcmNPYmplY3Q7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiB0cmFjayBtYXRjaGVzIGV4aXN0aW5nIHRyYWNrXG4gICAgbGV0IGV4aXN0aW5nVHJhY2tzO1xuICAgIGlmICh0cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgIGV4aXN0aW5nVHJhY2tzID0gbWVkaWFTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nVHJhY2tzID0gbWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICB9XG4gICAgaWYgKCFleGlzdGluZ1RyYWNrcy5pbmNsdWRlcyh0cmFjaykpIHtcbiAgICAgICAgZXhpc3RpbmdUcmFja3MuZm9yRWFjaCgoZXQpID0+IHtcbiAgICAgICAgICAgIG1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKGV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1lZGlhU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICB9XG4gICAgLy8gYXZvaWQgZmxpY2tlclxuICAgIGlmIChlbGVtZW50LnNyY09iamVjdCAhPT0gbWVkaWFTdHJlYW0pIHtcbiAgICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgICAgICAgaWYgKHV0aWxzXzEuaXNTYWZhcmkoKSAmJiBlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDE1IGhhcyBhIGJ1ZyB3aGVyZSBpbiBjZXJ0YWluIGxheW91dHMsIHZpZGVvIGVsZW1lbnQgcmVuZGVyc1xuICAgICAgICAgICAgLy8gYmxhY2sgdW50aWwgdGhlIHBhZ2UgaXMgcmVzaXplZCBvciBvdGhlciBjaGFuZ2VzIHRha2UgcGxhY2UuXG4gICAgICAgICAgICAvLyBSZXNldHRpbmcgdGhlIHNyYyB0cmlnZ2VycyBpdCB0byByZW5kZXIuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9ydW1zL3RocmVhZC82OTA1MjNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50LmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5hdHRhY2hUb0VsZW1lbnQgPSBhdHRhY2hUb0VsZW1lbnQ7XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBkZXRhY2hUcmFjayh0cmFjaywgZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50LnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhU3RyZWFtID0gZWxlbWVudC5zcmNPYmplY3Q7XG4gICAgICAgIG1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuZGV0YWNoVHJhY2sgPSBkZXRhY2hUcmFjaztcbihmdW5jdGlvbiAoVHJhY2spIHtcbiAgICBsZXQgS2luZDtcbiAgICAoZnVuY3Rpb24gKEtpbmQpIHtcbiAgICAgICAgS2luZFtcIkF1ZGlvXCJdID0gXCJhdWRpb1wiO1xuICAgICAgICBLaW5kW1wiVmlkZW9cIl0gPSBcInZpZGVvXCI7XG4gICAgICAgIEtpbmRbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XG4gICAgfSkoS2luZCA9IFRyYWNrLktpbmQgfHwgKFRyYWNrLktpbmQgPSB7fSkpO1xuICAgIGxldCBTb3VyY2U7XG4gICAgKGZ1bmN0aW9uIChTb3VyY2UpIHtcbiAgICAgICAgU291cmNlW1wiQ2FtZXJhXCJdID0gXCJjYW1lcmFcIjtcbiAgICAgICAgU291cmNlW1wiTWljcm9waG9uZVwiXSA9IFwibWljcm9waG9uZVwiO1xuICAgICAgICBTb3VyY2VbXCJTY3JlZW5TaGFyZVwiXSA9IFwic2NyZWVuX3NoYXJlXCI7XG4gICAgICAgIFNvdXJjZVtcIlNjcmVlblNoYXJlQXVkaW9cIl0gPSBcInNjcmVlbl9zaGFyZV9hdWRpb1wiO1xuICAgICAgICBTb3VyY2VbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XG4gICAgfSkoU291cmNlID0gVHJhY2suU291cmNlIHx8IChUcmFjay5Tb3VyY2UgPSB7fSkpO1xuICAgIGxldCBTdHJlYW1TdGF0ZTtcbiAgICAoZnVuY3Rpb24gKFN0cmVhbVN0YXRlKSB7XG4gICAgICAgIFN0cmVhbVN0YXRlW1wiQWN0aXZlXCJdID0gXCJhY3RpdmVcIjtcbiAgICAgICAgU3RyZWFtU3RhdGVbXCJQYXVzZWRcIl0gPSBcInBhdXNlZFwiO1xuICAgICAgICBTdHJlYW1TdGF0ZVtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcbiAgICB9KShTdHJlYW1TdGF0ZSA9IFRyYWNrLlN0cmVhbVN0YXRlIHx8IChUcmFjay5TdHJlYW1TdGF0ZSA9IHt9KSk7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZ1bmN0aW9uIGtpbmRUb1Byb3RvKGspIHtcbiAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgICAgICBjYXNlIEtpbmQuQXVkaW86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpdmVraXRfbW9kZWxzXzEuVHJhY2tUeXBlLkFVRElPO1xuICAgICAgICAgICAgY2FzZSBLaW5kLlZpZGVvOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaXZla2l0X21vZGVsc18xLlRyYWNrVHlwZS5WSURFTztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpdmVraXRfbW9kZWxzXzEuVHJhY2tUeXBlLlVOUkVDT0dOSVpFRDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjay5raW5kVG9Qcm90byA9IGtpbmRUb1Byb3RvO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmdW5jdGlvbiBraW5kRnJvbVByb3RvKHQpIHtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICBjYXNlIGxpdmVraXRfbW9kZWxzXzEuVHJhY2tUeXBlLkFVRElPOlxuICAgICAgICAgICAgICAgIHJldHVybiBLaW5kLkF1ZGlvO1xuICAgICAgICAgICAgY2FzZSBsaXZla2l0X21vZGVsc18xLlRyYWNrVHlwZS5WSURFTzpcbiAgICAgICAgICAgICAgICByZXR1cm4gS2luZC5WaWRlbztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEtpbmQuVW5rbm93bjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjay5raW5kRnJvbVByb3RvID0ga2luZEZyb21Qcm90bztcbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gc291cmNlVG9Qcm90byhzKSB7XG4gICAgICAgIHN3aXRjaCAocykge1xuICAgICAgICAgICAgY2FzZSBTb3VyY2UuQ2FtZXJhOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaXZla2l0X21vZGVsc18xLlRyYWNrU291cmNlLkNBTUVSQTtcbiAgICAgICAgICAgIGNhc2UgU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpdmVraXRfbW9kZWxzXzEuVHJhY2tTb3VyY2UuTUlDUk9QSE9ORTtcbiAgICAgICAgICAgIGNhc2UgU291cmNlLlNjcmVlblNoYXJlOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaXZla2l0X21vZGVsc18xLlRyYWNrU291cmNlLlNDUkVFTl9TSEFSRTtcbiAgICAgICAgICAgIGNhc2UgU291cmNlLlNjcmVlblNoYXJlQXVkaW86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpdmVraXRfbW9kZWxzXzEuVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFX0FVRElPO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGl2ZWtpdF9tb2RlbHNfMS5UcmFja1NvdXJjZS5VTlJFQ09HTklaRUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJhY2suc291cmNlVG9Qcm90byA9IHNvdXJjZVRvUHJvdG87XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZ1bmN0aW9uIHNvdXJjZUZyb21Qcm90byhzKSB7XG4gICAgICAgIHN3aXRjaCAocykge1xuICAgICAgICAgICAgY2FzZSBsaXZla2l0X21vZGVsc18xLlRyYWNrU291cmNlLkNBTUVSQTpcbiAgICAgICAgICAgICAgICByZXR1cm4gU291cmNlLkNhbWVyYTtcbiAgICAgICAgICAgIGNhc2UgbGl2ZWtpdF9tb2RlbHNfMS5UcmFja1NvdXJjZS5NSUNST1BIT05FOlxuICAgICAgICAgICAgICAgIHJldHVybiBTb3VyY2UuTWljcm9waG9uZTtcbiAgICAgICAgICAgIGNhc2UgbGl2ZWtpdF9tb2RlbHNfMS5UcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNvdXJjZS5TY3JlZW5TaGFyZTtcbiAgICAgICAgICAgIGNhc2UgbGl2ZWtpdF9tb2RlbHNfMS5UcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkVfQVVESU86XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gU291cmNlLlVua25vd247XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJhY2suc291cmNlRnJvbVByb3RvID0gc291cmNlRnJvbVByb3RvO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmdW5jdGlvbiBzdHJlYW1TdGF0ZUZyb21Qcm90byhzKSB7XG4gICAgICAgIHN3aXRjaCAocykge1xuICAgICAgICAgICAgY2FzZSBsaXZla2l0X3J0Y18xLlN0cmVhbVN0YXRlLkFDVElWRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUuQWN0aXZlO1xuICAgICAgICAgICAgY2FzZSBsaXZla2l0X3J0Y18xLlN0cmVhbVN0YXRlLlBBVVNFRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUuUGF1c2VkO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUuVW5rbm93bjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjay5zdHJlYW1TdGF0ZUZyb21Qcm90byA9IHN0cmVhbVN0YXRlRnJvbVByb3RvO1xufSkoVHJhY2sgPSBleHBvcnRzLlRyYWNrIHx8IChleHBvcnRzLlRyYWNrID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFja1B1YmxpY2F0aW9uID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgZXZlbnRzXzIgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xuY29uc3QgTG9jYWxBdWRpb1RyYWNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTG9jYWxBdWRpb1RyYWNrXCIpKTtcbmNvbnN0IExvY2FsVmlkZW9UcmFja18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0xvY2FsVmlkZW9UcmFja1wiKSk7XG5jb25zdCBSZW1vdGVBdWRpb1RyYWNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUmVtb3RlQXVkaW9UcmFja1wiKSk7XG5jb25zdCBSZW1vdGVWaWRlb1RyYWNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUmVtb3RlVmlkZW9UcmFja1wiKSk7XG5jb25zdCBUcmFja18xID0gcmVxdWlyZShcIi4vVHJhY2tcIik7XG5jbGFzcyBUcmFja1B1YmxpY2F0aW9uIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihraW5kLCBpZCwgbmFtZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhTXV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYW5kbGVNdXRlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudHNfMi5UcmFja0V2ZW50Lk11dGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVVbm11dGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50c18yLlRyYWNrRXZlbnQuVW5tdXRlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICAgIHRoaXMudHJhY2tTaWQgPSBpZDtcbiAgICAgICAgdGhpcy50cmFja05hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IFRyYWNrXzEuVHJhY2suU291cmNlLlVua25vd247XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzZXRUcmFjayh0cmFjaykge1xuICAgICAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgICAgICAgdGhpcy50cmFjay5vZmYoZXZlbnRzXzIuVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5oYW5kbGVNdXRlZCk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrLm9mZihldmVudHNfMi5UcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMuaGFuZGxlVW5tdXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjayA9IHRyYWNrO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIC8vIGZvcndhcmQgZXZlbnRzXG4gICAgICAgICAgICB0cmFjay5vbihldmVudHNfMi5UcmFja0V2ZW50Lk11dGVkLCB0aGlzLmhhbmRsZU11dGVkKTtcbiAgICAgICAgICAgIHRyYWNrLm9uKGV2ZW50c18yLlRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5oYW5kbGVVbm11dGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNNdXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGFNdXRlZDtcbiAgICB9XG4gICAgZ2V0IGlzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBpc1N1YnNjcmliZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFuIFtBdWRpb1RyYWNrXSBpZiB0aGlzIHB1YmxpY2F0aW9uIGhvbGRzIGFuIGF1ZGlvIHRyYWNrXG4gICAgICovXG4gICAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrXzEuZGVmYXVsdCB8fCB0aGlzLnRyYWNrIGluc3RhbmNlb2YgUmVtb3RlQXVkaW9UcmFja18xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFuIFtWaWRlb1RyYWNrXSBpZiB0aGlzIHB1YmxpY2F0aW9uIGhvbGRzIGEgdmlkZW8gdHJhY2tcbiAgICAgKi9cbiAgICBnZXQgdmlkZW9UcmFjaygpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2tfMS5kZWZhdWx0IHx8IHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVWaWRlb1RyYWNrXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHVwZGF0ZUluZm8oaW5mbykge1xuICAgICAgICB0aGlzLnRyYWNrU2lkID0gaW5mby5zaWQ7XG4gICAgICAgIHRoaXMudHJhY2tOYW1lID0gaW5mby5uYW1lO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IFRyYWNrXzEuVHJhY2suc291cmNlRnJvbVByb3RvKGluZm8uc291cmNlKTtcbiAgICAgICAgdGhpcy5taW1lVHlwZSA9IGluZm8ubWltZVR5cGU7XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrXzEuVHJhY2suS2luZC5WaWRlbyAmJiBpbmZvLndpZHRoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5kaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBpbmZvLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaW5mby5oZWlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zaW11bGNhc3RlZCA9IGluZm8uc2ltdWxjYXN0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tJbmZvID0gaW5mbztcbiAgICB9XG59XG5leHBvcnRzLlRyYWNrUHVibGljYXRpb24gPSBUcmFja1B1YmxpY2F0aW9uO1xuKGZ1bmN0aW9uIChUcmFja1B1YmxpY2F0aW9uKSB7XG4gICAgbGV0IFN1YnNjcmlwdGlvblN0YXR1cztcbiAgICAoZnVuY3Rpb24gKFN1YnNjcmlwdGlvblN0YXR1cykge1xuICAgICAgICBTdWJzY3JpcHRpb25TdGF0dXNbXCJTdWJzY3JpYmVkXCJdID0gXCJzdWJzY3JpYmVkXCI7XG4gICAgICAgIFN1YnNjcmlwdGlvblN0YXR1c1tcIk5vdEFsbG93ZWRcIl0gPSBcIm5vdF9hbGxvd2VkXCI7XG4gICAgICAgIFN1YnNjcmlwdGlvblN0YXR1c1tcIlVuc3Vic2NyaWJlZFwiXSA9IFwidW5zdWJzY3JpYmVkXCI7XG4gICAgfSkoU3Vic2NyaXB0aW9uU3RhdHVzID0gVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMgfHwgKFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzID0ge30pKTtcbn0pKFRyYWNrUHVibGljYXRpb24gPSBleHBvcnRzLlRyYWNrUHVibGljYXRpb24gfHwgKGV4cG9ydHMuVHJhY2tQdWJsaWNhdGlvbiA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFja1B1YmxpY2F0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUxvY2FsU2NyZWVuVHJhY2tzID0gZXhwb3J0cy5jcmVhdGVMb2NhbEF1ZGlvVHJhY2sgPSBleHBvcnRzLmNyZWF0ZUxvY2FsVmlkZW9UcmFjayA9IGV4cG9ydHMuY3JlYXRlTG9jYWxUcmFja3MgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBwdWJsaXNoVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9wYXJ0aWNpcGFudC9wdWJsaXNoVXRpbHNcIik7XG5jb25zdCBkZWZhdWx0c18xID0gcmVxdWlyZShcIi4vZGVmYXVsdHNcIik7XG5jb25zdCBMb2NhbEF1ZGlvVHJhY2tfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Mb2NhbEF1ZGlvVHJhY2tcIikpO1xuY29uc3QgTG9jYWxWaWRlb1RyYWNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTG9jYWxWaWRlb1RyYWNrXCIpKTtcbmNvbnN0IG9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL29wdGlvbnNcIik7XG5jb25zdCBUcmFja18xID0gcmVxdWlyZShcIi4vVHJhY2tcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIENyZWF0ZXMgYSBsb2NhbCB2aWRlbyBhbmQgYXVkaW8gdHJhY2sgYXQgdGhlIHNhbWUgdGltZS4gV2hlbiBhY3F1aXJpbmcgYm90aFxuICogYXVkaW8gYW5kIHZpZGVvIHRyYWNrcyB0b2dldGhlciwgaXQnbGwgZGlzcGxheSBhIHNpbmdsZSBwZXJtaXNzaW9uIHByb21wdCB0b1xuICogdGhlIHVzZXIgaW5zdGVhZCBvZiB0d28gc2VwYXJhdGUgb25lcy5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsVHJhY2tzKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnMgdG8gdHJ1ZVxuICAgICAgICBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgKF9hID0gb3B0aW9ucy5hdWRpbykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKG9wdGlvbnMuYXVkaW8gPSB0cnVlKTtcbiAgICAgICAgKF9iID0gb3B0aW9ucy52aWRlbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKG9wdGlvbnMudmlkZW8gPSB0cnVlKTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHV0aWxzXzEubWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0c18xLmF1ZGlvRGVmYXVsdHMsIGRlZmF1bHRzXzEudmlkZW9EZWZhdWx0cyk7XG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdXRpbHNfMS5jb25zdHJhaW50c0Zvck9wdGlvbnMob3B0cyk7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5nZXRUcmFja3MoKS5tYXAoKG1lZGlhU3RyZWFtVHJhY2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQXVkaW8gPSBtZWRpYVN0cmVhbVRyYWNrLmtpbmQgPT09ICdhdWRpbyc7XG4gICAgICAgICAgICBsZXQgdHJhY2tPcHRpb25zID0gaXNBdWRpbyA/IG9wdGlvbnMuYXVkaW8gOiBvcHRpb25zLnZpZGVvO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0cmFja09wdGlvbnMgPT09ICdib29sZWFuJyB8fCAhdHJhY2tPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tPcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdHJhY2tDb25zdHJhaW50cztcbiAgICAgICAgICAgIGNvbnN0IGNvbk9yQm9vbCA9IGlzQXVkaW8gPyBjb25zdHJhaW50cy5hdWRpbyA6IGNvbnN0cmFpbnRzLnZpZGVvO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25PckJvb2wgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHRyYWNrQ29uc3RyYWludHMgPSBjb25PckJvb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0cmFjayA9IHB1Ymxpc2hVdGlsc18xLm1lZGlhVHJhY2tUb0xvY2FsVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgdHJhY2tDb25zdHJhaW50cyk7XG4gICAgICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2tfMS5UcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2tfMS5UcmFjay5Tb3VyY2UuQ2FtZXJhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2tfMS5UcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2tfMS5UcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUxvY2FsVHJhY2tzID0gY3JlYXRlTG9jYWxUcmFja3M7XG4vKipcbiAqIENyZWF0ZXMgYSBbW0xvY2FsVmlkZW9UcmFja11dIHdpdGggZ2V0VXNlck1lZGlhKClcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsVmlkZW9UcmFjayhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgdHJhY2tzID0geWllbGQgY3JlYXRlTG9jYWxUcmFja3Moe1xuICAgICAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICAgICAgdmlkZW86IG9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJhY2tzWzBdO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVMb2NhbFZpZGVvVHJhY2sgPSBjcmVhdGVMb2NhbFZpZGVvVHJhY2s7XG5mdW5jdGlvbiBjcmVhdGVMb2NhbEF1ZGlvVHJhY2sob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHlpZWxkIGNyZWF0ZUxvY2FsVHJhY2tzKHtcbiAgICAgICAgICAgIGF1ZGlvOiBvcHRpb25zLFxuICAgICAgICAgICAgdmlkZW86IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRyYWNrc1swXTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlTG9jYWxBdWRpb1RyYWNrID0gY3JlYXRlTG9jYWxBdWRpb1RyYWNrO1xuLyoqXG4gKiBDcmVhdGVzIGEgc2NyZWVuIGNhcHR1cmUgdHJhY2tzIHdpdGggZ2V0RGlzcGxheU1lZGlhKCkuXG4gKiBBIExvY2FsVmlkZW9UcmFjayBpcyBhbHdheXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBJZiB7IGF1ZGlvOiB0cnVlIH0sIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBhdWRpbyBjYXB0dXJlLCBhIExvY2FsQXVkaW9UcmFjayBpcyBhbHNvIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsU2NyZWVuVHJhY2tzKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5yZXNvbHV0aW9uID0gb3B0aW9uc18xLlZpZGVvUHJlc2V0cy5maGQucmVzb2x1dGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlkZW9Db25zdHJhaW50cyA9IHRydWU7XG4gICAgICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24pIHtcbiAgICAgICAgICAgIHZpZGVvQ29uc3RyYWludHMgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIHR5cGVzY3JpcHQgZGVmaW5pdGlvbiBpcyBtaXNzaW5nIGdldERpc3BsYXlNZWRpYTogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMzIzMlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKHtcbiAgICAgICAgICAgIGF1ZGlvOiAoX2EgPSBvcHRpb25zLmF1ZGlvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgIHZpZGVvOiB2aWRlb0NvbnN0cmFpbnRzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgIGlmICh0cmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVHJhY2tJbnZhbGlkRXJyb3IoJ25vIHZpZGVvIHRyYWNrIGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NyZWVuVmlkZW8gPSBuZXcgTG9jYWxWaWRlb1RyYWNrXzEuZGVmYXVsdCh0cmFja3NbMF0pO1xuICAgICAgICBzY3JlZW5WaWRlby5zb3VyY2UgPSBUcmFja18xLlRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZTtcbiAgICAgICAgY29uc3QgbG9jYWxUcmFja3MgPSBbc2NyZWVuVmlkZW9dO1xuICAgICAgICBpZiAoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc2NyZWVuQXVkaW8gPSBuZXcgTG9jYWxBdWRpb1RyYWNrXzEuZGVmYXVsdChzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXSk7XG4gICAgICAgICAgICBzY3JlZW5BdWRpby5zb3VyY2UgPSBUcmFja18xLlRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xuICAgICAgICAgICAgbG9jYWxUcmFja3MucHVzaChzY3JlZW5BdWRpbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsVHJhY2tzO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVMb2NhbFNjcmVlblRyYWNrcyA9IGNyZWF0ZUxvY2FsU2NyZWVuVHJhY2tzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52aWRlb0RlZmF1bHRzID0gZXhwb3J0cy5hdWRpb0RlZmF1bHRzID0gZXhwb3J0cy5wdWJsaXNoRGVmYXVsdHMgPSB2b2lkIDA7XG5jb25zdCBvcHRpb25zXzEgPSByZXF1aXJlKFwiLi9vcHRpb25zXCIpO1xuZXhwb3J0cy5wdWJsaXNoRGVmYXVsdHMgPSB7XG4gICAgYXVkaW9CaXRyYXRlOiBvcHRpb25zXzEuQXVkaW9QcmVzZXRzLnNwZWVjaC5tYXhCaXRyYXRlLFxuICAgIGR0eDogdHJ1ZSxcbiAgICBzaW11bGNhc3Q6IHRydWUsXG4gICAgc2NyZWVuU2hhcmVFbmNvZGluZzogb3B0aW9uc18xLlNjcmVlblNoYXJlUHJlc2V0cy5oZF8xNS5lbmNvZGluZyxcbiAgICBzdG9wTWljVHJhY2tPbk11dGU6IGZhbHNlLFxufTtcbmV4cG9ydHMuYXVkaW9EZWZhdWx0cyA9IHtcbiAgICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsXG4gICAgY2hhbm5lbENvdW50OiAxLFxuICAgIGVjaG9DYW5jZWxsYXRpb246IHRydWUsXG4gICAgbm9pc2VTdXBwcmVzc2lvbjogdHJ1ZSxcbn07XG5leHBvcnRzLnZpZGVvRGVmYXVsdHMgPSB7XG4gICAgcmVzb2x1dGlvbjogb3B0aW9uc18xLlZpZGVvUHJlc2V0cy5xaGQucmVzb2x1dGlvbixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2NyZWVuU2hhcmVQcmVzZXRzID0gZXhwb3J0cy5WaWRlb1ByZXNldHM0MyA9IGV4cG9ydHMuVmlkZW9QcmVzZXRzID0gZXhwb3J0cy5BdWRpb1ByZXNldHMgPSBleHBvcnRzLlZpZGVvUHJlc2V0ID0gdm9pZCAwO1xuY2xhc3MgVmlkZW9QcmVzZXQge1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIG1heEJpdHJhdGUsIG1heEZyYW1lcmF0ZSkge1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmVuY29kaW5nID0ge1xuICAgICAgICAgICAgbWF4Qml0cmF0ZSxcbiAgICAgICAgICAgIG1heEZyYW1lcmF0ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBmcmFtZVJhdGU6IHRoaXMuZW5jb2RpbmcubWF4RnJhbWVyYXRlLFxuICAgICAgICAgICAgYXNwZWN0UmF0aW86IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlZpZGVvUHJlc2V0ID0gVmlkZW9QcmVzZXQ7XG52YXIgQXVkaW9QcmVzZXRzO1xuKGZ1bmN0aW9uIChBdWRpb1ByZXNldHMpIHtcbiAgICBBdWRpb1ByZXNldHMudGVsZXBob25lID0ge1xuICAgICAgICBtYXhCaXRyYXRlOiAxMjAwMCxcbiAgICB9O1xuICAgIEF1ZGlvUHJlc2V0cy5zcGVlY2ggPSB7XG4gICAgICAgIG1heEJpdHJhdGU6IDIwMDAwLFxuICAgIH07XG4gICAgQXVkaW9QcmVzZXRzLm11c2ljID0ge1xuICAgICAgICBtYXhCaXRyYXRlOiAzMjAwMCxcbiAgICB9O1xufSkoQXVkaW9QcmVzZXRzID0gZXhwb3J0cy5BdWRpb1ByZXNldHMgfHwgKGV4cG9ydHMuQXVkaW9QcmVzZXRzID0ge30pKTtcbi8qKlxuICogU2FuZSBwcmVzZXRzIGZvciB2aWRlbyByZXNvbHV0aW9uL2VuY29kaW5nXG4gKi9cbmV4cG9ydHMuVmlkZW9QcmVzZXRzID0ge1xuICAgIHF2Z2E6IG5ldyBWaWRlb1ByZXNldCgzMjAsIDE4MCwgMTIwMDAwLCAxMCksXG4gICAgdmdhOiBuZXcgVmlkZW9QcmVzZXQoNjQwLCAzNjAsIDMwMDAwMCwgMjApLFxuICAgIHFoZDogbmV3IFZpZGVvUHJlc2V0KDk2MCwgNTQwLCA2MDAwMDAsIDI1KSxcbiAgICBoZDogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMjAwMDAwMCwgMzApLFxuICAgIGZoZDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDMwMDAwMDAsIDMwKSxcbn07XG4vKipcbiAqIEZvdXIgYnkgdGhyZWUgcHJlc2V0c1xuICovXG5leHBvcnRzLlZpZGVvUHJlc2V0czQzID0ge1xuICAgIHF2Z2E6IG5ldyBWaWRlb1ByZXNldCgyNDAsIDE4MCwgOTAwMDAsIDEwKSxcbiAgICB2Z2E6IG5ldyBWaWRlb1ByZXNldCg0ODAsIDM2MCwgMjI1MDAwLCAyMCksXG4gICAgcWhkOiBuZXcgVmlkZW9QcmVzZXQoNzIwLCA1NDAsIDQ1MDAwMCwgMjUpLFxuICAgIGhkOiBuZXcgVmlkZW9QcmVzZXQoOTYwLCA3MjAsIDE1MDAwMDAsIDMwKSxcbiAgICBmaGQ6IG5ldyBWaWRlb1ByZXNldCgxNDQwLCAxMDgwLCAyODAwMDAwLCAzMCksXG59O1xuZXhwb3J0cy5TY3JlZW5TaGFyZVByZXNldHMgPSB7XG4gICAgdmdhOiBuZXcgVmlkZW9QcmVzZXQoNjQwLCAzNjAsIDIwMDAwMCwgMyksXG4gICAgaGRfODogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgNDAwMDAwLCA1KSxcbiAgICBoZF8xNTogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMTAwMDAwMCwgMTUpLFxuICAgIGZoZF8xNTogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDE1MDAwMDAsIDE1KSxcbiAgICBmaGRfMzA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCAzMDAwMDAwLCAzMCksXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25zdHJhaW50c0Zvck9wdGlvbnMgPSBleHBvcnRzLm1lcmdlRGVmYXVsdE9wdGlvbnMgPSB2b2lkIDA7XG5mdW5jdGlvbiBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIGF1ZGlvRGVmYXVsdHMsIHZpZGVvRGVmYXVsdHMpIHtcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdHMuYXVkaW8gPT09IHRydWUpXG4gICAgICAgIG9wdHMuYXVkaW8gPSB7fTtcbiAgICBpZiAob3B0cy52aWRlbyA9PT0gdHJ1ZSlcbiAgICAgICAgb3B0cy52aWRlbyA9IHt9O1xuICAgIC8vIHVzZSBkZWZhdWx0c1xuICAgIGlmIChvcHRzLmF1ZGlvKSB7XG4gICAgICAgIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKG9wdHMuYXVkaW8sIGF1ZGlvRGVmYXVsdHMpO1xuICAgIH1cbiAgICBpZiAob3B0cy52aWRlbykge1xuICAgICAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhvcHRzLnZpZGVvLCB2aWRlb0RlZmF1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdHM7XG59XG5leHBvcnRzLm1lcmdlRGVmYXVsdE9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zO1xuZnVuY3Rpb24gbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcobWFpbk9iamVjdCwgb2JqZWN0VG9NZXJnZSkge1xuICAgIE9iamVjdC5rZXlzKG9iamVjdFRvTWVyZ2UpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAobWFpbk9iamVjdFtrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBtYWluT2JqZWN0W2tleV0gPSBvYmplY3RUb01lcmdlW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG1haW5PYmplY3Q7XG59XG5mdW5jdGlvbiBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0ge307XG4gICAgaWYgKG9wdGlvbnMudmlkZW8pIHtcbiAgICAgICAgLy8gZGVmYXVsdCB2aWRlbyBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdmlkZW9PcHRpb25zO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gb3B0aW9ucy52aWRlbztcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVzb2x1dGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmbGF0dGVuIFZpZGVvUmVzb2x1dGlvbiBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKHRhcmdldCwgc291cmNlLnJlc29sdXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8gPSB2aWRlb09wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IG9wdGlvbnMudmlkZW87XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmF1ZGlvKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gb3B0aW9ucy5hdWRpbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xufVxuZXhwb3J0cy5jb25zdHJhaW50c0Zvck9wdGlvbnMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRDbGllbnRJbmZvID0gZXhwb3J0cy5nZXRJbnRlcnNlY3Rpb25PYnNlcnZlciA9IGV4cG9ydHMuZ2V0UmVzaXplT2JzZXJ2ZXIgPSBleHBvcnRzLmlzU2FmYXJpID0gZXhwb3J0cy5pc0ZpcmVGb3ggPSBleHBvcnRzLnNsZWVwID0gZXhwb3J0cy51bnBhY2tTdHJlYW1JZCA9IHZvaWQgMDtcbmNvbnN0IGxpdmVraXRfbW9kZWxzXzEgPSByZXF1aXJlKFwiLi4vcHJvdG8vbGl2ZWtpdF9tb2RlbHNcIik7XG5jb25zdCB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi4vdmVyc2lvblwiKTtcbmNvbnN0IHNlcGFyYXRvciA9ICd8JztcbmZ1bmN0aW9uIHVucGFja1N0cmVhbUlkKHBhY2tlZCkge1xuICAgIGNvbnN0IHBhcnRzID0gcGFja2VkLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIFtwYXJ0c1swXSwgcGFja2VkLnN1YnN0cihwYXJ0c1swXS5sZW5ndGggKyAxKV07XG4gICAgfVxuICAgIHJldHVybiBbcGFja2VkLCAnJ107XG59XG5leHBvcnRzLnVucGFja1N0cmVhbUlkID0gdW5wYWNrU3RyZWFtSWQ7XG5mdW5jdGlvbiBzbGVlcChkdXJhdGlvbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbikpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5zbGVlcCA9IHNsZWVwO1xuZnVuY3Rpb24gaXNGaXJlRm94KCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSAhPT0gLTE7XG59XG5leHBvcnRzLmlzRmlyZUZveCA9IGlzRmlyZUZveDtcbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAgIHJldHVybiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuZXhwb3J0cy5pc1NhZmFyaSA9IGlzU2FmYXJpO1xuZnVuY3Rpb24gcm9EaXNwYXRjaENhbGxiYWNrKGVudHJpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgZW50cnkudGFyZ2V0LmhhbmRsZVJlc2l6ZShlbnRyeSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW9EaXNwYXRjaENhbGxiYWNrKGVudHJpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgZW50cnkudGFyZ2V0LmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKGVudHJ5KTtcbiAgICB9XG59XG5sZXQgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuY29uc3QgZ2V0UmVzaXplT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFyZXNpemVPYnNlcnZlcilcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIocm9EaXNwYXRjaENhbGxiYWNrKTtcbiAgICByZXR1cm4gcmVzaXplT2JzZXJ2ZXI7XG59O1xuZXhwb3J0cy5nZXRSZXNpemVPYnNlcnZlciA9IGdldFJlc2l6ZU9ic2VydmVyO1xubGV0IGludGVyc2VjdGlvbk9ic2VydmVyID0gbnVsbDtcbmNvbnN0IGdldEludGVyc2VjdGlvbk9ic2VydmVyID0gKCkgPT4ge1xuICAgIGlmICghaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpXG4gICAgICAgIGludGVyc2VjdGlvbk9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGlvRGlzcGF0Y2hDYWxsYmFjayk7XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbk9ic2VydmVyO1xufTtcbmV4cG9ydHMuZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBnZXRJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbmZ1bmN0aW9uIGdldENsaWVudEluZm8oKSB7XG4gICAgY29uc3QgaW5mbyA9IGxpdmVraXRfbW9kZWxzXzEuQ2xpZW50SW5mby5mcm9tUGFydGlhbCh7XG4gICAgICAgIHNkazogbGl2ZWtpdF9tb2RlbHNfMS5DbGllbnRJbmZvX1NESy5KUyxcbiAgICAgICAgcHJvdG9jb2w6IHZlcnNpb25fMS5wcm90b2NvbFZlcnNpb24sXG4gICAgICAgIHZlcnNpb246IHZlcnNpb25fMS52ZXJzaW9uLFxuICAgIH0pO1xuICAgIHJldHVybiBpbmZvO1xufVxuZXhwb3J0cy5nZXRDbGllbnRJbmZvID0gZ2V0Q2xpZW50SW5mbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcm90b2NvbFZlcnNpb24gPSBleHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLnZlcnNpb24gPSAnMC4xNi4yJztcbmV4cG9ydHMucHJvdG9jb2xWZXJzaW9uID0gNjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxuICAgICAgICAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICBkZWZhdWx0TGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuXG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xlYXJQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBVVENcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGRlZmF1bHRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5yZXNldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoZGVmYXVsdExldmVsLCBmYWxzZSk7XG4gICAgICAgICAgY2xlYXJQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAoKHR5cGVvZiBuYW1lICE9PSBcInN5bWJvbFwiICYmIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgLy8gRVM2IGRlZmF1bHQgZXhwb3J0LCBmb3IgY29tcGF0aWJpbGl0eVxuICAgIGRlZmF1bHRMb2dnZXJbJ2RlZmF1bHQnXSA9IGRlZmF1bHRMb2dnZXI7XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gTG9uZztcclxuXHJcbi8qKlxyXG4gKiB3YXNtIG9wdGltaXphdGlvbnMsIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxyXG4gKi9cclxudmFyIHdhc20gPSBudWxsO1xyXG5cclxudHJ5IHtcclxuICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFcclxuICBdKSksIHt9KS5leHBvcnRzO1xyXG59IGNhdGNoIChlKSB7XHJcbiAgLy8gbm8gd2FzbSBzdXBwb3J0IDooXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxyXG4gKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cclxuICogQGV4cG9ydHMgTG9uZ1xyXG4gKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG59XHJcblxyXG4vLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxyXG4vLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxyXG4vLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcclxuLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxyXG4vLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xyXG4vLyBvciBjaGFuZ2UgaW4gc2lnbi5cclxuLy9cclxuLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxyXG4vLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cclxuLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXHJcbi8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcclxuLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xyXG4vLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXHJcbi8vXHJcbi8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxyXG4vLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxyXG5cclxuLyoqXHJcbiAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBjb25zdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0xvbmcob2JqKSB7XHJcbiAgICByZXR1cm4gKG9iaiAmJiBvYmpbXCJfX2lzTG9uZ19fXCJdKSA9PT0gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgTG9uZy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmcuaXNMb25nID0gaXNMb25nO1xyXG5cclxuLyoqXHJcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxyXG4gKiBAdHlwZSB7IU9iamVjdH1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIHZhbHVlID4+Pj0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlIHw9IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlID0gKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKGNhY2hlKVxyXG4gICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tSW50ID0gZnJvbUludDtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAoaXNOYU4odmFsdWUpKVxyXG4gICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xyXG4gKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcclxuICogQHJldHVybnMge251bWJlcn1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xyXG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2VtcHR5IHN0cmluZycpO1xyXG4gICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgIHJhZGl4ID0gdW5zaWduZWQsXHJcbiAgICAgICAgdW5zaWduZWQgPSBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdW5zaWduZWQgPSAhISB1bnNpZ25lZDtcclxuICAgIH1cclxuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuXHJcbiAgICB2YXIgcDtcclxuICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XHJcbiAgICBlbHNlIGlmIChwID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gWkVSTztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksXHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcclxuICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcclxuICAgICAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXHJcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XHJcbiAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxyXG4gICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICdib29sZWFuJyA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBmcm9tKiBmdW5jdGlvbiBmb3IgaXRzIHR5cGUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlO1xyXG5cclxuLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxyXG4vLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFpFUk8gPSBmcm9tSW50KDApO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCB6ZXJvLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlpFUk8gPSBaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVVpFUk8gPSBVWkVSTztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE9ORSA9IGZyb21JbnQoMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5PTkUgPSBPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBVbnNpZ25lZCBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVU9ORSA9IFVPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBORUdfT05FID0gZnJvbUludCgtMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5ORUdfT05FID0gTkVHX09ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHg3RkZGRkZGRnwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweEZGRkZGRkZGfDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIE1heGltdW0gdW5zaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMHwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWluaW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiAoKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCkgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBAb3ZlcnJpZGVcclxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuICcwJztcclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXHJcbiAgICAgICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cclxuICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxyXG4gICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcclxuICAgICAgICAgICAgICAgIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxyXG4gICAgICAgICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICByZW0gPSByZW1EaXY7XHJcbiAgICAgICAgaWYgKHJlbS5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxyXG4gICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xyXG4gICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2g7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcclxuICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xyXG4gICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxyXG4gICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpID09PSAxICYmIChvdGhlci5oaWdoID4+PiAzMSkgPT09IDEpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuZXEoLyogdmFsaWRhdGVzICovIG90aGVyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPj0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLmVxKG90aGVyKSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXHJcbiAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XHJcbiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXHJcbiAgICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBTdW1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoYWRkZW5kKSlcclxuICAgICAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgIGMwMCArPSBhMDAgKyBiMDA7XHJcbiAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTE2ICsgYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiArIGIzMjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGM0OCArPSBhNDggKyBiNDg7XHJcbiAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcclxuICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKVxyXG4gICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXHJcbiAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgdmFyIGxvdyA9IHdhc20ubXVsKHRoaXMubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyLmhpZ2gpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG4gICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcclxuXHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcclxuICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xyXG5cclxuICAgIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cclxuICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cclxuICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXHJcblxyXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCAqIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKiBiMDA7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTAwICogYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiAqIGIwMDtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMTYgKiBiMTY7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTAwICogYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICovXHJcbkxvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcclxuICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xyXG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuICAgIGlmIChkaXZpc29yLmlzWmVybygpKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc2lnbmVkIGRpdmlzaW9uIG92ZXJmbG93OiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIG5lZ2F0aXZlIG51bWJlciAvIC0xIHdvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGhlIGxhcmdlc3RcclxuICAgICAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJlxyXG4gICAgICAgICAgICB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIGJlIGNvbnNpc3RlbnQgd2l0aCBub24td2FzbSBjb2RlIHBhdGhcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20uZGl2X3UgOiB3YXNtLmRpdl9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxyXG4gICAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBPTkU7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxyXG4gICAgICAgICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XHJcbiAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xyXG4gICAgICAgIHJlcyA9IFpFUk87XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxyXG4gICAgICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cclxuICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcclxuICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSlcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXHJcbiAgICAgICAgICAgIHJldHVybiBVT05FO1xyXG4gICAgICAgIHJlcyA9IFVaRVJPO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXHJcbiAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXHJcbiAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XHJcbiAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXHJcbiAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cclxuICAgIHJlbSA9IHRoaXM7XHJcbiAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xyXG4gICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcclxuICAgICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cclxuICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XHJcblxyXG4gICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcclxuICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXHJcbiAgICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxyXG5cclxuICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcclxuICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XHJcbiAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXHJcbiAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gT05FO1xyXG5cclxuICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XHJcbiAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLnJlbV91IDogd2FzbS5yZW1fcykoXHJcbiAgICAgICAgICAgIHRoaXMubG93LFxyXG4gICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93LFxyXG4gICAgICAgICAgICBkaXZpc29yLmhpZ2hcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IChudW1CaXRzIC0gMzIpLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0TGVmdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIG51bUJpdHMgJj0gNjM7XHJcbiAgICBpZiAobnVtQml0cyA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93O1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJfdSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHVuc2lnbmVkLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbG8gICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMjRcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgaGkgPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmXHJcbiAgICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZy5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcoXHJcbiAgICAgICAgYnl0ZXNbMF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzFdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1syXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbM10gPDwgMjQsXHJcbiAgICAgICAgYnl0ZXNbNF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzVdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s2XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbN10gPDwgMjQsXHJcbiAgICAgICAgdW5zaWduZWRcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1s0XSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s3XSxcclxuICAgICAgICBieXRlc1swXSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1szXSxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuIiwiLy8gbWluaW1hbCBsaWJyYXJ5IGVudHJ5IHBvaW50LlxuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2luZGV4LW1pbmltYWxcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm90b2J1ZiA9IGV4cG9ydHM7XG5cbi8qKlxuICogQnVpbGQgdHlwZSwgb25lIG9mIGBcImZ1bGxcImAsIGBcImxpZ2h0XCJgIG9yIGBcIm1pbmltYWxcImAuXG4gKiBAbmFtZSBidWlsZFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5wcm90b2J1Zi5idWlsZCA9IFwibWluaW1hbFwiO1xuXG4vLyBTZXJpYWxpemF0aW9uXG5wcm90b2J1Zi5Xcml0ZXIgICAgICAgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJfYnVmZmVyXCIpO1xucHJvdG9idWYuUmVhZGVyICAgICAgID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xucHJvdG9idWYuQnVmZmVyUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyX2J1ZmZlclwiKTtcblxuLy8gVXRpbGl0eVxucHJvdG9idWYudXRpbCAgICAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xucHJvdG9idWYucnBjICAgICAgICAgID0gcmVxdWlyZShcIi4vcnBjXCIpO1xucHJvdG9idWYucm9vdHMgICAgICAgID0gcmVxdWlyZShcIi4vcm9vdHNcIik7XG5wcm90b2J1Zi5jb25maWd1cmUgICAgPSBjb25maWd1cmU7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIFJlY29uZmlndXJlcyB0aGUgbGlicmFyeSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50LlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlKCkge1xuICAgIHByb3RvYnVmLnV0aWwuX2NvbmZpZ3VyZSgpO1xuICAgIHByb3RvYnVmLldyaXRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlcldyaXRlcik7XG4gICAgcHJvdG9idWYuUmVhZGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyUmVhZGVyKTtcbn1cblxuLy8gU2V0IHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnRcbmNvbmZpZ3VyZSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRlcjtcblxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIEJ1ZmZlclJlYWRlcjsgLy8gY3ljbGljXG5cbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGluZGV4T3V0T2ZSYW5nZShyZWFkZXIsIHdyaXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiICsgcmVhZGVyLnBvcyArIFwiICsgXCIgKyAod3JpdGVMZW5ndGggfHwgMSkgKyBcIiA+IFwiICsgcmVhZGVyLmxlbik7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByZWFkZXIgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBSZWFkZXIoYnVmZmVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAdHlwZSB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb3MgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBidWZmZXIubGVuZ3RoO1xufVxuXG52YXIgY3JlYXRlX2FycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IGZ1bmN0aW9uIGNyZWF0ZV90eXBlZF9hcnJheShidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheShidWZmZXIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfTtcblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKGJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIChSZWFkZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5CdWZmZXIuaXNCdWZmZXIoYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBCdWZmZXJSZWFkZXIoYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZV9hcnJheShidWZmZXIpO1xuICAgICAgICAgICAgfSkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGNyZWF0ZV9hcnJheTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWFkZXIgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7VWludDhBcnJheXxCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKiBAcmV0dXJucyB7UmVhZGVyfEJ1ZmZlclJlYWRlcn0gQSB7QGxpbmsgQnVmZmVyUmVhZGVyfSBpZiBgYnVmZmVyYCBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGEge0BsaW5rIFJlYWRlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgYnVmZmVyYCBpcyBub3QgYSB2YWxpZCBidWZmZXJcbiAqL1xuUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG5SZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5IHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnVpbnQzMiA9IChmdW5jdGlvbiByZWFkX3VpbnQzMl9zZXR1cCgpIHtcbiAgICB2YXIgdmFsdWUgPSA0Mjk0OTY3Mjk1OyAvLyBvcHRpbWl6ZXIgdHlwZS1oaW50LCB0ZW5kcyB0byBkZW9wdCBvdGhlcndpc2UgKD8hKVxuICAgIHJldHVybiBmdW5jdGlvbiByZWFkX3VpbnQzMigpIHtcbiAgICAgICAgdmFsdWUgPSAoICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3NdICYgMTI3ICAgICAgICkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8ICA3KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMTQpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyMSkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAgMTUpIDw8IDI4KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICgodGhpcy5wb3MgKz0gNSkgPiB0aGlzLmxlbikge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmxlbjtcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHJlYWRfaW50MzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ludDMyKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudWludDMyKCk7XG4gICAgcmV0dXJuIHZhbHVlID4+PiAxIF4gLSh2YWx1ZSAmIDEpIHwgMDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG5mdW5jdGlvbiByZWFkTG9uZ1ZhcmludCgpIHtcbiAgICAvLyB0ZW5kcyB0byBkZW9wdCB3aXRoIGxvY2FsIHZhcnMgZm9yIG9jdGV0IGV0Yy5cbiAgICB2YXIgYml0cyA9IG5ldyBMb25nQml0cygwLCAwKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGxvKVxuICAgICAgICBmb3IgKDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgLy8gMXN0Li40dGhcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLyA1dGhcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjgpID4+PiAwO1xuICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA+PiAgNCkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICBpID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDM7ICsraSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgLy8gMXN0Li4zdGhcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLyA0dGhcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAoaGkpXG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHZhcmludCBlbmNvZGluZ1wiKTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciN1aW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjc2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIGJvb2xlYW4uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiByZWFkX2Jvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgIT09IDA7XG59O1xuXG5mdW5jdGlvbiByZWFkRml4ZWQzMl9lbmQoYnVmLCBlbmQpIHsgLy8gbm90ZSB0aGF0IHRoaXMgdXNlcyBgZW5kYCwgbm90IGBwb3NgXG4gICAgcmV0dXJuIChidWZbZW5kIC0gNF1cbiAgICAgICAgICB8IGJ1ZltlbmQgLSAzXSA8PCA4XG4gICAgICAgICAgfCBidWZbZW5kIC0gMl0gPDwgMTZcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAxXSA8PCAyNCkgPj4+IDA7XG59XG5cbi8qKlxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gcmVhZF9maXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KTtcbn07XG5cbi8qKlxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhIHNpZ25lZCAzMiBiaXQgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpIHwgMDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG5mdW5jdGlvbiByZWFkRml4ZWQ2NCgvKiB0aGlzOiBSZWFkZXIgKi8pIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDgpO1xuXG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhyZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpLCByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpKTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCA2NCBiaXRzLlxuICogQG5hbWUgUmVhZGVyI2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIHppZy16YWcgZW5jb2RlZCBmaXhlZCA2NCBiaXRzLlxuICogQG5hbWUgUmVhZGVyI3NmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIGZsb2F0ICgzMiBiaXQpIGFzIGEgbnVtYmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiByZWFkX2Zsb2F0KCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpIGFzIGEgbnVtYmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gcmVhZF9kb3VibGUoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZERvdWJsZUxFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gODtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gcmVhZF9ieXRlcygpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy51aW50MzIoKSxcbiAgICAgICAgc3RhcnQgID0gdGhpcy5wb3MsXG4gICAgICAgIGVuZCAgICA9IHRoaXMucG9zICsgbGVuZ3RoO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVuZCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcblxuICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmJ1ZikpIC8vIHBsYWluIGFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZShzdGFydCwgZW5kKTtcbiAgICByZXR1cm4gc3RhcnQgPT09IGVuZCAvLyBmaXggZm9yIElFIDEwL1dpbjggYW5kIG90aGVycycgc3ViYXJyYXkgcmV0dXJuaW5nIGFycmF5IG9mIHNpemUgMVxuICAgICAgICA/IG5ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKVxuICAgICAgICA6IHRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsIHN0YXJ0LCBlbmQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHN0cmluZyBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge3N0cmluZ30gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nKCkge1xuICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXMoKTtcbiAgICByZXR1cm4gdXRmOC5yZWFkKGJ5dGVzLCAwLCBieXRlcy5sZW5ndGgpO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBieXRlcyBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBza2lwcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggaWYga25vd24sIG90aGVyd2lzZSBhIHZhcmludCBpcyBhc3N1bWVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMucG9zICsgbGVuZ3RoID4gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIG5leHQgZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHdpcmUgdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aXJlVHlwZSBXaXJlIHR5cGUgcmVjZWl2ZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXBUeXBlID0gZnVuY3Rpb24od2lyZVR5cGUpIHtcbiAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLnNraXAodGhpcy51aW50MzIoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgd2hpbGUgKCh3aXJlVHlwZSA9IHRoaXMudWludDMyKCkgJiA3KSAhPT0gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcFR5cGUod2lyZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUgKyBcIiBhdCBvZmZzZXQgXCIgKyB0aGlzLnBvcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJSZWFkZXJfKSB7XG4gICAgQnVmZmVyUmVhZGVyID0gQnVmZmVyUmVhZGVyXztcbiAgICBSZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcblxuICAgIHZhciBmbiA9IHV0aWwuTG9uZyA/IFwidG9Mb25nXCIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBcInRvTnVtYmVyXCI7XG4gICAgdXRpbC5tZXJnZShSZWFkZXIucHJvdG90eXBlLCB7XG5cbiAgICAgICAgaW50NjQ6IGZ1bmN0aW9uIHJlYWRfaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVpbnQ2NDogZnVuY3Rpb24gcmVhZF91aW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ludDY0OiBmdW5jdGlvbiByZWFkX3NpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpLnp6RGVjb2RlKClbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXhlZDY0OiBmdW5jdGlvbiByZWFkX2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICB9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xuXG4vLyBleHRlbmRzIFJlYWRlclxudmFyIFJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcbihCdWZmZXJSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWFkZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJSZWFkZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHJlYWRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFJlYWRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gQnVmZmVyUmVhZGVyKGJ1ZmZlcikge1xuICAgIFJlYWRlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnVmXG4gICAgICogQHR5cGUge0J1ZmZlcn1cbiAgICAgKi9cbn1cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodXRpbC5CdWZmZXIpXG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5CdWZmZXIucHJvdG90eXBlLnNsaWNlO1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nX2J1ZmZlcigpIHtcbiAgICB2YXIgbGVuID0gdGhpcy51aW50MzIoKTsgLy8gbW9kaWZpZXMgcG9zXG4gICAgcmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZVxuICAgICAgICA/IHRoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKVxuICAgICAgICA6IHRoaXMuYnVmLnRvU3RyaW5nKFwidXRmLThcIiwgdGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnl0ZXNcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gVmFsdWUgcmVhZFxuICovXG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogTmFtZWQgcm9vdHMuXG4gKiBUaGlzIGlzIHdoZXJlIHBianMgc3RvcmVzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzICh0aGUgb3B0aW9uIGAtciwgLS1yb290YCBzcGVjaWZpZXMgYSBuYW1lKS5cbiAqIENhbiBhbHNvIGJlIHVzZWQgbWFudWFsbHkgdG8gbWFrZSByb290cyBhdmFpbGFibGUgYWNjcm9zcyBtb2R1bGVzLlxuICogQG5hbWUgcm9vdHNcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSb290Pn1cbiAqIEBleGFtcGxlXG4gKiAvLyBwYmpzIC1yIG15cm9vdCAtbyBjb21waWxlZC5qcyAuLi5cbiAqXG4gKiAvLyBpbiBhbm90aGVyIG1vZHVsZTpcbiAqIHJlcXVpcmUoXCIuL2NvbXBpbGVkLmpzXCIpO1xuICpcbiAqIC8vIGluIGFueSBzdWJzZXF1ZW50IG1vZHVsZTpcbiAqIHZhciByb290ID0gcHJvdG9idWYucm9vdHNbXCJteXJvb3RcIl07XG4gKi9cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFN0cmVhbWluZyBSUEMgaGVscGVycy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHJwYyA9IGV4cG9ydHM7XG5cbi8qKlxuICogUlBDIGltcGxlbWVudGF0aW9uIHBhc3NlZCB0byB7QGxpbmsgU2VydmljZSNjcmVhdGV9IHBlcmZvcm1pbmcgYSBzZXJ2aWNlIHJlcXVlc3Qgb24gbmV0d29yayBsZXZlbCwgaS5lLiBieSB1dGlsaXppbmcgaHR0cCByZXF1ZXN0cyBvciB3ZWJzb2NrZXRzLlxuICogQHR5cGVkZWYgUlBDSW1wbFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8TWVzc2FnZTx7fT4sTWVzc2FnZTx7fT4+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2QgYmVpbmcgY2FsbGVkXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHJlcXVlc3REYXRhIFJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtSUENJbXBsQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIHJwY0ltcGwobWV0aG9kLCByZXF1ZXN0RGF0YSwgY2FsbGJhY2spIHtcbiAqICAgICBpZiAocHJvdG9idWYudXRpbC5sY0ZpcnN0KG1ldGhvZC5uYW1lKSAhPT0gXCJteU1ldGhvZFwiKSAvLyBjb21wYXRpYmxlIHdpdGggc3RhdGljIGNvZGVcbiAqICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIG1ldGhvZFwiKTtcbiAqICAgICBhc3luY2hyb25vdXNseU9idGFpbkFSZXNwb25zZShyZXF1ZXN0RGF0YSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZURhdGEpIHtcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZURhdGEpO1xuICogICAgIH0pO1xuICogfVxuICovXG5cbi8qKlxuICogTm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBSUENJbXBsfS5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gW3Jlc3BvbnNlXSBSZXNwb25zZSBkYXRhIG9yIGBudWxsYCB0byBzaWduYWwgZW5kIG9mIHN0cmVhbSwgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxucnBjLlNlcnZpY2UgPSByZXF1aXJlKFwiLi9ycGMvc2VydmljZVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8vIEV4dGVuZHMgRXZlbnRFbWl0dGVyXG4oU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHV0aWwuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gU2VydmljZTtcblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHJwYy5TZXJ2aWNlTWV0aG9kfFNlcnZpY2VNZXRob2R9LlxuICpcbiAqIERpZmZlcnMgZnJvbSB7QGxpbmsgUlBDSW1wbENhbGxiYWNrfSBpbiB0aGF0IGl0IGlzIGFuIGFjdHVhbCBjYWxsYmFjayBvZiBhIHNlcnZpY2UgbWV0aG9kIHdoaWNoIG1heSBub3QgcmV0dXJuIGByZXNwb25zZSA9IG51bGxgLlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RDYWxsYmFja1xuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcbiAqIEBwYXJhbSB7VFJlc30gW3Jlc3BvbnNlXSBSZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBwYXJ0IG9mIGEge0BsaW5rIHJwYy5TZXJ2aWNlfSBhcyBjcmVhdGVkIGJ5IHtAbGluayBTZXJ2aWNlLmNyZWF0ZX0uXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZFxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gW2NhbGxiYWNrXSBOb2RlLXN0eWxlIGNhbGxiYWNrIGNhbGxlZCB3aXRoIHRoZSBlcnJvciwgaWYgYW55LCBhbmQgdGhlIHJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U8VFJlcz4+fSBQcm9taXNlIGlmIGBjYWxsYmFja2AgaGFzIGJlZW4gb21pdHRlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IFJQQyBzZXJ2aWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBBbiBSUEMgc2VydmljZSBhcyByZXR1cm5lZCBieSB7QGxpbmsgU2VydmljZSNjcmVhdGV9LlxuICogQGV4cG9ydHMgcnBjLlNlcnZpY2VcbiAqIEBleHRlbmRzIHV0aWwuRXZlbnRFbWl0dGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3BvbnNlRGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICovXG5mdW5jdGlvbiBTZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XG5cbiAgICBpZiAodHlwZW9mIHJwY0ltcGwgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG5cbiAgICB1dGlsLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogUlBDIGltcGxlbWVudGF0aW9uLiBCZWNvbWVzIGBudWxsYCBvbmNlIHRoZSBzZXJ2aWNlIGlzIGVuZGVkLlxuICAgICAqIEB0eXBlIHtSUENJbXBsfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0RGVsaW1pdGVkID0gQm9vbGVhbihyZXF1ZXN0RGVsaW1pdGVkKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQgPSBCb29sZWFuKHJlc3BvbnNlRGVsaW1pdGVkKTtcbn1cblxuLyoqXG4gKiBDYWxscyBhIHNlcnZpY2UgbWV0aG9kIHRocm91Z2gge0BsaW5rIHJwYy5TZXJ2aWNlI3JwY0ltcGx8cnBjSW1wbH0uXG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxUUmVxLFRSZXM+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2RcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcT59IHJlcXVlc3RDdG9yIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcz59IHJlc3BvbnNlQ3RvciBSZXNwb25zZSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBjYWxsYmFjayBTZXJ2aWNlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqL1xuU2VydmljZS5wcm90b3R5cGUucnBjQ2FsbCA9IGZ1bmN0aW9uIHJwY0NhbGwobWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0LCBjYWxsYmFjaykge1xuXG4gICAgaWYgKCFyZXF1ZXN0KVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShycGNDYWxsLCBzZWxmLCBtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QpO1xuXG4gICAgaWYgKCFzZWxmLnJwY0ltcGwpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNlbGYucnBjSW1wbChcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RDdG9yW3NlbGYucmVxdWVzdERlbGltaXRlZCA/IFwiZW5jb2RlRGVsaW1pdGVkXCIgOiBcImVuY29kZVwiXShyZXF1ZXN0KS5maW5pc2goKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJwY0NhbGxiYWNrKGVyciwgcmVzcG9uc2UpIHtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmQoLyogZW5kZWRCeVJQQyAqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIHJlc3BvbnNlQ3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VDdG9yW3NlbGYucmVzcG9uc2VEZWxpbWl0ZWQgPyBcImRlY29kZURlbGltaXRlZFwiIDogXCJkZWNvZGVcIl0ocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZGF0YVwiLCByZXNwb25zZSwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGVycik7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5kcyB0aGlzIHNlcnZpY2UgYW5kIGVtaXRzIHRoZSBgZW5kYCBldmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZGVkQnlSUEM9ZmFsc2VdIFdoZXRoZXIgdGhlIHNlcnZpY2UgaGFzIGJlZW4gZW5kZWQgYnkgdGhlIFJQQyBpbXBsZW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIHtycGMuU2VydmljZX0gYHRoaXNgXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChlbmRlZEJ5UlBDKSB7XG4gICAgaWYgKHRoaXMucnBjSW1wbCkge1xuICAgICAgICBpZiAoIWVuZGVkQnlSUEMpIC8vIHNpZ25hbCBlbmQgdG8gcnBjSW1wbFxuICAgICAgICAgICAgdGhpcy5ycGNJbXBsKG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLnJwY0ltcGwgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIikub2ZmKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBMb25nQml0cztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cy5cbiAqIEBjbGFzc2Rlc2MgSGVscGVyIGNsYXNzIGZvciB3b3JraW5nIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxvIExvdyAzMiBiaXRzLCB1bnNpZ25lZFxuICogQHBhcmFtIHtudW1iZXJ9IGhpIEhpZ2ggMzIgYml0cywgdW5zaWduZWRcbiAqL1xuZnVuY3Rpb24gTG9uZ0JpdHMobG8sIGhpKSB7XG5cbiAgICAvLyBub3RlIHRoYXQgdGhlIGNhc3RzIGJlbG93IGFyZSB0aGVvcmV0aWNhbGx5IHVubmVjZXNzYXJ5IGFzIG9mIHRvZGF5LCBidXQgb2xkZXIgc3RhdGljYWxseVxuICAgIC8vIGdlbmVyYXRlZCBjb252ZXJ0ZXIgY29kZSBtaWdodCBzdGlsbCBjYWxsIHRoZSBjdG9yIHdpdGggc2lnbmVkIDMyYml0cy4ga2VwdCBmb3IgY29tcGF0LlxuXG4gICAgLyoqXG4gICAgICogTG93IGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvID0gbG8gPj4+IDA7XG5cbiAgICAvKipcbiAgICAgKiBIaWdoIGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpID0gaGkgPj4+IDA7XG59XG5cbi8qKlxuICogWmVybyBiaXRzLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHt1dGlsLkxvbmdCaXRzfVxuICovXG52YXIgemVybyA9IExvbmdCaXRzLnplcm8gPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG5cbnplcm8udG9OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG56ZXJvLnp6RW5jb2RlID0gemVyby56ekRlY29kZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbnplcm8ubGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9O1xuXG4vKipcbiAqIFplcm8gaGFzaC5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgemVyb0hhc2ggPSBMb25nQml0cy56ZXJvSGFzaCA9IFwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDA7XG4gICAgaWYgKHNpZ24pXG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgIHZhciBsbyA9IHZhbHVlID4+PiAwLFxuICAgICAgICBoaSA9ICh2YWx1ZSAtIGxvKSAvIDQyOTQ5NjcyOTYgPj4+IDA7XG4gICAgaWYgKHNpZ24pIHtcbiAgICAgICAgaGkgPSB+aGkgPj4+IDA7XG4gICAgICAgIGxvID0gfmxvID4+PiAwO1xuICAgICAgICBpZiAoKytsbyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIGxvID0gMDtcbiAgICAgICAgICAgIGlmICgrK2hpID4gNDI5NDk2NzI5NSlcbiAgICAgICAgICAgICAgICBoaSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhsbywgaGkpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSBhIG51bWJlciwgbG9uZyBvciBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgICAgIHZhbHVlID0gdXRpbC5Mb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcihwYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmxvdyB8fCB2YWx1ZS5oaWdoID8gbmV3IExvbmdCaXRzKHZhbHVlLmxvdyA+Pj4gMCwgdmFsdWUuaGlnaCA+Pj4gMCkgOiB6ZXJvO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIHBvc3NpYmx5IHVuc2FmZSBKYXZhU2NyaXB0IG51bWJlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge251bWJlcn0gUG9zc2libHkgdW5zYWZlIG51bWJlclxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcih1bnNpZ25lZCkge1xuICAgIGlmICghdW5zaWduZWQgJiYgdGhpcy5oaSA+Pj4gMzEpIHtcbiAgICAgICAgdmFyIGxvID0gfnRoaXMubG8gKyAxID4+PiAwLFxuICAgICAgICAgICAgaGkgPSB+dGhpcy5oaSAgICAgPj4+IDA7XG4gICAgICAgIGlmICghbG8pXG4gICAgICAgICAgICBoaSA9IGhpICsgMSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIC0obG8gKyBoaSAqIDQyOTQ5NjcyOTYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sbyArIHRoaXMuaGkgKiA0Mjk0OTY3Mjk2O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIGxvbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfSBMb25nXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0xvbmcgPSBmdW5jdGlvbiB0b0xvbmcodW5zaWduZWQpIHtcbiAgICByZXR1cm4gdXRpbC5Mb25nXG4gICAgICAgID8gbmV3IHV0aWwuTG9uZyh0aGlzLmxvIHwgMCwgdGhpcy5oaSB8IDAsIEJvb2xlYW4odW5zaWduZWQpKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IHsgbG93OiB0aGlzLmxvIHwgMCwgaGlnaDogdGhpcy5oaSB8IDAsIHVuc2lnbmVkOiBCb29sZWFuKHVuc2lnbmVkKSB9O1xufTtcblxudmFyIGNoYXJDb2RlQXQgPSBTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEJpdHNcbiAqL1xuTG9uZ0JpdHMuZnJvbUhhc2ggPSBmdW5jdGlvbiBmcm9tSGFzaChoYXNoKSB7XG4gICAgaWYgKGhhc2ggPT09IHplcm9IYXNoKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCAwKVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAxKSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDIpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDMpIDw8IDI0KSA+Pj4gMFxuICAgICxcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA2KSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA3KSA8PCAyNCkgPj4+IDBcbiAgICApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiB0b0hhc2goKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHRoaXMubG8gICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDI0ICAgICAgLFxuICAgICAgICB0aGlzLmhpICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAyNFxuICAgICk7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZW5jb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RW5jb2RlID0gZnVuY3Rpb24genpFbmNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAgIHRoaXMuaGkgPj4gMzE7XG4gICAgdGhpcy5oaSAgPSAoKHRoaXMuaGkgPDwgMSB8IHRoaXMubG8gPj4+IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMubG8gID0gKCB0aGlzLmxvIDw8IDEgICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogWmlnLXphZyBkZWNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpEZWNvZGUgPSBmdW5jdGlvbiB6ekRlY29kZSgpIHtcbiAgICB2YXIgbWFzayA9IC0odGhpcy5sbyAmIDEpO1xuICAgIHRoaXMubG8gID0gKCh0aGlzLmxvID4+PiAxIHwgdGhpcy5oaSA8PCAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmhpICA9ICggdGhpcy5oaSA+Pj4gMSAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGxvbmdiaXRzIHdoZW4gZW5jb2RlZCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IExlbmd0aFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHZhciBwYXJ0MCA9ICB0aGlzLmxvLFxuICAgICAgICBwYXJ0MSA9ICh0aGlzLmxvID4+PiAyOCB8IHRoaXMuaGkgPDwgNCkgPj4+IDAsXG4gICAgICAgIHBhcnQyID0gIHRoaXMuaGkgPj4+IDI0O1xuICAgIHJldHVybiBwYXJ0MiA9PT0gMFxuICAgICAgICAgPyBwYXJ0MSA9PT0gMFxuICAgICAgICAgICA/IHBhcnQwIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQwIDwgMTI4ID8gMSA6IDJcbiAgICAgICAgICAgICA6IHBhcnQwIDwgMjA5NzE1MiA/IDMgOiA0XG4gICAgICAgICAgIDogcGFydDEgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDEgPCAxMjggPyA1IDogNlxuICAgICAgICAgICAgIDogcGFydDEgPCAyMDk3MTUyID8gNyA6IDhcbiAgICAgICAgIDogcGFydDIgPCAxMjggPyA5IDogMTA7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IGV4cG9ydHM7XG5cbi8vIHVzZWQgdG8gcmV0dXJuIGEgUHJvbWlzZSB3aGVyZSBjYWxsYmFjayBpcyBvbWl0dGVkXG51dGlsLmFzUHJvbWlzZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9hc3Byb21pc2VcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG51dGlsLmJhc2U2NCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9iYXNlNjRcIik7XG5cbi8vIGJhc2UgY2xhc3Mgb2YgcnBjLlNlcnZpY2VcbnV0aWwuRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlclwiKTtcblxuLy8gZmxvYXQgaGFuZGxpbmcgYWNjcm9zcyBicm93c2Vyc1xudXRpbC5mbG9hdCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mbG9hdFwiKTtcblxuLy8gcmVxdWlyZXMgbW9kdWxlcyBvcHRpb25hbGx5IGFuZCBoaWRlcyB0aGUgY2FsbCBmcm9tIGJ1bmRsZXJzXG51dGlsLmlucXVpcmUgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvaW5xdWlyZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIHV0ZjggZW5jb2RlZCBzdHJpbmdzXG51dGlsLnV0ZjggPSByZXF1aXJlKFwiQHByb3RvYnVmanMvdXRmOFwiKTtcblxuLy8gcHJvdmlkZXMgYSBub2RlLWxpa2UgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXJcbnV0aWwucG9vbCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wb29sXCIpO1xuXG4vLyB1dGlsaXR5IHRvIHdvcmsgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWVcbnV0aWwuTG9uZ0JpdHMgPSByZXF1aXJlKFwiLi9sb25nYml0c1wiKTtcblxuLyoqXG4gKiBXaGV0aGVyIHJ1bm5pbmcgd2l0aGluIG5vZGUgb3Igbm90LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG51dGlsLmlzTm9kZSA9IEJvb2xlYW4odHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbFxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcblxuLyoqXG4gKiBHbG9iYWwgb2JqZWN0IHJlZmVyZW5jZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG51dGlsLmdsb2JhbCA9IHV0aWwuaXNOb2RlICYmIGdsb2JhbFxuICAgICAgICAgICB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvd1xuICAgICAgICAgICB8fCB0eXBlb2Ygc2VsZiAgICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGZcbiAgICAgICAgICAgfHwgdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbnZhbGlkLXRoaXNcblxuLyoqXG4gKiBBbiBpbW11YWJsZSBlbXB0eSBhcnJheS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7QXJyYXkuPCo+fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKFtdKSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFtdOyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgZW1wdHkgb2JqZWN0LlxuICogQHR5cGUge09iamVjdH1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoe30pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnRlZ2VyXG4gKi9cbnV0aWwuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nXG4gKi9cbnV0aWwuaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0XG4gKi9cbnV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayB1dGlsLmlzU2V0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNzZXQgPVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc1NldCA9IGZ1bmN0aW9uIGlzU2V0KG9iaiwgcHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxLCBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSA+IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBCdWZmZXIgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBub2RlJ3MgdHlwaW5ncy5cbiAqIEBpbnRlcmZhY2UgQnVmZmVyXG4gKiBAZXh0ZW5kcyBVaW50OEFycmF5XG4gKi9cblxuLyoqXG4gKiBOb2RlJ3MgQnVmZmVyIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxCdWZmZXI+fVxuICovXG51dGlsLkJ1ZmZlciA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgQnVmZmVyID0gdXRpbC5pbnF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICAgICAgLy8gcmVmdXNlIHRvIHVzZSBub24tbm9kZSBidWZmZXJzIGlmIG5vdCBleHBsaWNpdGx5IGFzc2lnbmVkIChwZXJmIHJlYXNvbnMpOlxuICAgICAgICByZXR1cm4gQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPyBCdWZmZXIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSkoKTtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZ1bGwgZm9yIEJ1ZmZlci5mcm9tLlxudXRpbC5fQnVmZmVyX2Zyb20gPSBudWxsO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZmlsbCBmb3IgQnVmZmVyLmFsbG9jVW5zYWZlLlxudXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGJ1ZmZlciBvZiB3aGF0ZXZlciB0eXBlIHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gW3NpemVPckFycmF5PTBdIEJ1ZmZlciBzaXplIG9yIG51bWJlciBhcnJheVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl8QnVmZmVyfSBCdWZmZXJcbiAqL1xudXRpbC5uZXdCdWZmZXIgPSBmdW5jdGlvbiBuZXdCdWZmZXIoc2l6ZU9yQXJyYXkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0eXBlb2Ygc2l6ZU9yQXJyYXkgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IG5ldyB1dGlsLkFycmF5KHNpemVPckFycmF5KVxuICAgICAgICA6IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9mcm9tKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgID8gc2l6ZU9yQXJyYXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KHNpemVPckFycmF5KTtcbn07XG5cbi8qKlxuICogQXJyYXkgaW1wbGVtZW50YXRpb24gdXNlZCBpbiB0aGUgYnJvd3Nlci4gYFVpbnQ4QXJyYXlgIGlmIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8VWludDhBcnJheT59XG4gKi9cbnV0aWwuQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IFVpbnQ4QXJyYXkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOiBBcnJheTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBMb25nIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIExvbmcgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IGxvbmcuanMuXG4gKiBAaW50ZXJmYWNlIExvbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb3cgTG93IGJpdHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoIEhpZ2ggYml0c1xuICogQHByb3BlcnR5IHtib29sZWFufSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICovXG5cbi8qKlxuICogTG9uZy5qcydzIExvbmcgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPExvbmc+fVxuICovXG51dGlsLkxvbmcgPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8uTG9uZ1xuICAgICAgICAgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuTG9uZ1xuICAgICAgICAgfHwgdXRpbC5pbnF1aXJlKFwibG9uZ1wiKTtcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMiBiaXQgKGBib29sYCkgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MlJlID0gL150cnVlfGZhbHNlfDB8MSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAzMiBiaXQgKGBpbnQzMmAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MzJSZSA9IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSA2NCBiaXQgKGBpbnQ2NGAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5NjRSZSA9IC9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciBvciBsb25nIHRvIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcn0gdmFsdWUgVmFsdWUgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG51dGlsLmxvbmdUb0hhc2ggPSBmdW5jdGlvbiBsb25nVG9IYXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gdXRpbC5Mb25nQml0cy5mcm9tKHZhbHVlKS50b0hhc2goKVxuICAgICAgICA6IHV0aWwuTG9uZ0JpdHMuemVyb0hhc2g7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nIHRvIGEgbG9uZyBvciBudW1iZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfG51bWJlcn0gT3JpZ2luYWwgdmFsdWVcbiAqL1xudXRpbC5sb25nRnJvbUhhc2ggPSBmdW5jdGlvbiBsb25nRnJvbUhhc2goaGFzaCwgdW5zaWduZWQpIHtcbiAgICB2YXIgYml0cyA9IHV0aWwuTG9uZ0JpdHMuZnJvbUhhc2goaGFzaCk7XG4gICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgcmV0dXJuIHV0aWwuTG9uZy5mcm9tQml0cyhiaXRzLmxvLCBiaXRzLmhpLCB1bnNpZ25lZCk7XG4gICAgcmV0dXJuIGJpdHMudG9OdW1iZXIoQm9vbGVhbih1bnNpZ25lZCkpO1xufTtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IHNyYyBTb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldD1mYWxzZV0gTWVyZ2VzIG9ubHkgaWYgdGhlIGtleSBpcyBub3QgYWxyZWFkeSBzZXRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKGRzdCwgc3JjLCBpZk5vdFNldCkgeyAvLyB1c2VkIGJ5IGNvbnZlcnRlcnNcbiAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoZHN0W2tleXNbaV1dID09PSB1bmRlZmluZWQgfHwgIWlmTm90U2V0KVxuICAgICAgICAgICAgZHN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgIHJldHVybiBkc3Q7XG59XG5cbnV0aWwubWVyZ2UgPSBtZXJnZTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwubGNGaXJzdCA9IGZ1bmN0aW9uIGxjRmlyc3Qoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjdXN0b20gZXJyb3IgY29uc3RydWN0b3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXJyb3IgbmFtZVxuICogQHJldHVybnMge0NvbnN0cnVjdG9yPEVycm9yPn0gQ3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIG5ld0Vycm9yKG5hbWUpIHtcblxuICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpIHtcblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tRXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAvLyBeIGp1c3QgcmV0dXJucyBhIG5ldyBlcnJvciBpbnN0YW5jZSBiZWNhdXNlIHRoZSBjdG9yIGNhbiBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvblxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVzc2FnZTsgfSB9KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIC8vIG5vZGVcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEN1c3RvbUVycm9yKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogbmV3IEVycm9yKCkuc3RhY2sgfHwgXCJcIiB9KTtcblxuICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgIG1lcmdlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIChDdXN0b21FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQ3VzdG9tRXJyb3I7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tRXJyb3IucHJvdG90eXBlLCBcIm5hbWVcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmFtZTsgfSB9KTtcblxuICAgIEN1c3RvbUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XG59XG5cbnV0aWwubmV3RXJyb3IgPSBuZXdFcnJvcjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHByb3RvY29sIGVycm9yLlxuICogQGNsYXNzZGVzYyBFcnJvciBzdWJjbGFzcyBpbmRpY2F0aW5nIGEgcHJvdG9jb2wgc3BlY2lmYyBlcnJvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAZXh0ZW5kcyBFcnJvclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwcm9wZXJ0aWVzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBleGFtcGxlXG4gKiB0cnkge1xuICogICAgIE15TWVzc2FnZS5kZWNvZGUoc29tZUJ1ZmZlcik7IC8vIHRocm93cyBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAqIH0gY2F0Y2ggKGUpIHtcbiAqICAgICBpZiAoZSBpbnN0YW5jZW9mIFByb3RvY29sRXJyb3IgJiYgZS5pbnN0YW5jZSlcbiAqICAgICAgICAgY29uc29sZS5sb2coXCJkZWNvZGVkIHNvIGZhcjogXCIgKyBKU09OLnN0cmluZ2lmeShlLmluc3RhbmNlKSk7XG4gKiB9XG4gKi9cbnV0aWwuUHJvdG9jb2xFcnJvciA9IG5ld0Vycm9yKFwiUHJvdG9jb2xFcnJvclwiKTtcblxuLyoqXG4gKiBTbyBmYXIgZGVjb2RlZCBtZXNzYWdlIGluc3RhbmNlLlxuICogQG5hbWUgdXRpbC5Qcm90b2NvbEVycm9yI2luc3RhbmNlXG4gKiBAdHlwZSB7TWVzc2FnZTxUPn1cbiAqL1xuXG4vKipcbiAqIEEgT25lT2YgZ2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mR2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mR2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgZ2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mR2V0dGVyfSBVbmJvdW5kIGdldHRlclxuICovXG51dGlsLm9uZU9mR2V0dGVyID0gZnVuY3Rpb24gZ2V0T25lT2YoZmllbGROYW1lcykge1xuICAgIHZhciBmaWVsZE1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgZmllbGRNYXBbZmllbGROYW1lc1tpXV0gPSAxO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKSwgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+IC0xOyAtLWkpXG4gICAgICAgICAgICBpZiAoZmllbGRNYXBba2V5c1tpXV0gPT09IDEgJiYgdGhpc1trZXlzW2ldXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNba2V5c1tpXV0gIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXNbaV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogQSBPbmVPZiBzZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZTZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZTZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdmFsdWUgRmllbGQgbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIHNldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZlNldHRlcn0gVW5ib3VuZCBzZXR0ZXJcbiAqL1xudXRpbC5vbmVPZlNldHRlciA9IGZ1bmN0aW9uIHNldE9uZU9mKGZpZWxkTmFtZXMpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXSAhPT0gbmFtZSlcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1tmaWVsZE5hbWVzW2ldXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IGNvbnZlcnNpb24gb3B0aW9ucyB1c2VkIGZvciB7QGxpbmsgTWVzc2FnZSN0b0pTT059IGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBjbG9zZSB0byBwcm90bzMncyBKU09OIG1hcHBpbmcgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaW50ZXJuYWwgdHlwZXMgbGlrZSBBbnkgYXJlIGhhbmRsZWQganVzdCBsaWtlIG1lc3NhZ2VzLiBNb3JlIHByZWNpc2VseTpcbiAqXG4gKiAtIExvbmdzIGJlY29tZSBzdHJpbmdzXG4gKiAtIEVudW1zIGJlY29tZSBzdHJpbmcga2V5c1xuICogLSBCeXRlcyBiZWNvbWUgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICogLSAoU3ViLSlNZXNzYWdlcyBiZWNvbWUgcGxhaW4gb2JqZWN0c1xuICogLSBNYXBzIGJlY29tZSBwbGFpbiBvYmplY3RzIHdpdGggYWxsIHN0cmluZyBrZXlzXG4gKiAtIFJlcGVhdGVkIGZpZWxkcyBiZWNvbWUgYXJyYXlzXG4gKiAtIE5hTiBhbmQgSW5maW5pdHkgZm9yIGZsb2F0IGFuZCBkb3VibGUgZmllbGRzIGJlY29tZSBzdHJpbmdzXG4gKlxuICogQHR5cGUge0lDb252ZXJzaW9uT3B0aW9uc31cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMz9obD1lbiNqc29uXG4gKi9cbnV0aWwudG9KU09OT3B0aW9ucyA9IHtcbiAgICBsb25nczogU3RyaW5nLFxuICAgIGVudW1zOiBTdHJpbmcsXG4gICAgYnl0ZXM6IFN0cmluZyxcbiAgICBqc29uOiB0cnVlXG59O1xuXG4vLyBTZXRzIHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQgKGNhbGxlZCBpbiBpbmRleC1taW5pbWFsKVxudXRpbC5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQnVmZmVyKSB7XG4gICAgICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBiZWNhdXNlIG5vZGUgNC54IGJ1ZmZlcnMgYXJlIGluY29tcGF0aWJsZSAmIGltbXV0YWJsZVxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMvcHVsbC82NjVcbiAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20gJiYgQnVmZmVyLmZyb20gfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2Zyb20odmFsdWUsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgICB9O1xuICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgIH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRlcjtcblxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIEJ1ZmZlcldyaXRlcjsgLy8gY3ljbGljXG5cbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxuICAgIGJhc2U2NCAgICA9IHV0aWwuYmFzZTY0LFxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIFVpbnQ4QXJyYXksIG51bWJlcil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7Kn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIE9wKGZuLCBsZW4sIHZhbCkge1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX1cbiAgICAgKi9cbiAgICB0aGlzLmZuID0gZm47XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBieXRlIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gbGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1dyaXRlci5PcHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy52YWwgPSB2YWw7IC8vIHR5cGUgdmFyaWVzXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBub29wKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eS1mdW5jdGlvblxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIHN0YXRlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBDb3BpZWQgd3JpdGVyIHN0YXRlLlxuICogQG1lbWJlcm9mIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dyaXRlcn0gd3JpdGVyIFdyaXRlciB0byBjb3B5IHN0YXRlIGZyb21cbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gU3RhdGUod3JpdGVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGhlYWQuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSB3cml0ZXIuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgdGFpbC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHdyaXRlci50YWlsO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBidWZmZXIgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSB3cml0ZXIubGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7U3RhdGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB3cml0ZXIuc3RhdGVzO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gV3JpdGVyKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIGhlYWQuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIHRhaWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIExpbmtlZCBmb3JrZWQgc3RhdGVzLlxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlcyA9IG51bGw7XG5cbiAgICAvLyBXaGVuIGEgdmFsdWUgaXMgd3JpdHRlbiwgdGhlIHdyaXRlciBjYWxjdWxhdGVzIGl0cyBieXRlIGxlbmd0aCBhbmQgcHV0cyBpdCBpbnRvIGEgbGlua2VkXG4gICAgLy8gbGlzdCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm0gd2hlbiBmaW5pc2goKSBpcyBjYWxsZWQuIFRoaXMgYm90aCBhbGxvd3MgdXMgdG8gYWxsb2NhdGVcbiAgICAvLyBidWZmZXJzIG9mIHRoZSBleGFjdCByZXF1aXJlZCBzaXplIGFuZCByZWR1Y2VzIHRoZSBhbW91bnQgb2Ygd29yayB3ZSBoYXZlIHRvIGRvIGNvbXBhcmVkXG4gICAgLy8gdG8gZmlyc3QgY2FsY3VsYXRpbmcgb3ZlciBvYmplY3RzIGFuZCB0aGVuIGVuY29kaW5nIG92ZXIgb2JqZWN0cy4gSW4gb3VyIGNhc2UsIHRoZSBlbmNvZGluZ1xuICAgIC8vIHBhcnQgaXMganVzdCBhIGxpbmtlZCBsaXN0IHdhbGsgY2FsbGluZyBvcGVyYXRpb25zIHdpdGggYWxyZWFkeSBwcmVwYXJlZCB2YWx1ZXMuXG59XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoV3JpdGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlcigpO1xuICAgICAgICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHdyaXRlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcldyaXRlcnxXcml0ZXJ9IEEge0BsaW5rIEJ1ZmZlcldyaXRlcn0gd2hlbiBCdWZmZXJzIGFyZSBzdXBwb3J0ZWQsIG90aGVyd2lzZSBhIHtAbGluayBXcml0ZXJ9XG4gKi9cbldyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuLyoqXG4gKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcbiAqL1xuV3JpdGVyLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSkge1xuICAgIHJldHVybiBuZXcgdXRpbC5BcnJheShzaXplKTtcbn07XG5cbi8vIFVzZSBVaW50OEFycmF5IGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyLCBqdXN0IGxpa2Ugbm9kZSBkb2VzIHdpdGggYnVmZmVyc1xuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbmlmICh1dGlsLkFycmF5ICE9PSBBcnJheSlcbiAgICBXcml0ZXIuYWxsb2MgPSB1dGlsLnBvb2woV3JpdGVyLmFsbG9jLCB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSk7XG5cbi8qKlxuICogUHVzaGVzIGEgbmV3IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHByaXZhdGVcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5fcHVzaCA9IGZ1bmN0aW9uIHB1c2goZm4sIGxlbiwgdmFsKSB7XG4gICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgT3AoZm4sIGxlbiwgdmFsKTtcbiAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUJ5dGUodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3NdID0gdmFsICYgMjU1O1xufVxuXG5mdW5jdGlvbiB3cml0ZVZhcmludDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwgJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbCA+Pj49IDc7XG4gICAgfVxuICAgIGJ1Zltwb3NdID0gdmFsO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgdmFyaW50IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBleHRlbmRzIE9wXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gVmFyaW50T3AobGVuLCB2YWwpIHtcbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy52YWwgPSB2YWw7XG59XG5cblZhcmludE9wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3AucHJvdG90eXBlKTtcblZhcmludE9wLnByb3RvdHlwZS5mbiA9IHdyaXRlVmFyaW50MzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDMyID0gZnVuY3Rpb24gd3JpdGVfdWludDMyKHZhbHVlKSB7XG4gICAgLy8gaGVyZSwgdGhlIGNhbGwgdG8gdGhpcy5wdXNoIGhhcyBiZWVuIGlubGluZWQgYW5kIGEgdmFyaW50IHNwZWNpZmljIE9wIHN1YmNsYXNzIGlzIHVzZWQuXG4gICAgLy8gdWludDMyIGlzIGJ5IGZhciB0aGUgbW9zdCBmcmVxdWVudGx5IHVzZWQgb3BlcmF0aW9uIGFuZCBiZW5lZml0cyBzaWduaWZpY2FudGx5IGZyb20gdGhpcy5cbiAgICB0aGlzLmxlbiArPSAodGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgVmFyaW50T3AoXG4gICAgICAgICh2YWx1ZSA9IHZhbHVlID4+PiAwKVxuICAgICAgICAgICAgICAgIDwgMTI4ICAgICAgID8gMVxuICAgICAgICA6IHZhbHVlIDwgMTYzODQgICAgID8gMlxuICAgICAgICA6IHZhbHVlIDwgMjA5NzE1MiAgID8gM1xuICAgICAgICA6IHZhbHVlIDwgMjY4NDM1NDU2ID8gNFxuICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgNSxcbiAgICB2YWx1ZSkpLmxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgMFxuICAgICAgICA/IHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgMTAsIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpKSAvLyAxMCBieXRlcyBwZXIgc3BlY1xuICAgICAgICA6IHRoaXMudWludDMyKHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigodmFsdWUgPDwgMSBeIHZhbHVlID4+IDMxKSA+Pj4gMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVZhcmludDY0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsLmhpKSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9ICh2YWwubG8gPj4+IDcgfCB2YWwuaGkgPDwgMjUpID4+PiAwO1xuICAgICAgICB2YWwuaGkgPj4+PSA3O1xuICAgIH1cbiAgICB3aGlsZSAodmFsLmxvID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9IHZhbC5sbyA+Pj4gNztcbiAgICB9XG4gICAgYnVmW3BvcysrXSA9IHZhbC5sbztcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDY0ID0gZnVuY3Rpb24gd3JpdGVfdWludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50NjQgPSBXcml0ZXIucHJvdG90eXBlLnVpbnQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50NjQgPSBmdW5jdGlvbiB3cml0ZV9zaW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpLnp6RW5jb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGJvb2xpc2ggdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gd3JpdGVfYm9vbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgdmFsdWUgPyAxIDogMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZpeGVkMzIodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICAmIDI1NTtcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkMzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIHZhbHVlID4+PiAwKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDMyID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkNjQgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMubG8pLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5oaSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkNjQgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkNjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgZmxvYXQgKDMyIGJpdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiB3cml0ZV9mbG9hdCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVGbG9hdExFLCA0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiB3cml0ZV9kb3VibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRG91YmxlTEUsIDgsIHZhbHVlKTtcbn07XG5cbnZhciB3cml0ZUJ5dGVzID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc2V0XG4gICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfZm9yKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB2YWxbaV07XG4gICAgfTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzZXF1ZW5jZSBvZiBieXRlcy5cbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IHZhbHVlIEJ1ZmZlciBvciBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXModmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgIGlmICghbGVuKVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB2YXIgYnVmID0gV3JpdGVyLmFsbG9jKGxlbiA9IGJhc2U2NC5sZW5ndGgodmFsdWUpKTtcbiAgICAgICAgYmFzZTY0LmRlY29kZSh2YWx1ZSwgYnVmLCAwKTtcbiAgICAgICAgdmFsdWUgPSBidWY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHdyaXRlQnl0ZXMsIGxlbiwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB1dGY4Lmxlbmd0aCh2YWx1ZSk7XG4gICAgcmV0dXJuIGxlblxuICAgICAgICA/IHRoaXMudWludDMyKGxlbikuX3B1c2godXRmOC53cml0ZSwgbGVuLCB2YWx1ZSlcbiAgICAgICAgOiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG59O1xuXG4vKipcbiAqIEZvcmtzIHRoaXMgd3JpdGVyJ3Mgc3RhdGUgYnkgcHVzaGluZyBpdCB0byBhIHN0YWNrLlxuICogQ2FsbGluZyB7QGxpbmsgV3JpdGVyI3Jlc2V0fHJlc2V0fSBvciB7QGxpbmsgV3JpdGVyI2xkZWxpbXxsZGVsaW19IHJlc2V0cyB0aGUgd3JpdGVyIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiBmb3JrKCkge1xuICAgIHRoaXMuc3RhdGVzID0gbmV3IFN0YXRlKHRoaXMpO1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICB0aGlzLmxlbiA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGlzIGluc3RhbmNlIHRvIHRoZSBsYXN0IHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5oZWFkICAgPSB0aGlzLnN0YXRlcy5oZWFkO1xuICAgICAgICB0aGlzLnRhaWwgICA9IHRoaXMuc3RhdGVzLnRhaWw7XG4gICAgICAgIHRoaXMubGVuICAgID0gdGhpcy5zdGF0ZXMubGVuO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHRoaXMuc3RhdGVzLm5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgICAgICB0aGlzLmxlbiAgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRvIHRoZSBsYXN0IHN0YXRlIGFuZCBhcHBlbmRzIHRoZSBmb3JrIHN0YXRlJ3MgY3VycmVudCB3cml0ZSBsZW5ndGggYXMgYSB2YXJpbnQgZm9sbG93ZWQgYnkgaXRzIG9wZXJhdGlvbnMuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5sZGVsaW0gPSBmdW5jdGlvbiBsZGVsaW0oKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQsXG4gICAgICAgIHRhaWwgPSB0aGlzLnRhaWwsXG4gICAgICAgIGxlbiAgPSB0aGlzLmxlbjtcbiAgICB0aGlzLnJlc2V0KCkudWludDMyKGxlbik7XG4gICAgaWYgKGxlbikge1xuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGhlYWQubmV4dDsgLy8gc2tpcCBub29wXG4gICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gRmluaXNoZWQgYnVmZmVyXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLm5leHQsIC8vIHNraXAgbm9vcFxuICAgICAgICBidWYgID0gdGhpcy5jb25zdHJ1Y3Rvci5hbGxvYyh0aGlzLmxlbiksXG4gICAgICAgIHBvcyAgPSAwO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICAgIGhlYWQuZm4oaGVhZC52YWwsIGJ1ZiwgcG9zKTtcbiAgICAgICAgcG9zICs9IGhlYWQubGVuO1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgIH1cbiAgICAvLyB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHJldHVybiBidWY7XG59O1xuXG5Xcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlcldyaXRlcl8pIHtcbiAgICBCdWZmZXJXcml0ZXIgPSBCdWZmZXJXcml0ZXJfO1xuICAgIFdyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJXcml0ZXI7XG5cbi8vIGV4dGVuZHMgV3JpdGVyXG52YXIgV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xuKEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlcldyaXRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQnVmZmVyV3JpdGVyKCkge1xuICAgIFdyaXRlci5jYWxsKHRoaXMpO1xufVxuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gQnVmZmVyXG4gICAgICovXG4gICAgQnVmZmVyV3JpdGVyLmFsbG9jID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlO1xuXG4gICAgQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIgPSB1dGlsLkJ1ZmZlciAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZSA9PT0gXCJzZXRcIlxuICAgICAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gZmFzdGVyIHRoYW4gY29weSAocmVxdWlyZXMgbm9kZSA+PSA0IHdoZXJlIEJ1ZmZlcnMgZXh0ZW5kIFVpbnQ4QXJyYXkgYW5kIHNldCBpcyBwcm9wZXJseSBpbmhlcml0ZWQpXG4gICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX2NvcHkodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGlmICh2YWwuY29weSkgLy8gQnVmZmVyIHZhbHVlc1xuICAgICAgICAgICAgdmFsLmNvcHkoYnVmLCBwb3MsIDAsIHZhbC5sZW5ndGgpO1xuICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOykgLy8gcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgICAgICBidWZbcG9zKytdID0gdmFsW2krK107XG4gICAgICAgIH07XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlc19idWZmZXIodmFsdWUpIHtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpXG4gICAgICAgIHZhbHVlID0gdXRpbC5fQnVmZmVyX2Zyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nQnVmZmVyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA8IDQwKSAvLyBwbGFpbiBqcyBpcyBmYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgKHByb2JhYmx5IGR1ZSB0byByZWR1bmRhbnQgYXNzZXJ0aW9ucylcbiAgICAgICAgdXRpbC51dGY4LndyaXRlKHZhbCwgYnVmLCBwb3MpO1xuICAgIGVsc2UgaWYgKGJ1Zi51dGY4V3JpdGUpXG4gICAgICAgIGJ1Zi51dGY4V3JpdGUodmFsLCBwb3MpO1xuICAgIGVsc2VcbiAgICAgICAgYnVmLndyaXRlKHZhbCwgcG9zKTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmdfYnVmZmVyKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0aWwuQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEBuYW1lIEJ1ZmZlcldyaXRlciNmaW5pc2hcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gRmluaXNoZWQgYnVmZmVyXG4gKi9cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbiIsIi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBTRFAgaGVscGVycy5cbmNvbnN0IFNEUFV0aWxzID0ge307XG5cbi8vIEdlbmVyYXRlIGFuIGFscGhhbnVtZXJpYyBpZGVudGlmaWVyIGZvciBjbmFtZSBvciBtaWRzLlxuLy8gVE9ETzogdXNlIFVVSURzIGluc3RlYWQ/IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcblNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDEwKTtcbn07XG5cbi8vIFRoZSBSVENQIENOQU1FIHVzZWQgYnkgYWxsIHBlZXJjb25uZWN0aW9ucyBmcm9tIHRoZSBzYW1lIEpTLlxuU0RQVXRpbHMubG9jYWxDTmFtZSA9IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuXG4vLyBTcGxpdHMgU0RQIGludG8gbGluZXMsIGRlYWxpbmcgd2l0aCBib3RoIENSTEYgYW5kIExGLlxuU0RQVXRpbHMuc3BsaXRMaW5lcyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgcmV0dXJuIGJsb2IudHJpbSgpLnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSk7XG59O1xuLy8gU3BsaXRzIFNEUCBpbnRvIHNlc3Npb25wYXJ0IGFuZCBtZWRpYXNlY3Rpb25zLiBFbnN1cmVzIENSTEYuXG5TRFBVdGlscy5zcGxpdFNlY3Rpb25zID0gZnVuY3Rpb24oYmxvYikge1xuICBjb25zdCBwYXJ0cyA9IGJsb2Iuc3BsaXQoJ1xcbm09Jyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoKHBhcnQsIGluZGV4KSA9PiAoaW5kZXggPiAwID9cbiAgICAnbT0nICsgcGFydCA6IHBhcnQpLnRyaW0oKSArICdcXHJcXG4nKTtcbn07XG5cbi8vIFJldHVybnMgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24uXG5TRFBVdGlscy5nZXREZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICByZXR1cm4gc2VjdGlvbnMgJiYgc2VjdGlvbnNbMF07XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBpbmRpdmlkdWFsIG1lZGlhIHNlY3Rpb25zLlxuU0RQVXRpbHMuZ2V0TWVkaWFTZWN0aW9ucyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICBzZWN0aW9ucy5zaGlmdCgpO1xuICByZXR1cm4gc2VjdGlvbnM7XG59O1xuXG4vLyBSZXR1cm5zIGxpbmVzIHRoYXQgc3RhcnQgd2l0aCBhIGNlcnRhaW4gcHJlZml4LlxuU0RQVXRpbHMubWF0Y2hQcmVmaXggPSBmdW5jdGlvbihibG9iLCBwcmVmaXgpIHtcbiAgcmV0dXJuIFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYikuZmlsdGVyKGxpbmUgPT4gbGluZS5pbmRleE9mKHByZWZpeCkgPT09IDApO1xufTtcblxuLy8gUGFyc2VzIGFuIElDRSBjYW5kaWRhdGUgbGluZS4gU2FtcGxlIGlucHV0OlxuLy8gY2FuZGlkYXRlOjcwMjc4NjM1MCAyIHVkcCA0MTgxOTkwMiA4LjguOC44IDYwNzY5IHR5cCByZWxheSByYWRkciA4LjguOC44XG4vLyBycG9ydCA1NTk5NlwiXG4vLyBJbnB1dCBjYW4gYmUgcHJlZml4ZWQgd2l0aCBhPS5cblNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlID0gZnVuY3Rpb24obGluZSkge1xuICBsZXQgcGFydHM7XG4gIC8vIFBhcnNlIGJvdGggdmFyaWFudHMuXG4gIGlmIChsaW5lLmluZGV4T2YoJ2E9Y2FuZGlkYXRlOicpID09PSAwKSB7XG4gICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMikuc3BsaXQoJyAnKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICB9XG5cbiAgY29uc3QgY2FuZGlkYXRlID0ge1xuICAgIGZvdW5kYXRpb246IHBhcnRzWzBdLFxuICAgIGNvbXBvbmVudDogezE6ICdydHAnLCAyOiAncnRjcCd9W3BhcnRzWzFdXSB8fCBwYXJ0c1sxXSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0udG9Mb3dlckNhc2UoKSxcbiAgICBwcmlvcml0eTogcGFyc2VJbnQocGFydHNbM10sIDEwKSxcbiAgICBpcDogcGFydHNbNF0sXG4gICAgYWRkcmVzczogcGFydHNbNF0sIC8vIGFkZHJlc3MgaXMgYW4gYWxpYXMgZm9yIGlwLlxuICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzVdLCAxMCksXG4gICAgLy8gc2tpcCBwYXJ0c1s2XSA9PSAndHlwJ1xuICAgIHR5cGU6IHBhcnRzWzddLFxuICB9O1xuXG4gIGZvciAobGV0IGkgPSA4OyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBzd2l0Y2ggKHBhcnRzW2ldKSB7XG4gICAgICBjYXNlICdyYWRkcic6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdycG9ydCc6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCA9IHBhcnNlSW50KHBhcnRzW2kgKyAxXSwgMTApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RjcHR5cGUnOlxuICAgICAgICBjYW5kaWRhdGUudGNwVHlwZSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1ZnJhZyc6XG4gICAgICAgIGNhbmRpZGF0ZS51ZnJhZyA9IHBhcnRzW2kgKyAxXTsgLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50ID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIGV4dGVuc2lvbiBoYW5kbGluZywgaW4gcGFydGljdWxhciB1ZnJhZy4gRG9uJ3Qgb3ZlcndyaXRlLlxuICAgICAgICBpZiAoY2FuZGlkYXRlW3BhcnRzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2FuZGlkYXRlW3BhcnRzW2ldXSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn07XG5cbi8vIFRyYW5zbGF0ZXMgYSBjYW5kaWRhdGUgb2JqZWN0IGludG8gU0RQIGNhbmRpZGF0ZSBhdHRyaWJ1dGUuXG4vLyBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIGE9IHByZWZpeCFcblNEUFV0aWxzLndyaXRlQ2FuZGlkYXRlID0gZnVuY3Rpb24oY2FuZGlkYXRlKSB7XG4gIGNvbnN0IHNkcCA9IFtdO1xuICBzZHAucHVzaChjYW5kaWRhdGUuZm91bmRhdGlvbik7XG5cbiAgY29uc3QgY29tcG9uZW50ID0gY2FuZGlkYXRlLmNvbXBvbmVudDtcbiAgaWYgKGNvbXBvbmVudCA9PT0gJ3J0cCcpIHtcbiAgICBzZHAucHVzaCgxKTtcbiAgfSBlbHNlIGlmIChjb21wb25lbnQgPT09ICdydGNwJykge1xuICAgIHNkcC5wdXNoKDIpO1xuICB9IGVsc2Uge1xuICAgIHNkcC5wdXNoKGNvbXBvbmVudCk7XG4gIH1cbiAgc2RwLnB1c2goY2FuZGlkYXRlLnByb3RvY29sLnRvVXBwZXJDYXNlKCkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUucHJpb3JpdHkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUuYWRkcmVzcyB8fCBjYW5kaWRhdGUuaXApO1xuICBzZHAucHVzaChjYW5kaWRhdGUucG9ydCk7XG5cbiAgY29uc3QgdHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuICBzZHAucHVzaCgndHlwJyk7XG4gIHNkcC5wdXNoKHR5cGUpO1xuICBpZiAodHlwZSAhPT0gJ2hvc3QnICYmIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyAmJlxuICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KSB7XG4gICAgc2RwLnB1c2goJ3JhZGRyJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzKTtcbiAgICBzZHAucHVzaCgncnBvcnQnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZFBvcnQpO1xuICB9XG4gIGlmIChjYW5kaWRhdGUudGNwVHlwZSAmJiBjYW5kaWRhdGUucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gJ3RjcCcpIHtcbiAgICBzZHAucHVzaCgndGNwdHlwZScpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS50Y3BUeXBlKTtcbiAgfVxuICBpZiAoY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKSB7XG4gICAgc2RwLnB1c2goJ3VmcmFnJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKTtcbiAgfVxuICByZXR1cm4gJ2NhbmRpZGF0ZTonICsgc2RwLmpvaW4oJyAnKTtcbn07XG5cbi8vIFBhcnNlcyBhbiBpY2Utb3B0aW9ucyBsaW5lLCByZXR1cm5zIGFuIGFycmF5IG9mIG9wdGlvbiB0YWdzLlxuLy8gU2FtcGxlIGlucHV0OlxuLy8gYT1pY2Utb3B0aW9uczpmb28gYmFyXG5TRFBVdGlscy5wYXJzZUljZU9wdGlvbnMgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHJldHVybiBsaW5lLnN1YnN0cigxNCkuc3BsaXQoJyAnKTtcbn07XG5cbi8vIFBhcnNlcyBhIHJ0cG1hcCBsaW5lLCByZXR1cm5zIFJUQ1J0cENvZGRlY1BhcmFtZXRlcnMuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRwbWFwOjExMSBvcHVzLzQ4MDAwLzJcblNEUFV0aWxzLnBhcnNlUnRwTWFwID0gZnVuY3Rpb24obGluZSkge1xuICBsZXQgcGFydHMgPSBsaW5lLnN1YnN0cig5KS5zcGxpdCgnICcpO1xuICBjb25zdCBwYXJzZWQgPSB7XG4gICAgcGF5bG9hZFR5cGU6IHBhcnNlSW50KHBhcnRzLnNoaWZ0KCksIDEwKSwgLy8gd2FzOiBpZFxuICB9O1xuXG4gIHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcblxuICBwYXJzZWQubmFtZSA9IHBhcnRzWzBdO1xuICBwYXJzZWQuY2xvY2tSYXRlID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsgLy8gd2FzOiBjbG9ja3JhdGVcbiAgcGFyc2VkLmNoYW5uZWxzID0gcGFydHMubGVuZ3RoID09PSAzID8gcGFyc2VJbnQocGFydHNbMl0sIDEwKSA6IDE7XG4gIC8vIGxlZ2FjeSBhbGlhcywgZ290IHJlbmFtZWQgYmFjayB0byBjaGFubmVscyBpbiBPUlRDLlxuICBwYXJzZWQubnVtQ2hhbm5lbHMgPSBwYXJzZWQuY2hhbm5lbHM7XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBHZW5lcmF0ZXMgYSBydHBtYXAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvclxuLy8gUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdHBNYXAgPSBmdW5jdGlvbihjb2RlYykge1xuICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGNvbnN0IGNoYW5uZWxzID0gY29kZWMuY2hhbm5lbHMgfHwgY29kZWMubnVtQ2hhbm5lbHMgfHwgMTtcbiAgcmV0dXJuICdhPXJ0cG1hcDonICsgcHQgKyAnICcgKyBjb2RlYy5uYW1lICsgJy8nICsgY29kZWMuY2xvY2tSYXRlICtcbiAgICAgIChjaGFubmVscyAhPT0gMSA/ICcvJyArIGNoYW5uZWxzIDogJycpICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgYSBleHRtYXAgbGluZSAoaGVhZGVyZXh0ZW5zaW9uIGZyb20gUkZDIDUyODUpLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbi8vIGE9ZXh0bWFwOjIvc2VuZG9ubHkgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuU0RQVXRpbHMucGFyc2VFeHRtYXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHIoOSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICBkaXJlY3Rpb246IHBhcnRzWzBdLmluZGV4T2YoJy8nKSA+IDAgPyBwYXJ0c1swXS5zcGxpdCgnLycpWzFdIDogJ3NlbmRyZWN2JyxcbiAgICB1cmk6IHBhcnRzWzFdLFxuICB9O1xufTtcblxuLy8gR2VuZXJhdGVzIGFuIGV4dG1hcCBsaW5lIGZyb20gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGVycyBvclxuLy8gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uLlxuU0RQVXRpbHMud3JpdGVFeHRtYXAgPSBmdW5jdGlvbihoZWFkZXJFeHRlbnNpb24pIHtcbiAgcmV0dXJuICdhPWV4dG1hcDonICsgKGhlYWRlckV4dGVuc2lvbi5pZCB8fCBoZWFkZXJFeHRlbnNpb24ucHJlZmVycmVkSWQpICtcbiAgICAgIChoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICYmIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kcmVjdidcbiAgICAgICAgPyAnLycgKyBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uXG4gICAgICAgIDogJycpICtcbiAgICAgICcgJyArIGhlYWRlckV4dGVuc2lvbi51cmkgKyAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyBhIGZtdHAgbGluZSwgcmV0dXJucyBkaWN0aW9uYXJ5LiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWZtdHA6OTYgdmJyPW9uO2NuZz1vblxuLy8gQWxzbyBkZWFscyB3aXRoIHZicj1vbjsgY25nPW9uXG5TRFBVdGlscy5wYXJzZUZtdHAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xuICBsZXQga3Y7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHIobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnOycpO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAga3YgPSBwYXJ0c1tqXS50cmltKCkuc3BsaXQoJz0nKTtcbiAgICBwYXJzZWRba3ZbMF0udHJpbSgpXSA9IGt2WzFdO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBHZW5lcmF0ZXMgYSBmbXRwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVGbXRwID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgbGV0IGxpbmUgPSAnJztcbiAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBpZiAoY29kZWMucGFyYW1ldGVycyAmJiBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5sZW5ndGgpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5mb3JFYWNoKHBhcmFtID0+IHtcbiAgICAgIGlmIChjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtICsgJz0nICsgY29kZWMucGFyYW1ldGVyc1twYXJhbV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxpbmUgKz0gJ2E9Zm10cDonICsgcHQgKyAnICcgKyBwYXJhbXMuam9pbignOycpICsgJ1xcclxcbic7XG4gIH1cbiAgcmV0dXJuIGxpbmU7XG59O1xuXG4vLyBQYXJzZXMgYSBydGNwLWZiIGxpbmUsIHJldHVybnMgUlRDUFJ0Y3BGZWVkYmFjayBvYmplY3QuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcblNEUFV0aWxzLnBhcnNlUnRjcEZiID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBwYXJ0cy5zaGlmdCgpLFxuICAgIHBhcmFtZXRlcjogcGFydHMuam9pbignICcpLFxuICB9O1xufTtcblxuLy8gR2VuZXJhdGUgYT1ydGNwLWZiIGxpbmVzIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlUnRjcEZiID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgbGV0IGxpbmVzID0gJyc7XG4gIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gIH1cbiAgaWYgKGNvZGVjLnJ0Y3BGZWVkYmFjayAmJiBjb2RlYy5ydGNwRmVlZGJhY2subGVuZ3RoKSB7XG4gICAgLy8gRklYTUU6IHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRyci1pbnQ/XG4gICAgY29kZWMucnRjcEZlZWRiYWNrLmZvckVhY2goZmIgPT4ge1xuICAgICAgbGluZXMgKz0gJ2E9cnRjcC1mYjonICsgcHQgKyAnICcgKyBmYi50eXBlICtcbiAgICAgIChmYi5wYXJhbWV0ZXIgJiYgZmIucGFyYW1ldGVyLmxlbmd0aCA/ICcgJyArIGZiLnBhcmFtZXRlciA6ICcnKSArXG4gICAgICAgICAgJ1xcclxcbic7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxpbmVzO1xufTtcblxuLy8gUGFyc2VzIGEgUkZDIDU1NzYgc3NyYyBtZWRpYSBhdHRyaWJ1dGUuIFNhbXBsZSBpbnB1dDpcbi8vIGE9c3NyYzozNzM1OTI4NTU5IGNuYW1lOnNvbWV0aGluZ1xuU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHNwID0gbGluZS5pbmRleE9mKCcgJyk7XG4gIGNvbnN0IHBhcnRzID0ge1xuICAgIHNzcmM6IHBhcnNlSW50KGxpbmUuc3Vic3RyKDcsIHNwIC0gNyksIDEwKSxcbiAgfTtcbiAgY29uc3QgY29sb24gPSBsaW5lLmluZGV4T2YoJzonLCBzcCk7XG4gIGlmIChjb2xvbiA+IC0xKSB7XG4gICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHIoc3AgKyAxLCBjb2xvbiAtIHNwIC0gMSk7XG4gICAgcGFydHMudmFsdWUgPSBsaW5lLnN1YnN0cihjb2xvbiArIDEpO1xuICB9IGVsc2Uge1xuICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyKHNwICsgMSk7XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufTtcblxuLy8gUGFyc2UgYSBzc3JjLWdyb3VwIGxpbmUgKHNlZSBSRkMgNTU3NikuIFNhbXBsZSBpbnB1dDpcbi8vIGE9c3NyYy1ncm91cDpzZW1hbnRpY3MgMTIgMzRcblNEUFV0aWxzLnBhcnNlU3NyY0dyb3VwID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyKDEzKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHNlbWFudGljczogcGFydHMuc2hpZnQoKSxcbiAgICBzc3JjczogcGFydHMubWFwKHNzcmMgPT4gcGFyc2VJbnQoc3NyYywgMTApKSxcbiAgfTtcbn07XG5cbi8vIEV4dHJhY3RzIHRoZSBNSUQgKFJGQyA1ODg4KSBmcm9tIGEgbWVkaWEgc2VjdGlvbi5cbi8vIFJldHVybnMgdGhlIE1JRCBvciB1bmRlZmluZWQgaWYgbm8gbWlkIGxpbmUgd2FzIGZvdW5kLlxuU0RQVXRpbHMuZ2V0TWlkID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IG1pZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWlkOicpWzBdO1xuICBpZiAobWlkKSB7XG4gICAgcmV0dXJuIG1pZC5zdWJzdHIoNik7XG4gIH1cbn07XG5cbi8vIFBhcnNlcyBhIGZpbmdlcnByaW50IGxpbmUgZm9yIERUTFMtU1JUUC5cblNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHIoMTQpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgYWxnb3JpdGhtOiBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLCAvLyBhbGdvcml0aG0gaXMgY2FzZS1zZW5zaXRpdmUgaW4gRWRnZS5cbiAgICB2YWx1ZTogcGFydHNbMV0udG9VcHBlckNhc2UoKSwgLy8gdGhlIGRlZmluaXRpb24gaXMgdXBwZXItY2FzZSBpbiBSRkMgNDU3Mi5cbiAgfTtcbn07XG5cbi8vIEV4dHJhY3RzIERUTFMgcGFyYW1ldGVycyBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4vLyAgIGdldCB0aGUgZmluZ2VycHJpbnQgbGluZSBhcyBpbnB1dC4gU2VlIGFsc28gZ2V0SWNlUGFyYW1ldGVycy5cblNEUFV0aWxzLmdldER0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWZpbmdlcnByaW50OicpO1xuICAvLyBOb3RlOiBhPXNldHVwIGxpbmUgaXMgaWdub3JlZCBzaW5jZSB3ZSB1c2UgdGhlICdhdXRvJyByb2xlIGluIEVkZ2UuXG4gIHJldHVybiB7XG4gICAgcm9sZTogJ2F1dG8nLFxuICAgIGZpbmdlcnByaW50czogbGluZXMubWFwKFNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQpLFxuICB9O1xufTtcblxuLy8gU2VyaWFsaXplcyBEVExTIHBhcmFtZXRlcnMgdG8gU0RQLlxuU0RQVXRpbHMud3JpdGVEdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtcywgc2V0dXBUeXBlKSB7XG4gIGxldCBzZHAgPSAnYT1zZXR1cDonICsgc2V0dXBUeXBlICsgJ1xcclxcbic7XG4gIHBhcmFtcy5maW5nZXJwcmludHMuZm9yRWFjaChmcCA9PiB7XG4gICAgc2RwICs9ICdhPWZpbmdlcnByaW50OicgKyBmcC5hbGdvcml0aG0gKyAnICcgKyBmcC52YWx1ZSArICdcXHJcXG4nO1xuICB9KTtcbiAgcmV0dXJuIHNkcDtcbn07XG5cbi8vIFBhcnNlcyBhPWNyeXB0byBsaW5lcyBpbnRvXG4vLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjZGljdGlvbmFyeS1ydGNzcnRwc2Rlc3BhcmFtZXRlcnMtbWVtYmVyc1xuU0RQVXRpbHMucGFyc2VDcnlwdG9MaW5lID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyKDkpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgdGFnOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgIGNyeXB0b1N1aXRlOiBwYXJ0c1sxXSxcbiAgICBrZXlQYXJhbXM6IHBhcnRzWzJdLFxuICAgIHNlc3Npb25QYXJhbXM6IHBhcnRzLnNsaWNlKDMpLFxuICB9O1xufTtcblxuU0RQVXRpbHMud3JpdGVDcnlwdG9MaW5lID0gZnVuY3Rpb24ocGFyYW1ldGVycykge1xuICByZXR1cm4gJ2E9Y3J5cHRvOicgKyBwYXJhbWV0ZXJzLnRhZyArICcgJyArXG4gICAgcGFyYW1ldGVycy5jcnlwdG9TdWl0ZSArICcgJyArXG4gICAgKHR5cGVvZiBwYXJhbWV0ZXJzLmtleVBhcmFtcyA9PT0gJ29iamVjdCdcbiAgICAgID8gU0RQVXRpbHMud3JpdGVDcnlwdG9LZXlQYXJhbXMocGFyYW1ldGVycy5rZXlQYXJhbXMpXG4gICAgICA6IHBhcmFtZXRlcnMua2V5UGFyYW1zKSArXG4gICAgKHBhcmFtZXRlcnMuc2Vzc2lvblBhcmFtcyA/ICcgJyArIHBhcmFtZXRlcnMuc2Vzc2lvblBhcmFtcy5qb2luKCcgJykgOiAnJykgK1xuICAgICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIHRoZSBjcnlwdG8ga2V5IHBhcmFtZXRlcnMgaW50b1xuLy8gICBodHRwczovL3Jhd2dpdC5jb20vYWJvYmEvZWRnZXJ0Yy9tYXN0ZXIvbXNvcnRjLXJzNC5odG1sI3J0Y3NydHBrZXlwYXJhbSpcblNEUFV0aWxzLnBhcnNlQ3J5cHRvS2V5UGFyYW1zID0gZnVuY3Rpb24oa2V5UGFyYW1zKSB7XG4gIGlmIChrZXlQYXJhbXMuaW5kZXhPZignaW5saW5lOicpICE9PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcGFydHMgPSBrZXlQYXJhbXMuc3Vic3RyKDcpLnNwbGl0KCd8Jyk7XG4gIHJldHVybiB7XG4gICAga2V5TWV0aG9kOiAnaW5saW5lJyxcbiAgICBrZXlTYWx0OiBwYXJ0c1swXSxcbiAgICBsaWZlVGltZTogcGFydHNbMV0sXG4gICAgbWtpVmFsdWU6IHBhcnRzWzJdID8gcGFydHNbMl0uc3BsaXQoJzonKVswXSA6IHVuZGVmaW5lZCxcbiAgICBta2lMZW5ndGg6IHBhcnRzWzJdID8gcGFydHNbMl0uc3BsaXQoJzonKVsxXSA6IHVuZGVmaW5lZCxcbiAgfTtcbn07XG5cblNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zID0gZnVuY3Rpb24oa2V5UGFyYW1zKSB7XG4gIHJldHVybiBrZXlQYXJhbXMua2V5TWV0aG9kICsgJzonXG4gICAgKyBrZXlQYXJhbXMua2V5U2FsdCArXG4gICAgKGtleVBhcmFtcy5saWZlVGltZSA/ICd8JyArIGtleVBhcmFtcy5saWZlVGltZSA6ICcnKSArXG4gICAgKGtleVBhcmFtcy5ta2lWYWx1ZSAmJiBrZXlQYXJhbXMubWtpTGVuZ3RoXG4gICAgICA/ICd8JyArIGtleVBhcmFtcy5ta2lWYWx1ZSArICc6JyArIGtleVBhcmFtcy5ta2lMZW5ndGhcbiAgICAgIDogJycpO1xufTtcblxuLy8gRXh0cmFjdHMgYWxsIFNERVMgcGFyYW1ldGVycy5cblNEUFV0aWxzLmdldENyeXB0b1BhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsXG4gICAgJ2E9Y3J5cHRvOicpO1xuICByZXR1cm4gbGluZXMubWFwKFNEUFV0aWxzLnBhcnNlQ3J5cHRvTGluZSk7XG59O1xuXG4vLyBQYXJzZXMgSUNFIGluZm9ybWF0aW9uIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4vLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcbi8vICAgZ2V0IHRoZSBpY2UtdWZyYWcgYW5kIGljZS1wd2QgbGluZXMgYXMgaW5wdXQuXG5TRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICBjb25zdCB1ZnJhZyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWljZS11ZnJhZzonKVswXTtcbiAgY29uc3QgcHdkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsXG4gICAgJ2E9aWNlLXB3ZDonKVswXTtcbiAgaWYgKCEodWZyYWcgJiYgcHdkKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgdXNlcm5hbWVGcmFnbWVudDogdWZyYWcuc3Vic3RyKDEyKSxcbiAgICBwYXNzd29yZDogcHdkLnN1YnN0cigxMCksXG4gIH07XG59O1xuXG4vLyBTZXJpYWxpemVzIElDRSBwYXJhbWV0ZXJzIHRvIFNEUC5cblNEUFV0aWxzLndyaXRlSWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBsZXQgc2RwID0gJ2E9aWNlLXVmcmFnOicgKyBwYXJhbXMudXNlcm5hbWVGcmFnbWVudCArICdcXHJcXG4nICtcbiAgICAgICdhPWljZS1wd2Q6JyArIHBhcmFtcy5wYXNzd29yZCArICdcXHJcXG4nO1xuICBpZiAocGFyYW1zLmljZUxpdGUpIHtcbiAgICBzZHAgKz0gJ2E9aWNlLWxpdGVcXHJcXG4nO1xuICB9XG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIFJUQ1J0cFBhcmFtZXRlcnMuXG5TRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSB7XG4gICAgY29kZWNzOiBbXSxcbiAgICBoZWFkZXJFeHRlbnNpb25zOiBbXSxcbiAgICBmZWNNZWNoYW5pc21zOiBbXSxcbiAgICBydGNwOiBbXSxcbiAgfTtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIGNvbnN0IG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBtbGluZS5sZW5ndGg7IGkrKykgeyAvLyBmaW5kIGFsbCBjb2RlY3MgZnJvbSBtbGluZVszLi5dXG4gICAgY29uc3QgcHQgPSBtbGluZVtpXTtcbiAgICBjb25zdCBydHBtYXBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0cG1hcDonICsgcHQgKyAnICcpWzBdO1xuICAgIGlmIChydHBtYXBsaW5lKSB7XG4gICAgICBjb25zdCBjb2RlYyA9IFNEUFV0aWxzLnBhcnNlUnRwTWFwKHJ0cG1hcGxpbmUpO1xuICAgICAgY29uc3QgZm10cHMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgICAgbWVkaWFTZWN0aW9uLCAnYT1mbXRwOicgKyBwdCArICcgJyk7XG4gICAgICAvLyBPbmx5IHRoZSBmaXJzdCBhPWZtdHA6PHB0PiBpcyBjb25zaWRlcmVkLlxuICAgICAgY29kZWMucGFyYW1ldGVycyA9IGZtdHBzLmxlbmd0aCA/IFNEUFV0aWxzLnBhcnNlRm10cChmbXRwc1swXSkgOiB7fTtcbiAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnKVxuICAgICAgICAubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICAgIC8vIHBhcnNlIEZFQyBtZWNoYW5pc21zIGZyb20gcnRwbWFwIGxpbmVzLlxuICAgICAgc3dpdGNoIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnUkVEJzpcbiAgICAgICAgY2FzZSAnVUxQRkVDJzpcbiAgICAgICAgICBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLnB1c2goY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gb25seSBSRUQgYW5kIFVMUEZFQyBhcmUgcmVjb2duaXplZCBhcyBGRUMgbWVjaGFuaXNtcy5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1leHRtYXA6JykuZm9yRWFjaChsaW5lID0+IHtcbiAgICBkZXNjcmlwdGlvbi5oZWFkZXJFeHRlbnNpb25zLnB1c2goU0RQVXRpbHMucGFyc2VFeHRtYXAobGluZSkpO1xuICB9KTtcbiAgLy8gRklYTUU6IHBhcnNlIHJ0Y3AuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn07XG5cbi8vIEdlbmVyYXRlcyBwYXJ0cyBvZiB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gZGVzY3JpYmluZyB0aGUgY2FwYWJpbGl0aWVzIC9cbi8vIHBhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24oa2luZCwgY2Fwcykge1xuICBsZXQgc2RwID0gJyc7XG5cbiAgLy8gQnVpbGQgdGhlIG1saW5lLlxuICBzZHAgKz0gJ209JyArIGtpbmQgKyAnICc7XG4gIHNkcCArPSBjYXBzLmNvZGVjcy5sZW5ndGggPiAwID8gJzknIDogJzAnOyAvLyByZWplY3QgaWYgbm8gY29kZWNzLlxuICBzZHAgKz0gJyBVRFAvVExTL1JUUC9TQVZQRiAnO1xuICBzZHAgKz0gY2Fwcy5jb2RlY3MubWFwKGNvZGVjID0+IHtcbiAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gY29kZWMucGF5bG9hZFR5cGU7XG4gIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuXG4gIHNkcCArPSAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbic7XG4gIHNkcCArPSAnYT1ydGNwOjkgSU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xuXG4gIC8vIEFkZCBhPXJ0cG1hcCBsaW5lcyBmb3IgZWFjaCBjb2RlYy4gQWxzbyBmbXRwIGFuZCBydGNwLWZiLlxuICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdHBNYXAoY29kZWMpO1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUZtdHAoY29kZWMpO1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0Y3BGYihjb2RlYyk7XG4gIH0pO1xuICBsZXQgbWF4cHRpbWUgPSAwO1xuICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICBpZiAoY29kZWMubWF4cHRpbWUgPiBtYXhwdGltZSkge1xuICAgICAgbWF4cHRpbWUgPSBjb2RlYy5tYXhwdGltZTtcbiAgICB9XG4gIH0pO1xuICBpZiAobWF4cHRpbWUgPiAwKSB7XG4gICAgc2RwICs9ICdhPW1heHB0aW1lOicgKyBtYXhwdGltZSArICdcXHJcXG4nO1xuICB9XG5cbiAgaWYgKGNhcHMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgIGNhcHMuaGVhZGVyRXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVFeHRtYXAoZXh0ZW5zaW9uKTtcbiAgICB9KTtcbiAgfVxuICAvLyBGSVhNRTogd3JpdGUgZmVjTWVjaGFuaXNtcy5cbiAgcmV0dXJuIHNkcDtcbn07XG5cbi8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgYW4gYXJyYXkgb2Zcbi8vIFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVycy5cblNEUFV0aWxzLnBhcnNlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGVuY29kaW5nUGFyYW1ldGVycyA9IFtdO1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICBjb25zdCBoYXNSZWQgPSBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLmluZGV4T2YoJ1JFRCcpICE9PSAtMTtcbiAgY29uc3QgaGFzVWxwZmVjID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdVTFBGRUMnKSAhPT0gLTE7XG5cbiAgLy8gZmlsdGVyIGE9c3NyYzouLi4gY25hbWU6LCBpZ25vcmUgUGxhbkItbXNpZFxuICBjb25zdCBzc3JjcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgIC5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSlcbiAgICAuZmlsdGVyKHBhcnRzID0+IHBhcnRzLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJyk7XG4gIGNvbnN0IHByaW1hcnlTc3JjID0gc3NyY3MubGVuZ3RoID4gMCAmJiBzc3Jjc1swXS5zc3JjO1xuICBsZXQgc2Vjb25kYXJ5U3NyYztcblxuICBjb25zdCBmbG93cyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYy1ncm91cDpGSUQnKVxuICAgIC5tYXAobGluZSA9PiB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyKDE3KS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHBhcnRzLm1hcChwYXJ0ID0+IHBhcnNlSW50KHBhcnQsIDEwKSk7XG4gICAgfSk7XG4gIGlmIChmbG93cy5sZW5ndGggPiAwICYmIGZsb3dzWzBdLmxlbmd0aCA+IDEgJiYgZmxvd3NbMF1bMF0gPT09IHByaW1hcnlTc3JjKSB7XG4gICAgc2Vjb25kYXJ5U3NyYyA9IGZsb3dzWzBdWzFdO1xuICB9XG5cbiAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgIGlmIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdSVFgnICYmIGNvZGVjLnBhcmFtZXRlcnMuYXB0KSB7XG4gICAgICBsZXQgZW5jUGFyYW0gPSB7XG4gICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICBjb2RlY1BheWxvYWRUeXBlOiBwYXJzZUludChjb2RlYy5wYXJhbWV0ZXJzLmFwdCwgMTApLFxuICAgICAgfTtcbiAgICAgIGlmIChwcmltYXJ5U3NyYyAmJiBzZWNvbmRhcnlTc3JjKSB7XG4gICAgICAgIGVuY1BhcmFtLnJ0eCA9IHtzc3JjOiBzZWNvbmRhcnlTc3JjfTtcbiAgICAgIH1cbiAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgIGlmIChoYXNSZWQpIHtcbiAgICAgICAgZW5jUGFyYW0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVuY1BhcmFtKSk7XG4gICAgICAgIGVuY1BhcmFtLmZlYyA9IHtcbiAgICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICAgICAgICBtZWNoYW5pc206IGhhc1VscGZlYyA/ICdyZWQrdWxwZmVjJyA6ICdyZWQnLFxuICAgICAgICB9O1xuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKGVuY29kaW5nUGFyYW1ldGVycy5sZW5ndGggPT09IDAgJiYgcHJpbWFyeVNzcmMpIHtcbiAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaCh7XG4gICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHdlIHN1cHBvcnQgYm90aCBiPUFTIGFuZCBiPVRJQVMgYnV0IGludGVycHJldCBBUyBhcyBUSUFTLlxuICBsZXQgYmFuZHdpZHRoID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYj0nKTtcbiAgaWYgKGJhbmR3aWR0aC5sZW5ndGgpIHtcbiAgICBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9VElBUzonKSA9PT0gMCkge1xuICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cig3KSwgMTApO1xuICAgIH0gZWxzZSBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9QVM6JykgPT09IDApIHtcbiAgICAgIC8vIHVzZSBmb3JtdWxhIGZyb20gSlNFUCB0byBjb252ZXJ0IGI9QVMgdG8gVElBUyB2YWx1ZS5cbiAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHIoNSksIDEwKSAqIDEwMDAgKiAwLjk1XG4gICAgICAgICAgLSAoNTAgKiA0MCAqIDgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYW5kd2lkdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVuY29kaW5nUGFyYW1ldGVycy5mb3JFYWNoKHBhcmFtcyA9PiB7XG4gICAgICBwYXJhbXMubWF4Qml0cmF0ZSA9IGJhbmR3aWR0aDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZW5jb2RpbmdQYXJhbWV0ZXJzO1xufTtcblxuLy8gcGFyc2VzIGh0dHA6Ly9kcmFmdC5vcnRjLm9yZy8jcnRjcnRjcHBhcmFtZXRlcnMqXG5TRFBVdGlscy5wYXJzZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IHJ0Y3BQYXJhbWV0ZXJzID0ge307XG5cbiAgLy8gR2V0cyB0aGUgZmlyc3QgU1NSQy4gTm90ZSB0aGF0IHdpdGggUlRYIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlXG4gIC8vIFNTUkNzLlxuICBjb25zdCByZW1vdGVTc3JjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpXG4gICAgLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKVxuICAgIC5maWx0ZXIob2JqID0+IG9iai5hdHRyaWJ1dGUgPT09ICdjbmFtZScpWzBdO1xuICBpZiAocmVtb3RlU3NyYykge1xuICAgIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lID0gcmVtb3RlU3NyYy52YWx1ZTtcbiAgICBydGNwUGFyYW1ldGVycy5zc3JjID0gcmVtb3RlU3NyYy5zc3JjO1xuICB9XG5cbiAgLy8gRWRnZSB1c2VzIHRoZSBjb21wb3VuZCBhdHRyaWJ1dGUgaW5zdGVhZCBvZiByZWR1Y2VkU2l6ZVxuICAvLyBjb21wb3VuZCBpcyAhcmVkdWNlZFNpemVcbiAgY29uc3QgcnNpemUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtcnNpemUnKTtcbiAgcnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUgPSByc2l6ZS5sZW5ndGggPiAwO1xuICBydGNwUGFyYW1ldGVycy5jb21wb3VuZCA9IHJzaXplLmxlbmd0aCA9PT0gMDtcblxuICAvLyBwYXJzZXMgdGhlIHJ0Y3AtbXV4IGF0dHLRlmJ1dGUuXG4gIC8vIE5vdGUgdGhhdCBFZGdlIGRvZXMgbm90IHN1cHBvcnQgdW5tdXhlZCBSVENQLlxuICBjb25zdCBtdXggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtbXV4Jyk7XG4gIHJ0Y3BQYXJhbWV0ZXJzLm11eCA9IG11eC5sZW5ndGggPiAwO1xuXG4gIHJldHVybiBydGNwUGFyYW1ldGVycztcbn07XG5cblNEUFV0aWxzLndyaXRlUnRjcFBhcmFtZXRlcnMgPSBmdW5jdGlvbihydGNwUGFyYW1ldGVycykge1xuICBsZXQgc2RwID0gJyc7XG4gIGlmIChydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSkge1xuICAgIHNkcCArPSAnYT1ydGNwLXJzaXplXFxyXFxuJztcbiAgfVxuICBpZiAocnRjcFBhcmFtZXRlcnMubXV4KSB7XG4gICAgc2RwICs9ICdhPXJ0Y3AtbXV4XFxyXFxuJztcbiAgfVxuICBpZiAocnRjcFBhcmFtZXRlcnMuc3NyYyAhPT0gdW5kZWZpbmVkICYmIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lKSB7XG4gICAgc2RwICs9ICdhPXNzcmM6JyArIHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgK1xuICAgICAgJyBjbmFtZTonICsgcnRjcFBhcmFtZXRlcnMuY25hbWUgKyAnXFxyXFxuJztcbiAgfVxuICByZXR1cm4gc2RwO1xufTtcblxuXG4vLyBwYXJzZXMgZWl0aGVyIGE9bXNpZDogb3IgYT1zc3JjOi4uLiBtc2lkIGxpbmVzIGFuZCByZXR1cm5zXG4vLyB0aGUgaWQgb2YgdGhlIE1lZGlhU3RyZWFtIGFuZCBNZWRpYVN0cmVhbVRyYWNrLlxuU0RQVXRpbHMucGFyc2VNc2lkID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGxldCBwYXJ0cztcbiAgY29uc3Qgc3BlYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bXNpZDonKTtcbiAgaWYgKHNwZWMubGVuZ3RoID09PSAxKSB7XG4gICAgcGFydHMgPSBzcGVjWzBdLnN1YnN0cig3KS5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7c3RyZWFtOiBwYXJ0c1swXSwgdHJhY2s6IHBhcnRzWzFdfTtcbiAgfVxuICBjb25zdCBwbGFuQiA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgIC5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSlcbiAgICAuZmlsdGVyKG1zaWRQYXJ0cyA9PiBtc2lkUGFydHMuYXR0cmlidXRlID09PSAnbXNpZCcpO1xuICBpZiAocGxhbkIubGVuZ3RoID4gMCkge1xuICAgIHBhcnRzID0gcGxhbkJbMF0udmFsdWUuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge3N0cmVhbTogcGFydHNbMF0sIHRyYWNrOiBwYXJ0c1sxXX07XG4gIH1cbn07XG5cbi8vIFNDVFBcbi8vIHBhcnNlcyBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiBmaXJzdCBhbmQgZmFsbHMgYmFja1xuLy8gdG8gZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDVcblNEUFV0aWxzLnBhcnNlU2N0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IG1saW5lID0gU0RQVXRpbHMucGFyc2VNTGluZShtZWRpYVNlY3Rpb24pO1xuICBjb25zdCBtYXhTaXplTGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonKTtcbiAgbGV0IG1heE1lc3NhZ2VTaXplO1xuICBpZiAobWF4U2l6ZUxpbmUubGVuZ3RoID4gMCkge1xuICAgIG1heE1lc3NhZ2VTaXplID0gcGFyc2VJbnQobWF4U2l6ZUxpbmVbMF0uc3Vic3RyKDE5KSwgMTApO1xuICB9XG4gIGlmIChpc05hTihtYXhNZXNzYWdlU2l6ZSkpIHtcbiAgICBtYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xuICB9XG4gIGNvbnN0IHNjdHBQb3J0ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zY3RwLXBvcnQ6Jyk7XG4gIGlmIChzY3RwUG9ydC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcnQ6IHBhcnNlSW50KHNjdHBQb3J0WzBdLnN1YnN0cigxMiksIDEwKSxcbiAgICAgIHByb3RvY29sOiBtbGluZS5mbXQsXG4gICAgICBtYXhNZXNzYWdlU2l6ZSxcbiAgICB9O1xuICB9XG4gIGNvbnN0IHNjdHBNYXBMaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cG1hcDonKTtcbiAgaWYgKHNjdHBNYXBMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcGFydHMgPSBzY3RwTWFwTGluZXNbMF1cbiAgICAgIC5zdWJzdHIoMTApXG4gICAgICAuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICAgIHByb3RvY29sOiBwYXJ0c1sxXSxcbiAgICAgIG1heE1lc3NhZ2VTaXplLFxuICAgIH07XG4gIH1cbn07XG5cbi8vIFNDVFBcbi8vIG91dHB1dHMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2IHZlcnNpb24gdGhhdCBhbGwgYnJvd3NlcnNcbi8vIHN1cHBvcnQgYnkgbm93IHJlY2VpdmluZyBpbiB0aGlzIGZvcm1hdCwgdW5sZXNzIHdlIG9yaWdpbmFsbHkgcGFyc2VkXG4vLyBhcyB0aGUgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDUgZm9ybWF0IChpbmRpY2F0ZWQgYnkgdGhlIG0tbGluZVxuLy8gcHJvdG9jb2wgb2YgRFRMUy9TQ1RQIC0tIHdpdGhvdXQgVURQLyBvciBUQ1AvKVxuU0RQVXRpbHMud3JpdGVTY3RwRGVzY3JpcHRpb24gPSBmdW5jdGlvbihtZWRpYSwgc2N0cCkge1xuICBsZXQgb3V0cHV0ID0gW107XG4gIGlmIChtZWRpYS5wcm90b2NvbCAhPT0gJ0RUTFMvU0NUUCcpIHtcbiAgICBvdXRwdXQgPSBbXG4gICAgICAnbT0nICsgbWVkaWEua2luZCArICcgOSAnICsgbWVkaWEucHJvdG9jb2wgKyAnICcgKyBzY3RwLnByb3RvY29sICsgJ1xcclxcbicsXG4gICAgICAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsXG4gICAgICAnYT1zY3RwLXBvcnQ6JyArIHNjdHAucG9ydCArICdcXHJcXG4nLFxuICAgIF07XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gW1xuICAgICAgJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wb3J0ICsgJ1xcclxcbicsXG4gICAgICAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsXG4gICAgICAnYT1zY3RwbWFwOicgKyBzY3RwLnBvcnQgKyAnICcgKyBzY3RwLnByb3RvY29sICsgJyA2NTUzNVxcclxcbicsXG4gICAgXTtcbiAgfVxuICBpZiAoc2N0cC5tYXhNZXNzYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LnB1c2goJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonICsgc2N0cC5tYXhNZXNzYWdlU2l6ZSArICdcXHJcXG4nKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufTtcblxuLy8gR2VuZXJhdGUgYSBzZXNzaW9uIElEIGZvciBTRFAuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1ydGN3ZWItanNlcC0yMCNzZWN0aW9uLTUuMi4xXG4vLyByZWNvbW1lbmRzIHVzaW5nIGEgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tICt2ZSA2NC1iaXQgdmFsdWVcbi8vIGJ1dCByaWdodCBub3cgdGhpcyBzaG91bGQgYmUgYWNjZXB0YWJsZSBhbmQgd2l0aGluIHRoZSByaWdodCByYW5nZVxuU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zdWJzdHIoMiwgMjEpO1xufTtcblxuLy8gV3JpdGUgYm9pbGVyIHBsYXRlIGZvciBzdGFydCBvZiBTRFBcbi8vIHNlc3NJZCBhcmd1bWVudCBpcyBvcHRpb25hbCAtIGlmIG5vdCBzdXBwbGllZCBpdCB3aWxsXG4vLyBiZSBnZW5lcmF0ZWQgcmFuZG9tbHlcbi8vIHNlc3NWZXJzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAyXG4vLyBzZXNzVXNlciBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gJ3RoaXNpc2FkYXB0ZXJvcnRjJ1xuU0RQVXRpbHMud3JpdGVTZXNzaW9uQm9pbGVycGxhdGUgPSBmdW5jdGlvbihzZXNzSWQsIHNlc3NWZXIsIHNlc3NVc2VyKSB7XG4gIGxldCBzZXNzaW9uSWQ7XG4gIGNvbnN0IHZlcnNpb24gPSBzZXNzVmVyICE9PSB1bmRlZmluZWQgPyBzZXNzVmVyIDogMjtcbiAgaWYgKHNlc3NJZCkge1xuICAgIHNlc3Npb25JZCA9IHNlc3NJZDtcbiAgfSBlbHNlIHtcbiAgICBzZXNzaW9uSWQgPSBTRFBVdGlscy5nZW5lcmF0ZVNlc3Npb25JZCgpO1xuICB9XG4gIGNvbnN0IHVzZXIgPSBzZXNzVXNlciB8fCAndGhpc2lzYWRhcHRlcm9ydGMnO1xuICAvLyBGSVhNRTogc2Vzcy1pZCBzaG91bGQgYmUgYW4gTlRQIHRpbWVzdGFtcC5cbiAgcmV0dXJuICd2PTBcXHJcXG4nICtcbiAgICAgICdvPScgKyB1c2VyICsgJyAnICsgc2Vzc2lvbklkICsgJyAnICsgdmVyc2lvbiArXG4gICAgICAgICcgSU4gSVA0IDEyNy4wLjAuMVxcclxcbicgK1xuICAgICAgJ3M9LVxcclxcbicgK1xuICAgICAgJ3Q9MCAwXFxyXFxuJztcbn07XG5cbi8vIEdldHMgdGhlIGRpcmVjdGlvbiBmcm9tIHRoZSBtZWRpYVNlY3Rpb24gb3IgdGhlIHNlc3Npb25wYXJ0LlxuU0RQVXRpbHMuZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICAvLyBMb29rIGZvciBzZW5kcmVjdiwgc2VuZG9ubHksIHJlY3Zvbmx5LCBpbmFjdGl2ZSwgZGVmYXVsdCB0byBzZW5kcmVjdi5cbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzd2l0Y2ggKGxpbmVzW2ldKSB7XG4gICAgICBjYXNlICdhPXNlbmRyZWN2JzpcbiAgICAgIGNhc2UgJ2E9c2VuZG9ubHknOlxuICAgICAgY2FzZSAnYT1yZWN2b25seSc6XG4gICAgICBjYXNlICdhPWluYWN0aXZlJzpcbiAgICAgICAgcmV0dXJuIGxpbmVzW2ldLnN1YnN0cigyKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEZJWE1FOiBXaGF0IHNob3VsZCBoYXBwZW4gaGVyZT9cbiAgICB9XG4gIH1cbiAgaWYgKHNlc3Npb25wYXJ0KSB7XG4gICAgcmV0dXJuIFNEUFV0aWxzLmdldERpcmVjdGlvbihzZXNzaW9ucGFydCk7XG4gIH1cbiAgcmV0dXJuICdzZW5kcmVjdic7XG59O1xuXG5TRFBVdGlscy5nZXRLaW5kID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBjb25zdCBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gIHJldHVybiBtbGluZVswXS5zdWJzdHIoMik7XG59O1xuXG5TRFBVdGlscy5pc1JlamVjdGVkID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHJldHVybiBtZWRpYVNlY3Rpb24uc3BsaXQoJyAnLCAyKVsxXSA9PT0gJzAnO1xufTtcblxuU0RQVXRpbHMucGFyc2VNTGluZSA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgcGFydHMgPSBsaW5lc1swXS5zdWJzdHIoMikuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBwYXJ0c1swXSxcbiAgICBwb3J0OiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxuICAgIHByb3RvY29sOiBwYXJ0c1syXSxcbiAgICBmbXQ6IHBhcnRzLnNsaWNlKDMpLmpvaW4oJyAnKSxcbiAgfTtcbn07XG5cblNEUFV0aWxzLnBhcnNlT0xpbmUgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgbGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ289JylbMF07XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHIoMikuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICB1c2VybmFtZTogcGFydHNbMF0sXG4gICAgc2Vzc2lvbklkOiBwYXJ0c1sxXSxcbiAgICBzZXNzaW9uVmVyc2lvbjogcGFyc2VJbnQocGFydHNbMl0sIDEwKSxcbiAgICBuZXRUeXBlOiBwYXJ0c1szXSxcbiAgICBhZGRyZXNzVHlwZTogcGFydHNbNF0sXG4gICAgYWRkcmVzczogcGFydHNbNV0sXG4gIH07XG59O1xuXG4vLyBhIHZlcnkgbmFpdmUgaW50ZXJwcmV0YXRpb24gb2YgYSB2YWxpZCBTRFAuXG5TRFBVdGlscy5pc1ZhbGlkU0RQID0gZnVuY3Rpb24oYmxvYikge1xuICBpZiAodHlwZW9mIGJsb2IgIT09ICdzdHJpbmcnIHx8IGJsb2IubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsaW5lc1tpXS5sZW5ndGggPCAyIHx8IGxpbmVzW2ldLmNoYXJBdCgxKSAhPT0gJz0nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRPRE86IGNoZWNrIHRoZSBtb2RpZmllciBhIGJpdCBtb3JlLlxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gU0RQVXRpbHM7XG59XG4iLCJmdW5jdGlvbiByKHIsZSxuKXt2YXIgaSx0LG87dm9pZCAwPT09ZSYmKGU9NTApLHZvaWQgMD09PW4mJihuPXt9KTt2YXIgYT1udWxsIT0oaT1uLmlzSW1tZWRpYXRlKSYmaSx1PW51bGwhPSh0PW4uY2FsbGJhY2spJiZ0LGM9bi5tYXhXYWl0LHY9RGF0ZS5ub3coKSxsPVtdO2Z1bmN0aW9uIGYoKXtpZih2b2lkIDAhPT1jKXt2YXIgcj1EYXRlLm5vdygpLXY7aWYocitlPj1jKXJldHVybiBjLXJ9cmV0dXJuIGV9dmFyIGQ9ZnVuY3Rpb24oKXt2YXIgZT1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksbj10aGlzO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihpLHQpe3ZhciBjPWEmJnZvaWQgMD09PW87aWYodm9pZCAwIT09byYmY2xlYXJUaW1lb3V0KG8pLG89c2V0VGltZW91dChmdW5jdGlvbigpe2lmKG89dm9pZCAwLHY9RGF0ZS5ub3coKSwhYSl7dmFyIGk9ci5hcHBseShuLGUpO3UmJnUoaSksbC5mb3JFYWNoKGZ1bmN0aW9uKHIpe3JldHVybigwLHIucmVzb2x2ZSkoaSl9KSxsPVtdfX0sZigpKSxjKXt2YXIgZD1yLmFwcGx5KG4sZSk7cmV0dXJuIHUmJnUoZCksaShkKX1sLnB1c2goe3Jlc29sdmU6aSxyZWplY3Q6dH0pfSl9O3JldHVybiBkLmNhbmNlbD1mdW5jdGlvbihyKXt2b2lkIDAhPT1vJiZjbGVhclRpbWVvdXQobyksbC5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybigwLGUucmVqZWN0KShyKX0pLGw9W119LGR9ZXhwb3J0e3IgYXMgZGVib3VuY2V9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge2FkYXB0ZXJGYWN0b3J5fSBmcm9tICcuL2FkYXB0ZXJfZmFjdG9yeS5qcyc7XG5cbmNvbnN0IGFkYXB0ZXIgPVxuICBhZGFwdGVyRmFjdG9yeSh7d2luZG93OiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IHdpbmRvd30pO1xuZXhwb3J0IGRlZmF1bHQgYWRhcHRlcjtcbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbiAgLy8gQnJvd3NlciBzaGltcy5cbmltcG9ydCAqIGFzIGNocm9tZVNoaW0gZnJvbSAnLi9jaHJvbWUvY2hyb21lX3NoaW0nO1xuaW1wb3J0ICogYXMgZmlyZWZveFNoaW0gZnJvbSAnLi9maXJlZm94L2ZpcmVmb3hfc2hpbSc7XG5pbXBvcnQgKiBhcyBzYWZhcmlTaGltIGZyb20gJy4vc2FmYXJpL3NhZmFyaV9zaGltJztcbmltcG9ydCAqIGFzIGNvbW1vblNoaW0gZnJvbSAnLi9jb21tb25fc2hpbSc7XG5pbXBvcnQgKiBhcyBzZHAgZnJvbSAnc2RwJztcblxuLy8gU2hpbW1pbmcgc3RhcnRzIGhlcmUuXG5leHBvcnQgZnVuY3Rpb24gYWRhcHRlckZhY3Rvcnkoe3dpbmRvd30gPSB7fSwgb3B0aW9ucyA9IHtcbiAgc2hpbUNocm9tZTogdHJ1ZSxcbiAgc2hpbUZpcmVmb3g6IHRydWUsXG4gIHNoaW1TYWZhcmk6IHRydWUsXG59KSB7XG4gIC8vIFV0aWxzLlxuICBjb25zdCBsb2dnaW5nID0gdXRpbHMubG9nO1xuICBjb25zdCBicm93c2VyRGV0YWlscyA9IHV0aWxzLmRldGVjdEJyb3dzZXIod2luZG93KTtcblxuICBjb25zdCBhZGFwdGVyID0ge1xuICAgIGJyb3dzZXJEZXRhaWxzLFxuICAgIGNvbW1vblNoaW0sXG4gICAgZXh0cmFjdFZlcnNpb246IHV0aWxzLmV4dHJhY3RWZXJzaW9uLFxuICAgIGRpc2FibGVMb2c6IHV0aWxzLmRpc2FibGVMb2csXG4gICAgZGlzYWJsZVdhcm5pbmdzOiB1dGlscy5kaXNhYmxlV2FybmluZ3MsXG4gICAgLy8gRXhwb3NlIHNkcCBhcyBhIGNvbnZlbmllbmNlLiBGb3IgcHJvZHVjdGlvbiBhcHBzIGluY2x1ZGUgZGlyZWN0bHkuXG4gICAgc2RwLFxuICB9O1xuXG4gIC8vIFNoaW0gYnJvd3NlciBpZiBmb3VuZC5cbiAgc3dpdGNoIChicm93c2VyRGV0YWlscy5icm93c2VyKSB7XG4gICAgY2FzZSAnY2hyb21lJzpcbiAgICAgIGlmICghY2hyb21lU2hpbSB8fCAhY2hyb21lU2hpbS5zaGltUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgICAgICAhb3B0aW9ucy5zaGltQ2hyb21lKSB7XG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICBsb2dnaW5nKCdDaHJvbWUgc2hpbSBjYW4gbm90IGRldGVybWluZSB2ZXJzaW9uLCBub3Qgc2hpbW1pbmcuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBjaHJvbWUuJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IGNocm9tZVNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltUGVlckNvbm5lY3Rpb24uXG4gICAgICBjb21tb25TaGltLnNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuXG4gICAgICBjaHJvbWVTaGltLnNoaW1HZXRVc2VyTWVkaWEod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1NZWRpYVN0cmVhbSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY2hyb21lU2hpbS5zaGltT25UcmFjayh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1HZXRTZW5kZXJzV2l0aER0bWYod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1HZXRTdGF0cyh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLmZpeE5lZ290aWF0aW9uTmVlZGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuXG4gICAgICBjb21tb25TaGltLnNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0ucmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ZpcmVmb3gnOlxuICAgICAgaWYgKCFmaXJlZm94U2hpbSB8fCAhZmlyZWZveFNoaW0uc2hpbVBlZXJDb25uZWN0aW9uIHx8XG4gICAgICAgICAgIW9wdGlvbnMuc2hpbUZpcmVmb3gpIHtcbiAgICAgICAgbG9nZ2luZygnRmlyZWZveCBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIGZpcmVmb3guJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IGZpcmVmb3hTaGltO1xuXG4gICAgICAvLyBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgc2hpbVBlZXJDb25uZWN0aW9uLlxuICAgICAgY29tbW9uU2hpbS5zaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcblxuICAgICAgZmlyZWZveFNoaW0uc2hpbUdldFVzZXJNZWRpYSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1PblRyYWNrKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVJlbW92ZVN0cmVhbSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1TZW5kZXJHZXRTdGF0cyh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1SZWNlaXZlckdldFN0YXRzKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVJUQ0RhdGFDaGFubmVsKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbUFkZFRyYW5zY2VpdmVyKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbUdldFBhcmFtZXRlcnMod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltQ3JlYXRlT2ZmZXIod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltQ3JlYXRlQW5zd2VyKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuXG4gICAgICBjb21tb25TaGltLnNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NhZmFyaSc6XG4gICAgICBpZiAoIXNhZmFyaVNoaW0gfHwgIW9wdGlvbnMuc2hpbVNhZmFyaSkge1xuICAgICAgICBsb2dnaW5nKCdTYWZhcmkgc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBzYWZhcmkuJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IHNhZmFyaVNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltQ2FsbGJhY2tBUEkuXG4gICAgICBjb21tb25TaGltLnNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuXG4gICAgICBzYWZhcmlTaGltLnNoaW1SVENJY2VTZXJ2ZXJVcmxzKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltQ3JlYXRlT2ZmZXJMZWdhY3kod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1DYWxsYmFja3NBUEkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1Mb2NhbFN0cmVhbXNBUEkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1SZW1vdGVTdHJlYW1zQVBJKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltR2V0VXNlck1lZGlhKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltQXVkaW9Db250ZXh0KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuXG4gICAgICBjb21tb25TaGltLnNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0ucmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsb2dnaW5nKCdVbnN1cHBvcnRlZCBicm93c2VyIScpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gYWRhcHRlcjtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuIC8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5leHBvcnQge3NoaW1HZXRVc2VyTWVkaWF9IGZyb20gJy4vZ2V0dXNlcm1lZGlhJztcbmV4cG9ydCB7c2hpbUdldERpc3BsYXlNZWRpYX0gZnJvbSAnLi9nZXRkaXNwbGF5bWVkaWEnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbU1lZGlhU3RyZWFtKHdpbmRvdykge1xuICB3aW5kb3cuTWVkaWFTdHJlYW0gPSB3aW5kb3cuTWVkaWFTdHJlYW0gfHwgd2luZG93LndlYmtpdE1lZGlhU3RyZWFtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbU9uVHJhY2sod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnb250cmFjaycgaW5cbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbnRyYWNrJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb250cmFjaztcbiAgICAgIH0sXG4gICAgICBzZXQoZikge1xuICAgICAgICBpZiAodGhpcy5fb250cmFjaykge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayA9IGYpO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPVxuICAgICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPVxuICAgICAgZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fb250cmFja3BvbHkpIHtcbiAgICAgICAgICB0aGlzLl9vbnRyYWNrcG9seSA9IChlKSA9PiB7XG4gICAgICAgICAgICAvLyBvbmFkZHN0cmVhbSBkb2VzIG5vdCBmaXJlIHdoZW4gYSB0cmFjayBpcyBhZGRlZCB0byBhbiBleGlzdGluZ1xuICAgICAgICAgICAgLy8gc3RyZWFtLiBCdXQgc3RyZWFtLm9uYWRkdHJhY2sgaXMgaW1wbGVtZW50ZWQgc28gd2UgdXNlIHRoYXQuXG4gICAgICAgICAgICBlLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRlID0+IHtcbiAgICAgICAgICAgICAgbGV0IHJlY2VpdmVyO1xuICAgICAgICAgICAgICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9IHRoaXMuZ2V0UmVjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAgIC5maW5kKHIgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSB0ZS50cmFjay5pZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB7dHJhY2s6IHRlLnRyYWNrfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgICBldmVudC50cmFjayA9IHRlLnRyYWNrO1xuICAgICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgICBldmVudC50cmFuc2NlaXZlciA9IHtyZWNlaXZlcn07XG4gICAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAgICAgbGV0IHJlY2VpdmVyO1xuICAgICAgICAgICAgICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9IHRoaXMuZ2V0UmVjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAgIC5maW5kKHIgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSB0cmFjay5pZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB7dHJhY2t9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgICBldmVudC50cmFjayA9IHRyYWNrO1xuICAgICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgICBldmVudC50cmFuc2NlaXZlciA9IHtyZWNlaXZlcn07XG4gICAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29udHJhY2twb2x5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGV2ZW4gaWYgUlRDUnRwVHJhbnNjZWl2ZXIgaXMgaW4gd2luZG93LCBpdCBpcyBvbmx5IHVzZWQgYW5kXG4gICAgLy8gZW1pdHRlZCBpbiB1bmlmaWVkLXBsYW4uIFVuZm9ydHVuYXRlbHkgdGhpcyBtZWFucyB3ZSBuZWVkXG4gICAgLy8gdG8gdW5jb25kaXRpb25hbGx5IHdyYXAgdGhlIGV2ZW50LlxuICAgIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XG4gICAgICBpZiAoIWUudHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICd0cmFuc2NlaXZlcicsXG4gICAgICAgICAge3ZhbHVlOiB7cmVjZWl2ZXI6IGUucmVjZWl2ZXJ9fSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUdldFNlbmRlcnNXaXRoRHRtZih3aW5kb3cpIHtcbiAgLy8gT3ZlcnJpZGVzIGFkZFRyYWNrL3JlbW92ZVRyYWNrLCBkZXBlbmRzIG9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrLlxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICAhKCdnZXRTZW5kZXJzJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSAmJlxuICAgICAgJ2NyZWF0ZURUTUZTZW5kZXInIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICBjb25zdCBzaGltU2VuZGVyV2l0aER0bWYgPSBmdW5jdGlvbihwYywgdHJhY2spIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYWNrLFxuICAgICAgICBnZXQgZHRtZigpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZHRtZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgICB0aGlzLl9kdG1mID0gcGMuY3JlYXRlRFRNRlNlbmRlcih0cmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9kdG1mID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2R0bWY7XG4gICAgICAgIH0sXG4gICAgICAgIF9wYzogcGNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIGF1Z21lbnQgYWRkVHJhY2sgd2hlbiBnZXRTZW5kZXJzIGlzIG5vdCBhdmFpbGFibGUuXG4gICAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZGVycy5zbGljZSgpOyAvLyByZXR1cm4gYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBzdGF0ZS5cbiAgICAgIH07XG4gICAgICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9XG4gICAgICAgIGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICAgICAgICBsZXQgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgICAgICAgIHNlbmRlciA9IHNoaW1TZW5kZXJXaXRoRHRtZih0aGlzLCB0cmFjayk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2VuZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICAgICAgfTtcblxuICAgICAgY29uc3Qgb3JpZ1JlbW92ZVRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjaztcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPVxuICAgICAgICBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICAgICAgICBvcmlnUmVtb3ZlVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKTtcbiAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fc2VuZGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgIHRoaXMuX3NlbmRlcnMucHVzaChzaGltU2VuZGVyV2l0aER0bWYodGhpcywgdHJhY2spKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBvcmlnUmVtb3ZlU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPVxuICAgICAgZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgICAgb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG5cbiAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuX3NlbmRlcnMuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgICAgICBpZiAoc2VuZGVyKSB7IC8vIHJlbW92ZSBzZW5kZXJcbiAgICAgICAgICAgIHRoaXMuX3NlbmRlcnMuc3BsaWNlKHRoaXMuX3NlbmRlcnMuaW5kZXhPZihzZW5kZXIpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiZcbiAgICAgICAgICAgICAnZ2V0U2VuZGVycycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlICYmXG4gICAgICAgICAgICAgd2luZG93LlJUQ1J0cFNlbmRlciAmJlxuICAgICAgICAgICAgICEoJ2R0bWYnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICBjb25zdCBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgc2VuZGVycy5mb3JFYWNoKHNlbmRlciA9PiBzZW5kZXIuX3BjID0gdGhpcyk7XG4gICAgICByZXR1cm4gc2VuZGVycztcbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLCAnZHRtZicsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHRoaXMuX2R0bWYgPSB0aGlzLl9wYy5jcmVhdGVEVE1GU2VuZGVyKHRoaXMudHJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kdG1mID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2R0bWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBvcmlnR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgY29uc3QgW3NlbGVjdG9yLCBvblN1Y2MsIG9uRXJyXSA9IGFyZ3VtZW50cztcblxuICAgIC8vIElmIHNlbGVjdG9yIGlzIGEgZnVuY3Rpb24gdGhlbiB3ZSBhcmUgaW4gdGhlIG9sZCBzdHlsZSBzdGF0cyBzbyBqdXN0XG4gICAgLy8gcGFzcyBiYWNrIHRoZSBvcmlnaW5hbCBnZXRTdGF0cyBmb3JtYXQgdG8gYXZvaWQgYnJlYWtpbmcgb2xkIHVzZXJzLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHNwZWMtc3R5bGUgZ2V0U3RhdHMgaXMgc3VwcG9ydGVkLCByZXR1cm4gdGhvc2Ugd2hlbiBjYWxsZWQgd2l0aFxuICAgIC8vIGVpdGhlciBubyBhcmd1bWVudHMgb3IgdGhlIHNlbGVjdG9yIGFyZ3VtZW50IGlzIG51bGwuXG4gICAgaWYgKG9yaWdHZXRTdGF0cy5sZW5ndGggPT09IDAgJiYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgdHlwZW9mIHNlbGVjdG9yICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgcmV0dXJuIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBbXSk7XG4gICAgfVxuXG4gICAgY29uc3QgZml4Q2hyb21lU3RhdHNfID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IHN0YW5kYXJkUmVwb3J0ID0ge307XG4gICAgICBjb25zdCByZXBvcnRzID0gcmVzcG9uc2UucmVzdWx0KCk7XG4gICAgICByZXBvcnRzLmZvckVhY2gocmVwb3J0ID0+IHtcbiAgICAgICAgY29uc3Qgc3RhbmRhcmRTdGF0cyA9IHtcbiAgICAgICAgICBpZDogcmVwb3J0LmlkLFxuICAgICAgICAgIHRpbWVzdGFtcDogcmVwb3J0LnRpbWVzdGFtcCxcbiAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICBsb2NhbGNhbmRpZGF0ZTogJ2xvY2FsLWNhbmRpZGF0ZScsXG4gICAgICAgICAgICByZW1vdGVjYW5kaWRhdGU6ICdyZW1vdGUtY2FuZGlkYXRlJ1xuICAgICAgICAgIH1bcmVwb3J0LnR5cGVdIHx8IHJlcG9ydC50eXBlXG4gICAgICAgIH07XG4gICAgICAgIHJlcG9ydC5uYW1lcygpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgc3RhbmRhcmRTdGF0c1tuYW1lXSA9IHJlcG9ydC5zdGF0KG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhbmRhcmRSZXBvcnRbc3RhbmRhcmRTdGF0cy5pZF0gPSBzdGFuZGFyZFN0YXRzO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzdGFuZGFyZFJlcG9ydDtcbiAgICB9O1xuXG4gICAgLy8gc2hpbSBnZXRTdGF0cyB3aXRoIG1hcGxpa2Ugc3VwcG9ydFxuICAgIGNvbnN0IG1ha2VNYXBTdGF0cyA9IGZ1bmN0aW9uKHN0YXRzKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcChPYmplY3Qua2V5cyhzdGF0cykubWFwKGtleSA9PiBba2V5LCBzdGF0c1trZXldXSkpO1xuICAgIH07XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBjb25zdCBzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXyA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIG9uU3VjYyhtYWtlTWFwU3RhdHMoZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSkpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBbc3VjY2Vzc0NhbGxiYWNrV3JhcHBlcl8sXG4gICAgICAgIHNlbGVjdG9yXSk7XG4gICAgfVxuXG4gICAgLy8gcHJvbWlzZS1zdXBwb3J0XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBbXG4gICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgcmVzb2x2ZShtYWtlTWFwU3RhdHMoZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSkpO1xuICAgICAgICB9LCByZWplY3RdKTtcbiAgICB9KS50aGVuKG9uU3VjYywgb25FcnIpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJlxuICAgICAgd2luZG93LlJUQ1J0cFNlbmRlciAmJiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBzZW5kZXIgc3RhdHMuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpKSB7XG4gICAgY29uc3Qgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gICAgaWYgKG9yaWdHZXRTZW5kZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgICBjb25zdCBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgaWYgKG9yaWdBZGRUcmFjaykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgICAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgc2VuZGVyLl9wYyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9O1xuICAgIH1cbiAgICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgICAgY29uc3Qgc2VuZGVyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4ocmVzdWx0ID0+XG4gICAgICAgIC8qIE5vdGU6IHRoaXMgd2lsbCBpbmNsdWRlIHN0YXRzIG9mIGFsbCBzZW5kZXJzIHRoYXRcbiAgICAgICAgICogICBzZW5kIGEgdHJhY2sgd2l0aCB0aGUgc2FtZSBpZCBhcyBzZW5kZXIudHJhY2sgYXNcbiAgICAgICAgICogICBpdCBpcyBub3QgcG9zc2libGUgdG8gaWRlbnRpZnkgdGhlIFJUQ1J0cFNlbmRlci5cbiAgICAgICAgICovXG4gICAgICAgIHV0aWxzLmZpbHRlclN0YXRzKHJlc3VsdCwgc2VuZGVyLnRyYWNrLCB0cnVlKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHNoaW0gcmVjZWl2ZXIgc3RhdHMuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0UmVjZWl2ZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnM7XG4gICAgaWYgKG9yaWdHZXRSZWNlaXZlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xuICAgICAgICAgIGNvbnN0IHJlY2VpdmVycyA9IG9yaWdHZXRSZWNlaXZlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgICAgIHJlY2VpdmVycy5mb3JFYWNoKHJlY2VpdmVyID0+IHJlY2VpdmVyLl9wYyA9IHRoaXMpO1xuICAgICAgICAgIHJldHVybiByZWNlaXZlcnM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XG4gICAgICBlLnJlY2VpdmVyLl9wYyA9IGUuc3JjRWxlbWVudDtcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICAgIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICAgIGNvbnN0IHJlY2VpdmVyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4ocmVzdWx0ID0+XG4gICAgICAgIHV0aWxzLmZpbHRlclN0YXRzKHJlc3VsdCwgcmVjZWl2ZXIudHJhY2ssIGZhbHNlKSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUgJiZcbiAgICAgICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIFJUQ1BlZXJDb25uZWN0aW9uLmdldFN0YXRzKHRyYWNrKS5cbiAgY29uc3Qgb3JpZ0dldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJlxuICAgICAgICBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgY29uc3QgdHJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgICBsZXQgc2VuZGVyO1xuICAgICAgbGV0IHJlY2VpdmVyO1xuICAgICAgbGV0IGVycjtcbiAgICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2gocyA9PiB7XG4gICAgICAgIGlmIChzLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGlmIChzZW5kZXIpIHtcbiAgICAgICAgICAgIGVyciA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRlciA9IHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ2V0UmVjZWl2ZXJzKCkuZm9yRWFjaChyID0+IHtcbiAgICAgICAgaWYgKHIudHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgaWYgKHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBlcnIgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNlaXZlciA9IHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByLnRyYWNrID09PSB0cmFjaztcbiAgICAgIH0pO1xuICAgICAgaWYgKGVyciB8fCAoc2VuZGVyICYmIHJlY2VpdmVyKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgICAnVGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgc2VuZGVyIG9yIHJlY2VpdmVyIGZvciB0aGUgdHJhY2suJyxcbiAgICAgICAgICAnSW52YWxpZEFjY2Vzc0Vycm9yJykpO1xuICAgICAgfSBlbHNlIGlmIChzZW5kZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgfSBlbHNlIGlmIChyZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAnVGhlcmUgaXMgbm8gc2VuZGVyIG9yIHJlY2VpdmVyIGZvciB0aGUgdHJhY2suJyxcbiAgICAgICAgJ0ludmFsaWRBY2Nlc3NFcnJvcicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlKHdpbmRvdykge1xuICAvLyBzaGltIGFkZFRyYWNrL3JlbW92ZVRyYWNrIHdpdGggbmF0aXZlIHZhcmlhbnRzIGluIG9yZGVyIHRvIG1ha2VcbiAgLy8gdGhlIGludGVyYWN0aW9ucyB3aXRoIGxlZ2FjeSBnZXRMb2NhbFN0cmVhbXMgYmVoYXZlIGFzIGluIG90aGVyIGJyb3dzZXJzLlxuICAvLyBLZWVwcyBhIG1hcHBpbmcgc3RyZWFtLmlkID0+IFtzdHJlYW0sIHJ0cHNlbmRlcnMuLi5dXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID1cbiAgICBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zKVxuICAgICAgICAubWFwKHN0cmVhbUlkID0+IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdWzBdKTtcbiAgICB9O1xuXG4gIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPVxuICAgIGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICAgIGlmICghc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuXG4gICAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICghdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdKSB7XG4gICAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSA9IFtzdHJlYW0sIHNlbmRlcl07XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXS5pbmRleE9mKHNlbmRlcikgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXS5wdXNoKHNlbmRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VuZGVyO1xuICAgIH07XG5cbiAgY29uc3Qgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcblxuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJyxcbiAgICAgICAgICAgICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBleGlzdGluZ1NlbmRlcnMgPSB0aGlzLmdldFNlbmRlcnMoKTtcbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgY29uc3QgbmV3U2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpXG4gICAgICAuZmlsdGVyKG5ld1NlbmRlciA9PiBleGlzdGluZ1NlbmRlcnMuaW5kZXhPZihuZXdTZW5kZXIpID09PSAtMSk7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbV0uY29uY2F0KG5ld1NlbmRlcnMpO1xuICB9O1xuXG4gIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPVxuICAgIGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgICAgZGVsZXRlIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXTtcbiAgICAgIHJldHVybiBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICBjb25zdCBvcmlnUmVtb3ZlVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID1cbiAgICBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgICAgaWYgKHNlbmRlcikge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zKS5mb3JFYWNoKHN0cmVhbUlkID0+IHtcbiAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5pbmRleE9mKHNlbmRlcik7XG4gICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnUmVtb3ZlVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzaGltIGFkZFRyYWNrIGFuZCByZW1vdmVUcmFjay5cbiAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgJiZcbiAgICAgIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjUpIHtcbiAgICByZXR1cm4gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlKHdpbmRvdyk7XG4gIH1cblxuICAvLyBhbHNvIHNoaW0gcGMuZ2V0TG9jYWxTdHJlYW1zIHdoZW4gYWRkVHJhY2sgaXMgc2hpbW1lZFxuICAvLyB0byByZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmVhbXMuXG4gIGNvbnN0IG9yaWdHZXRMb2NhbFN0cmVhbXMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlXG4gICAgICAuZ2V0TG9jYWxTdHJlYW1zO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9XG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgICAgY29uc3QgbmF0aXZlU3RyZWFtcyA9IG9yaWdHZXRMb2NhbFN0cmVhbXMuYXBwbHkodGhpcyk7XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgICAgcmV0dXJuIG5hdGl2ZVN0cmVhbXMubWFwKHN0cmVhbSA9PiB0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKTtcbiAgICB9O1xuXG4gIGNvbnN0IG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcblxuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJyxcbiAgICAgICAgICAgICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBZGQgaWRlbnRpdHkgbWFwcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBhZGRUcmFjay5cbiAgICAvLyBVbmxlc3MgdGhpcyBpcyBiZWluZyB1c2VkIHdpdGggYSBzdHJlYW0gZnJvbSBhZGRUcmFjay5cbiAgICBpZiAoIXRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pIHtcbiAgICAgIGNvbnN0IG5ld1N0cmVhbSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oc3RyZWFtLmdldFRyYWNrcygpKTtcbiAgICAgIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA9IG5ld1N0cmVhbTtcbiAgICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zW25ld1N0cmVhbS5pZF0gPSBzdHJlYW07XG4gICAgICBzdHJlYW0gPSBuZXdTdHJlYW07XG4gICAgfVxuICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuICB9O1xuXG4gIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPVxuICAgIGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcblxuICAgICAgb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBbKHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSB8fCBzdHJlYW0pXSk7XG4gICAgICBkZWxldGUgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbKHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA/XG4gICAgICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdLmlkIDogc3RyZWFtLmlkKV07XG4gICAgICBkZWxldGUgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgIH07XG5cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9XG4gICAgZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgICAgJ1RoZSBSVENQZWVyQ29ubmVjdGlvblxcJ3Mgc2lnbmFsaW5nU3RhdGUgaXMgXFwnY2xvc2VkXFwnLicsXG4gICAgICAgICAgJ0ludmFsaWRTdGF0ZUVycm9yJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJlYW1zID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKHN0cmVhbXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgICAgIXN0cmVhbXNbMF0uZ2V0VHJhY2tzKCkuZmluZCh0ID0+IHQgPT09IHRyYWNrKSkge1xuICAgICAgICAvLyB0aGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0IGJ1dCBhbGwgd2UgY2FuIG1hbmFnZSB3aXRob3V0XG4gICAgICAgIC8vIFtbYXNzb2NpYXRlZCBNZWRpYVN0cmVhbXNdXSBpbnRlcm5hbCBzbG90LlxuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAgICdUaGUgYWRhcHRlci5qcyBhZGRUcmFjayBwb2x5ZmlsbCBvbmx5IHN1cHBvcnRzIGEgc2luZ2xlICcgK1xuICAgICAgICAgICcgc3RyZWFtIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHRyYWNrLicsXG4gICAgICAgICAgJ05vdFN1cHBvcnRlZEVycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJyxcbiAgICAgICAgICAgICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgICAgY29uc3Qgb2xkU3RyZWFtID0gdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgICAgaWYgKG9sZFN0cmVhbSkge1xuICAgICAgICAvLyB0aGlzIGlzIHVzaW5nIG9kZCBDaHJvbWUgYmVoYXZpb3VyLCB1c2Ugd2l0aCBjYXV0aW9uOlxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NzgxNVxuICAgICAgICAvLyBOb3RlOiB3ZSByZWx5IG9uIHRoZSBoaWdoLWxldmVsIGFkZFRyYWNrL2R0bWYgc2hpbSB0b1xuICAgICAgICAvLyBjcmVhdGUgdGhlIHNlbmRlciB3aXRoIGEgZHRtZiBzZW5kZXIuXG4gICAgICAgIG9sZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cbiAgICAgICAgLy8gVHJpZ2dlciBPTk4gYXN5bmMuXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld1N0cmVhbSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oW3RyYWNrXSk7XG4gICAgICAgIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA9IG5ld1N0cmVhbTtcbiAgICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbbmV3U3RyZWFtLmlkXSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy5hZGRTdHJlYW0obmV3U3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgIH07XG5cbiAgLy8gcmVwbGFjZSB0aGUgaW50ZXJuYWwgc3RyZWFtIGlkIHdpdGggdGhlIGV4dGVybmFsIG9uZSBhbmRcbiAgLy8gdmljZSB2ZXJzYS5cbiAgZnVuY3Rpb24gcmVwbGFjZUludGVybmFsU3RyZWFtSWQocGMsIGRlc2NyaXB0aW9uKSB7XG4gICAgbGV0IHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcbiAgICBPYmplY3Qua2V5cyhwYy5fcmV2ZXJzZVN0cmVhbXMgfHwgW10pLmZvckVhY2goaW50ZXJuYWxJZCA9PiB7XG4gICAgICBjb25zdCBleHRlcm5hbFN0cmVhbSA9IHBjLl9yZXZlcnNlU3RyZWFtc1tpbnRlcm5hbElkXTtcbiAgICAgIGNvbnN0IGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChpbnRlcm5hbFN0cmVhbS5pZCwgJ2cnKSxcbiAgICAgICAgICBleHRlcm5hbFN0cmVhbS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgIHNkcFxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlcGxhY2VFeHRlcm5hbFN0cmVhbUlkKHBjLCBkZXNjcmlwdGlvbikge1xuICAgIGxldCBzZHAgPSBkZXNjcmlwdGlvbi5zZHA7XG4gICAgT2JqZWN0LmtleXMocGMuX3JldmVyc2VTdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGludGVybmFsSWQgPT4ge1xuICAgICAgY29uc3QgZXh0ZXJuYWxTdHJlYW0gPSBwYy5fcmV2ZXJzZVN0cmVhbXNbaW50ZXJuYWxJZF07XG4gICAgICBjb25zdCBpbnRlcm5hbFN0cmVhbSA9IHBjLl9zdHJlYW1zW2V4dGVybmFsU3RyZWFtLmlkXTtcbiAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKG5ldyBSZWdFeHAoZXh0ZXJuYWxTdHJlYW0uaWQsICdnJyksXG4gICAgICAgICAgaW50ZXJuYWxTdHJlYW0uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICBzZHBcbiAgICB9KTtcbiAgfVxuICBbJ2NyZWF0ZU9mZmVyJywgJ2NyZWF0ZUFuc3dlciddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtbbWV0aG9kXSgpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBjb25zdCBpc0xlZ2FjeUNhbGwgPSBhcmd1bWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmIChpc0xlZ2FjeUNhbGwpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgKGRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXNjID0gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgYXJnc1swXS5hcHBseShudWxsLCBbZGVzY10pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgYXJnc1sxXS5hcHBseShudWxsLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGFyZ3VtZW50c1syXVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgLnRoZW4oZGVzY3JpcHRpb24gPT4gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pKTtcbiAgICB9fTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgfSk7XG5cbiAgY29uc3Qgb3JpZ1NldExvY2FsRGVzY3JpcHRpb24gPVxuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPVxuICAgIGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGggfHwgIWFyZ3VtZW50c1swXS50eXBlKSB7XG4gICAgICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgYXJndW1lbnRzWzBdID0gcmVwbGFjZUV4dGVybmFsU3RyZWFtSWQodGhpcywgYXJndW1lbnRzWzBdKTtcbiAgICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgLy8gVE9ETzogbWFuZ2xlIGdldFN0YXRzOiBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXN0YXRzLyNkb20tcnRjbWVkaWFzdHJlYW1zdGF0cy1zdHJlYW1pZGVudGlmaWVyXG5cbiAgY29uc3Qgb3JpZ0xvY2FsRGVzY3JpcHRpb24gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ2xvY2FsRGVzY3JpcHRpb24nKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsXG4gICAgICAnbG9jYWxEZXNjcmlwdGlvbicsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gb3JpZ0xvY2FsRGVzY3JpcHRpb24uZ2V0LmFwcGx5KHRoaXMpO1xuICAgICAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID1cbiAgICBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICAgIGlmICh0aGlzLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAgICdUaGUgUlRDUGVlckNvbm5lY3Rpb25cXCdzIHNpZ25hbGluZ1N0YXRlIGlzIFxcJ2Nsb3NlZFxcJy4nLFxuICAgICAgICAgICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgICAgfVxuICAgICAgLy8gV2UgY2FuIG5vdCB5ZXQgY2hlY2sgZm9yIHNlbmRlciBpbnN0YW5jZW9mIFJUQ1J0cFNlbmRlclxuICAgICAgLy8gc2luY2Ugd2Ugc2hpbSBSVFBTZW5kZXIuIFNvIHdlIGNoZWNrIGlmIHNlbmRlci5fcGMgaXMgc2V0LlxuICAgICAgaWYgKCFzZW5kZXIuX3BjKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0FyZ3VtZW50IDEgb2YgUlRDUGVlckNvbm5lY3Rpb24ucmVtb3ZlVHJhY2sgJyArXG4gICAgICAgICAgICAnZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSBSVENSdHBTZW5kZXIuJywgJ1R5cGVFcnJvcicpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNMb2NhbCA9IHNlbmRlci5fcGMgPT09IHRoaXM7XG4gICAgICBpZiAoIWlzTG9jYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignU2VuZGVyIHdhcyBub3QgY3JlYXRlZCBieSB0aGlzIGNvbm5lY3Rpb24uJyxcbiAgICAgICAgICAgICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2VhcmNoIGZvciB0aGUgbmF0aXZlIHN0cmVhbSB0aGUgc2VuZGVycyB0cmFjayBiZWxvbmdzIHRvLlxuICAgICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgICBsZXQgc3RyZWFtO1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fc3RyZWFtcykuZm9yRWFjaChzdHJlYW1pZCA9PiB7XG4gICAgICAgIGNvbnN0IGhhc1RyYWNrID0gdGhpcy5fc3RyZWFtc1tzdHJlYW1pZF0uZ2V0VHJhY2tzKClcbiAgICAgICAgICAuZmluZCh0cmFjayA9PiBzZW5kZXIudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgICAgaWYgKGhhc1RyYWNrKSB7XG4gICAgICAgICAgc3RyZWFtID0gdGhpcy5fc3RyZWFtc1tzdHJlYW1pZF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCB0cmFjayBvZiB0aGUgc3RyZWFtLCByZW1vdmUgdGhlIHN0cmVhbS4gVGhpc1xuICAgICAgICAgIC8vIHRha2VzIGNhcmUgb2YgYW55IHNoaW1tZWQgX3NlbmRlcnMuXG4gICAgICAgICAgdGhpcy5yZW1vdmVTdHJlYW0odGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmVseWluZyBvbiB0aGUgc2FtZSBvZGQgY2hyb21lIGJlaGF2aW91ciBhcyBhYm92ZS5cbiAgICAgICAgICBzdHJlYW0ucmVtb3ZlVHJhY2soc2VuZGVyLnRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCduZWdvdGlhdGlvbm5lZWRlZCcpKTtcbiAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uO1xuICB9XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBpbXBsaWNpdCBjcmVhdGlvbiBvZiBSVENTZXNzaW9uRGVzY3JpcHRpb24vUlRDSWNlQ2FuZGlkYXRlXG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMpIHtcbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ11cbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtbbWV0aG9kXSgpIHtcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAoKG1ldGhvZCA9PT0gJ2FkZEljZUNhbmRpZGF0ZScpID9cbiAgICAgICAgICAgICAgICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIDpcbiAgICAgICAgICAgICAgICB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH19O1xuICAgICAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICAgICAgICB9KTtcbiAgfVxufVxuXG4vLyBBdHRlbXB0IHRvIGZpeCBPTk4gaW4gcGxhbi1iIG1vZGUuXG5leHBvcnQgZnVuY3Rpb24gZml4TmVnb3RpYXRpb25OZWVkZWQod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICduZWdvdGlhdGlvbm5lZWRlZCcsIGUgPT4ge1xuICAgIGNvbnN0IHBjID0gZS50YXJnZXQ7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA3MiB8fCAocGMuZ2V0Q29uZmlndXJhdGlvbiAmJlxuICAgICAgICBwYy5nZXRDb25maWd1cmF0aW9uKCkuc2RwU2VtYW50aWNzID09PSAncGxhbi1iJykpIHtcbiAgICAgIGlmIChwYy5zaWduYWxpbmdTdGF0ZSAhPT0gJ3N0YWJsZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxOCBUaGUgYWRhcHRlci5qcyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcbmV4cG9ydCBmdW5jdGlvbiBzaGltR2V0RGlzcGxheU1lZGlhKHdpbmRvdywgZ2V0U291cmNlSWQpIHtcbiAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmXG4gICAgJ2dldERpc3BsYXlNZWRpYScgaW4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGdldFNvdXJjZUlkIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aFxuICAvLyB0aGUgc291cmNlSWQgb2YgdGhlIHNjcmVlbi93aW5kb3cvdGFiIHRvIGJlIHNoYXJlZC5cbiAgaWYgKHR5cGVvZiBnZXRTb3VyY2VJZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ3NoaW1HZXREaXNwbGF5TWVkaWE6IGdldFNvdXJjZUlkIGFyZ3VtZW50IGlzIG5vdCAnICtcbiAgICAgICAgJ2EgZnVuY3Rpb24nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhID1cbiAgICBmdW5jdGlvbiBnZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpIHtcbiAgICAgIHJldHVybiBnZXRTb3VyY2VJZChjb25zdHJhaW50cylcbiAgICAgICAgLnRoZW4oc291cmNlSWQgPT4ge1xuICAgICAgICAgIGNvbnN0IHdpZHRoU3BlY2lmaWVkID0gY29uc3RyYWludHMudmlkZW8gJiYgY29uc3RyYWludHMudmlkZW8ud2lkdGg7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0U3BlY2lmaWVkID0gY29uc3RyYWludHMudmlkZW8gJiZcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLmhlaWdodDtcbiAgICAgICAgICBjb25zdCBmcmFtZVJhdGVTcGVjaWZpZWQgPSBjb25zdHJhaW50cy52aWRlbyAmJlxuICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8uZnJhbWVSYXRlO1xuICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0ge1xuICAgICAgICAgICAgbWFuZGF0b3J5OiB7XG4gICAgICAgICAgICAgIGNocm9tZU1lZGlhU291cmNlOiAnZGVza3RvcCcsXG4gICAgICAgICAgICAgIGNocm9tZU1lZGlhU291cmNlSWQ6IHNvdXJjZUlkLFxuICAgICAgICAgICAgICBtYXhGcmFtZVJhdGU6IGZyYW1lUmF0ZVNwZWNpZmllZCB8fCAzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAod2lkdGhTcGVjaWZpZWQpIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLm1hbmRhdG9yeS5tYXhXaWR0aCA9IHdpZHRoU3BlY2lmaWVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVpZ2h0U3BlY2lmaWVkKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlby5tYW5kYXRvcnkubWF4SGVpZ2h0ID0gaGVpZ2h0U3BlY2lmaWVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5jb25zdCBsb2dnaW5nID0gdXRpbHMubG9nO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuXG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNvbnN0cmFpbnRzVG9DaHJvbWVfID0gZnVuY3Rpb24oYykge1xuICAgIGlmICh0eXBlb2YgYyAhPT0gJ29iamVjdCcgfHwgYy5tYW5kYXRvcnkgfHwgYy5vcHRpb25hbCkge1xuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGNvbnN0IGNjID0ge307XG4gICAgT2JqZWN0LmtleXMoYykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlcXVpcmUnIHx8IGtleSA9PT0gJ2FkdmFuY2VkJyB8fCBrZXkgPT09ICdtZWRpYVNvdXJjZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgciA9ICh0eXBlb2YgY1trZXldID09PSAnb2JqZWN0JykgPyBjW2tleV0gOiB7aWRlYWw6IGNba2V5XX07XG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByLm1pbiA9IHIubWF4ID0gci5leGFjdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZG5hbWVfID0gZnVuY3Rpb24ocHJlZml4LCBuYW1lKSB7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChuYW1lID09PSAnZGV2aWNlSWQnKSA/ICdzb3VyY2VJZCcgOiBuYW1lO1xuICAgICAgfTtcbiAgICAgIGlmIChyLmlkZWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2Mub3B0aW9uYWwgPSBjYy5vcHRpb25hbCB8fCBbXTtcbiAgICAgICAgbGV0IG9jID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygci5pZGVhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWluJywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICAgIG9jID0ge307XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJ21heCcsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnJywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgIGNjLm1hbmRhdG9yeVtvbGRuYW1lXygnJywga2V5KV0gPSByLmV4YWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWydtaW4nLCAnbWF4J10uZm9yRWFjaChtaXggPT4ge1xuICAgICAgICAgIGlmIChyW21peF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2MubWFuZGF0b3J5ID0gY2MubWFuZGF0b3J5IHx8IHt9O1xuICAgICAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKG1peCwga2V5KV0gPSByW21peF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoYy5hZHZhbmNlZCkge1xuICAgICAgY2Mub3B0aW9uYWwgPSAoY2Mub3B0aW9uYWwgfHwgW10pLmNvbmNhdChjLmFkdmFuY2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNjO1xuICB9O1xuXG4gIGNvbnN0IHNoaW1Db25zdHJhaW50c18gPSBmdW5jdGlvbihjb25zdHJhaW50cywgZnVuYykge1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDYxKSB7XG4gICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgfVxuICAgIGNvbnN0cmFpbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIGlmIChjb25zdHJhaW50cyAmJiB0eXBlb2YgY29uc3RyYWludHMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCByZW1hcCA9IGZ1bmN0aW9uKG9iaiwgYSwgYikge1xuICAgICAgICBpZiAoYSBpbiBvYmogJiYgIShiIGluIG9iaikpIHtcbiAgICAgICAgICBvYmpbYl0gPSBvYmpbYV07XG4gICAgICAgICAgZGVsZXRlIG9ialthXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0cmFpbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgICAgcmVtYXAoY29uc3RyYWludHMuYXVkaW8sICdhdXRvR2FpbkNvbnRyb2wnLCAnZ29vZ0F1dG9HYWluQ29udHJvbCcpO1xuICAgICAgcmVtYXAoY29uc3RyYWludHMuYXVkaW8sICdub2lzZVN1cHByZXNzaW9uJywgJ2dvb2dOb2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLmF1ZGlvKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzICYmIHR5cGVvZiBjb25zdHJhaW50cy52aWRlbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIFNoaW0gZmFjaW5nTW9kZSBmb3IgbW9iaWxlICYgc3VyZmFjZSBwcm8uXG4gICAgICBsZXQgZmFjZSA9IGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XG4gICAgICBmYWNlID0gZmFjZSAmJiAoKHR5cGVvZiBmYWNlID09PSAnb2JqZWN0JykgPyBmYWNlIDoge2lkZWFsOiBmYWNlfSk7XG4gICAgICBjb25zdCBnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcyA9IGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2NjtcblxuICAgICAgaWYgKChmYWNlICYmIChmYWNlLmV4YWN0ID09PSAndXNlcicgfHwgZmFjZS5leGFjdCA9PT0gJ2Vudmlyb25tZW50JyB8fFxuICAgICAgICAgICAgICAgICAgICBmYWNlLmlkZWFsID09PSAndXNlcicgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50JykpICYmXG4gICAgICAgICAgIShuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzICYmXG4gICAgICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuZmFjaW5nTW9kZSAmJlxuICAgICAgICAgICAgIWdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzKSkge1xuICAgICAgICBkZWxldGUgY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgICAgbGV0IG1hdGNoZXM7XG4gICAgICAgIGlmIChmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8IGZhY2UuaWRlYWwgPT09ICdlbnZpcm9ubWVudCcpIHtcbiAgICAgICAgICBtYXRjaGVzID0gWydiYWNrJywgJ3JlYXInXTtcbiAgICAgICAgfSBlbHNlIGlmIChmYWNlLmV4YWN0ID09PSAndXNlcicgfHwgZmFjZS5pZGVhbCA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IFsnZnJvbnQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIC8vIExvb2sgZm9yIG1hdGNoZXMgaW4gbGFiZWwsIG9yIHVzZSBsYXN0IGNhbSBmb3IgYmFjayAodHlwaWNhbCkuXG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXG4gICAgICAgICAgLnRoZW4oZGV2aWNlcyA9PiB7XG4gICAgICAgICAgICBkZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoZCA9PiBkLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XG4gICAgICAgICAgICBsZXQgZGV2ID0gZGV2aWNlcy5maW5kKGQgPT4gbWF0Y2hlcy5zb21lKG1hdGNoID0+XG4gICAgICAgICAgICAgIGQubGFiZWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhtYXRjaCkpKTtcbiAgICAgICAgICAgIGlmICghZGV2ICYmIGRldmljZXMubGVuZ3RoICYmIG1hdGNoZXMuaW5jbHVkZXMoJ2JhY2snKSkge1xuICAgICAgICAgICAgICBkZXYgPSBkZXZpY2VzW2RldmljZXMubGVuZ3RoIC0gMV07IC8vIG1vcmUgbGlrZWx5IHRoZSBiYWNrIGNhbVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRldikge1xuICAgICAgICAgICAgICBjb25zdHJhaW50cy52aWRlby5kZXZpY2VJZCA9IGZhY2UuZXhhY3QgPyB7ZXhhY3Q6IGRldi5kZXZpY2VJZH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aWRlYWw6IGRldi5kZXZpY2VJZH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICAgICAgICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgIH1cbiAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgfTtcblxuICBjb25zdCBzaGltRXJyb3JfID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDY0KSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHtcbiAgICAgICAgUGVybWlzc2lvbkRlbmllZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgUGVybWlzc2lvbkRpc21pc3NlZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgSW52YWxpZFN0YXRlRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBEZXZpY2VzTm90Rm91bmRFcnJvcjogJ05vdEZvdW5kRXJyb3InLFxuICAgICAgICBDb25zdHJhaW50Tm90U2F0aXNmaWVkRXJyb3I6ICdPdmVyY29uc3RyYWluZWRFcnJvcicsXG4gICAgICAgIFRyYWNrU3RhcnRFcnJvcjogJ05vdFJlYWRhYmxlRXJyb3InLFxuICAgICAgICBNZWRpYURldmljZUZhaWxlZER1ZVRvU2h1dGRvd246ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBNZWRpYURldmljZUtpbGxTd2l0Y2hPbjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIFRhYkNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InLFxuICAgICAgICBTY3JlZW5DYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJyxcbiAgICAgICAgRGV2aWNlQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcidcbiAgICAgIH1bZS5uYW1lXSB8fCBlLm5hbWUsXG4gICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICBjb25zdHJhaW50OiBlLmNvbnN0cmFpbnQgfHwgZS5jb25zdHJhaW50TmFtZSxcbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgKHRoaXMubWVzc2FnZSAmJiAnOiAnKSArIHRoaXMubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIGNvbnN0IGdldFVzZXJNZWRpYV8gPSBmdW5jdGlvbihjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgc2hpbUNvbnN0cmFpbnRzXyhjb25zdHJhaW50cywgYyA9PiB7XG4gICAgICBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhKGMsIG9uU3VjY2VzcywgZSA9PiB7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihzaGltRXJyb3JfKGUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBnZXRVc2VyTWVkaWFfLmJpbmQobmF2aWdhdG9yKTtcblxuICAvLyBFdmVuIHRob3VnaCBDaHJvbWUgNDUgaGFzIG5hdmlnYXRvci5tZWRpYURldmljZXMgYW5kIGEgZ2V0VXNlck1lZGlhXG4gIC8vIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBQcm9taXNlLCBpdCBkb2VzIG5vdCBhY2NlcHQgc3BlYy1zdHlsZVxuICAvLyBjb25zdHJhaW50cy5cbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgY29uc3Qgb3JpZ0dldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLlxuICAgICAgICBiaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oY3MpIHtcbiAgICAgIHJldHVybiBzaGltQ29uc3RyYWludHNfKGNzLCBjID0+IG9yaWdHZXRVc2VyTWVkaWEoYykudGhlbihzdHJlYW0gPT4ge1xuICAgICAgICBpZiAoYy5hdWRpbyAmJiAhc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoIHx8XG4gICAgICAgICAgICBjLnZpZGVvICYmICFzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignJywgJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSwgZSA9PiBQcm9taXNlLnJlamVjdChzaGltRXJyb3JfKGUpKSkpO1xuICAgIH07XG4gIH1cbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBTRFBVdGlscyBmcm9tICdzZHAnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdykge1xuICAvLyBmb3VuZGF0aW9uIGlzIGFyYml0cmFyaWx5IGNob3NlbiBhcyBhbiBpbmRpY2F0b3IgZm9yIGZ1bGwgc3VwcG9ydCBmb3JcbiAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1wYy8jcnRjaWNlY2FuZGlkYXRlLWludGVyZmFjZVxuICBpZiAoIXdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgKHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgJiYgJ2ZvdW5kYXRpb24nIGluXG4gICAgICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBOYXRpdmVSVENJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlO1xuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGE9IHdoaWNoIHNob3VsZG4ndCBiZSBwYXJ0IG9mIHRoZSBjYW5kaWRhdGUgc3RyaW5nLlxuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ29iamVjdCcgJiYgYXJncy5jYW5kaWRhdGUgJiZcbiAgICAgICAgYXJncy5jYW5kaWRhdGUuaW5kZXhPZignYT0nKSA9PT0gMCkge1xuICAgICAgYXJncyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgYXJncy5jYW5kaWRhdGUgPSBhcmdzLmNhbmRpZGF0ZS5zdWJzdHIoMik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MuY2FuZGlkYXRlICYmIGFyZ3MuY2FuZGlkYXRlLmxlbmd0aCkge1xuICAgICAgLy8gQXVnbWVudCB0aGUgbmF0aXZlIGNhbmRpZGF0ZSB3aXRoIHRoZSBwYXJzZWQgZmllbGRzLlxuICAgICAgY29uc3QgbmF0aXZlQ2FuZGlkYXRlID0gbmV3IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZShhcmdzKTtcbiAgICAgIGNvbnN0IHBhcnNlZENhbmRpZGF0ZSA9IFNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlKGFyZ3MuY2FuZGlkYXRlKTtcbiAgICAgIGNvbnN0IGF1Z21lbnRlZENhbmRpZGF0ZSA9IE9iamVjdC5hc3NpZ24obmF0aXZlQ2FuZGlkYXRlLFxuICAgICAgICAgIHBhcnNlZENhbmRpZGF0ZSk7XG5cbiAgICAgIC8vIEFkZCBhIHNlcmlhbGl6ZXIgdGhhdCBkb2VzIG5vdCBzZXJpYWxpemUgdGhlIGV4dHJhIGF0dHJpYnV0ZXMuXG4gICAgICBhdWdtZW50ZWRDYW5kaWRhdGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbmRpZGF0ZTogYXVnbWVudGVkQ2FuZGlkYXRlLmNhbmRpZGF0ZSxcbiAgICAgICAgICBzZHBNaWQ6IGF1Z21lbnRlZENhbmRpZGF0ZS5zZHBNaWQsXG4gICAgICAgICAgc2RwTUxpbmVJbmRleDogYXVnbWVudGVkQ2FuZGlkYXRlLnNkcE1MaW5lSW5kZXgsXG4gICAgICAgICAgdXNlcm5hbWVGcmFnbWVudDogYXVnbWVudGVkQ2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQsXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGF1Z21lbnRlZENhbmRpZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOYXRpdmVSVENJY2VDYW5kaWRhdGUoYXJncyk7XG4gIH07XG4gIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlID0gTmF0aXZlUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZTtcblxuICAvLyBIb29rIHVwIHRoZSBhdWdtZW50ZWQgY2FuZGlkYXRlIGluIG9uaWNlY2FuZGlkYXRlIGFuZFxuICAvLyBhZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCAuLi4pXG4gIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2ljZWNhbmRpZGF0ZScsIGUgPT4ge1xuICAgIGlmIChlLmNhbmRpZGF0ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdjYW5kaWRhdGUnLCB7XG4gICAgICAgIHZhbHVlOiBuZXcgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZShlLmNhbmRpZGF0ZSksXG4gICAgICAgIHdyaXRhYmxlOiAnZmFsc2UnXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoISgnc2N0cCcgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3NjdHAnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHNjdHBJbkRlc2NyaXB0aW9uID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICBpZiAoIWRlc2NyaXB0aW9uIHx8ICFkZXNjcmlwdGlvbi5zZHApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGRlc2NyaXB0aW9uLnNkcCk7XG4gICAgc2VjdGlvbnMuc2hpZnQoKTtcbiAgICByZXR1cm4gc2VjdGlvbnMuc29tZShtZWRpYVNlY3Rpb24gPT4ge1xuICAgICAgY29uc3QgbUxpbmUgPSBTRFBVdGlscy5wYXJzZU1MaW5lKG1lZGlhU2VjdGlvbik7XG4gICAgICByZXR1cm4gbUxpbmUgJiYgbUxpbmUua2luZCA9PT0gJ2FwcGxpY2F0aW9uJ1xuICAgICAgICAgICYmIG1MaW5lLnByb3RvY29sLmluZGV4T2YoJ1NDVFAnKSAhPT0gLTE7XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24gPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIC8vIFRPRE86IElzIHRoZXJlIGEgYmV0dGVyIHNvbHV0aW9uIGZvciBkZXRlY3RpbmcgRmlyZWZveD9cbiAgICBjb25zdCBtYXRjaCA9IGRlc2NyaXB0aW9uLnNkcC5tYXRjaCgvbW96aWxsYS4uLlRISVNfSVNfU0RQQVJUQS0oXFxkKykvKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2gubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAvLyBUZXN0IGZvciBOYU4gKHllcywgdGhpcyBpcyB1Z2x5KVxuICAgIHJldHVybiB2ZXJzaW9uICE9PSB2ZXJzaW9uID8gLTEgOiB2ZXJzaW9uO1xuICB9O1xuXG4gIGNvbnN0IGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uKHJlbW90ZUlzRmlyZWZveCkge1xuICAgIC8vIEV2ZXJ5IGltcGxlbWVudGF0aW9uIHdlIGtub3cgY2FuIHNlbmQgYXQgbGVhc3QgNjQgS2lCLlxuICAgIC8vIE5vdGU6IEFsdGhvdWdoIENocm9tZSBpcyB0ZWNobmljYWxseSBhYmxlIHRvIHNlbmQgdXAgdG8gMjU2IEtpQiwgdGhlXG4gICAgLy8gICAgICAgZGF0YSBkb2VzIG5vdCByZWFjaCB0aGUgb3RoZXIgcGVlciByZWxpYWJseS5cbiAgICAvLyAgICAgICBTZWU6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD04NDE5XG4gICAgbGV0IGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcpIHtcbiAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTcpIHtcbiAgICAgICAgaWYgKHJlbW90ZUlzRmlyZWZveCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBGRiA8IDU3IHdpbGwgc2VuZCBpbiAxNiBLaUIgY2h1bmtzIHVzaW5nIHRoZSBkZXByZWNhdGVkIFBQSURcbiAgICAgICAgICAvLyBmcmFnbWVudGF0aW9uLlxuICAgICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDE2Mzg0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEhvd2V2ZXIsIG90aGVyIEZGIChhbmQgUkFXUlRDKSBjYW4gcmVhc3NlbWJsZSBQUElELWZyYWdtZW50ZWRcbiAgICAgICAgICAvLyBtZXNzYWdlcy4gVGh1cywgc3VwcG9ydGluZyB+MiBHaUIgd2hlbiBzZW5kaW5nLlxuICAgICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDYwKSB7XG4gICAgICAgIC8vIEN1cnJlbnRseSwgYWxsIEZGID49IDU3IHdpbGwgcmVzZXQgdGhlIHJlbW90ZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZVxuICAgICAgICAvLyB0byB0aGUgZGVmYXVsdCB2YWx1ZSB3aGVuIGEgZGF0YSBjaGFubmVsIGlzIGNyZWF0ZWQgYXQgYSBsYXRlclxuICAgICAgICAvLyBzdGFnZS4gOihcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI2ODMxXG4gICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9XG4gICAgICAgICAgYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gNTcgPyA2NTUzNSA6IDY1NTM2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRkYgPj0gNjAgc3VwcG9ydHMgc2VuZGluZyB+MiBHaUJcbiAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gMjE0NzQ4MzYzNztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhblNlbmRNYXhNZXNzYWdlU2l6ZTtcbiAgfTtcblxuICBjb25zdCBnZXRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCByZW1vdGVJc0ZpcmVmb3gpIHtcbiAgICAvLyBOb3RlOiA2NTUzNiBieXRlcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBTRFAgc3BlYy4gQWxzbyxcbiAgICAvLyAgICAgICBldmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IHN1cHBvcnRzIHJlY2VpdmluZyA2NTUzNiBieXRlcy5cbiAgICBsZXQgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcblxuICAgIC8vIEZGIDU3IGhhcyBhIHNsaWdodGx5IGluY29ycmVjdCBkZWZhdWx0IHJlbW90ZSBtYXggbWVzc2FnZSBzaXplLCBzb1xuICAgIC8vIHdlIG5lZWQgdG8gYWRqdXN0IGl0IGhlcmUgdG8gYXZvaWQgYSBmYWlsdXJlIHdoZW4gc2VuZGluZy5cbiAgICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MjU2OTdcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnXG4gICAgICAgICAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1Nykge1xuICAgICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KGRlc2NyaXB0aW9uLnNkcCxcbiAgICAgICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gICAgaWYgKG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gcGFyc2VJbnQobWF0Y2hbMF0uc3Vic3RyKDE5KSwgMTApO1xuICAgIH0gZWxzZSBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnICYmXG4gICAgICAgICAgICAgICAgcmVtb3RlSXNGaXJlZm94ICE9PSAtMSkge1xuICAgICAgLy8gSWYgdGhlIG1heGltdW0gbWVzc2FnZSBzaXplIGlzIG5vdCBwcmVzZW50IGluIHRoZSByZW1vdGUgU0RQIGFuZFxuICAgICAgLy8gYm90aCBsb2NhbCBhbmQgcmVtb3RlIGFyZSBGaXJlZm94LCB0aGUgcmVtb3RlIHBlZXIgY2FuIHJlY2VpdmVcbiAgICAgIC8vIH4yIEdpQi5cbiAgICAgIG1heE1lc3NhZ2VTaXplID0gMjE0NzQ4MzYzNztcbiAgICB9XG4gICAgcmV0dXJuIG1heE1lc3NhZ2VTaXplO1xuICB9O1xuXG4gIGNvbnN0IG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgICAgIHRoaXMuX3NjdHAgPSBudWxsO1xuICAgICAgLy8gQ2hyb21lIGRlY2lkZWQgdG8gbm90IGV4cG9zZSAuc2N0cCBpbiBwbGFuLWIgbW9kZS5cbiAgICAgIC8vIEFzIHVzdWFsLCBhZGFwdGVyLmpzIGhhcyB0byBkbyBhbiAndWdseSB3b3Jha2Fyb3VuZCdcbiAgICAgIC8vIHRvIGNvdmVyIHVwIHRoZSBtZXNzLlxuICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdjaHJvbWUnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNzYpIHtcbiAgICAgICAgY29uc3Qge3NkcFNlbWFudGljc30gPSB0aGlzLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgaWYgKHNkcFNlbWFudGljcyA9PT0gJ3BsYW4tYicpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NjdHAnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzY3RwSW5EZXNjcmlwdGlvbihhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSByZW1vdGUgaXMgRkYuXG4gICAgICAgIGNvbnN0IGlzRmlyZWZveCA9IGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uKGFyZ3VtZW50c1swXSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSB0aGUgbG9jYWwgcGVlciBpcyBjYXBhYmxlIG9mIHNlbmRpbmdcbiAgICAgICAgY29uc3QgY2FuU2VuZE1NUyA9IGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZShpc0ZpcmVmb3gpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgb2YgdGhlIHJlbW90ZSBwZWVyLlxuICAgICAgICBjb25zdCByZW1vdGVNTVMgPSBnZXRNYXhNZXNzYWdlU2l6ZShhcmd1bWVudHNbMF0sIGlzRmlyZWZveCk7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGZpbmFsIG1heGltdW0gbWVzc2FnZSBzaXplXG4gICAgICAgIGxldCBtYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgaWYgKGNhblNlbmRNTVMgPT09IDAgJiYgcmVtb3RlTU1TID09PSAwKSB7XG4gICAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FuU2VuZE1NUyA9PT0gMCB8fCByZW1vdGVNTVMgPT09IDApIHtcbiAgICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE1hdGgubWF4KGNhblNlbmRNTVMsIHJlbW90ZU1NUyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1pbihjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgUlRDU2N0cFRyYW5zcG9ydCBvYmplY3QgYW5kIHRoZSAnbWF4TWVzc2FnZVNpemUnXG4gICAgICAgIC8vIGF0dHJpYnV0ZS5cbiAgICAgICAgY29uc3Qgc2N0cCA9IHt9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2N0cCwgJ21heE1lc3NhZ2VTaXplJywge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zY3RwID0gc2N0cDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdykge1xuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiZcbiAgICAgICdjcmVhdGVEYXRhQ2hhbm5lbCcgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBOb3RlOiBBbHRob3VnaCBGaXJlZm94ID49IDU3IGhhcyBhIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgdGhlIG1heGltdW1cbiAgLy8gICAgICAgbWVzc2FnZSBzaXplIGNhbiBiZSByZXNldCBmb3IgYWxsIGRhdGEgY2hhbm5lbHMgYXQgYSBsYXRlciBzdGFnZS5cbiAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI2ODMxXG5cbiAgZnVuY3Rpb24gd3JhcERjU2VuZChkYywgcGMpIHtcbiAgICBjb25zdCBvcmlnRGF0YUNoYW5uZWxTZW5kID0gZGMuc2VuZDtcbiAgICBkYy5zZW5kID0gZnVuY3Rpb24gc2VuZCgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhcmd1bWVudHNbMF07XG4gICAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aCB8fCBkYXRhLnNpemUgfHwgZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgaWYgKGRjLnJlYWR5U3RhdGUgPT09ICdvcGVuJyAmJlxuICAgICAgICAgIHBjLnNjdHAgJiYgbGVuZ3RoID4gcGMuc2N0cC5tYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNZXNzYWdlIHRvbyBsYXJnZSAoY2FuIHNlbmQgYSBtYXhpbXVtIG9mICcgK1xuICAgICAgICAgIHBjLnNjdHAubWF4TWVzc2FnZVNpemUgKyAnIGJ5dGVzKScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdEYXRhQ2hhbm5lbFNlbmQuYXBwbHkoZGMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwgPVxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWw7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWwgPVxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGFDaGFubmVsKCkge1xuICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdyYXBEY1NlbmQoZGF0YUNoYW5uZWwsIHRoaXMpO1xuICAgICAgcmV0dXJuIGRhdGFDaGFubmVsO1xuICAgIH07XG4gIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2RhdGFjaGFubmVsJywgZSA9PiB7XG4gICAgd3JhcERjU2VuZChlLmNoYW5uZWwsIGUudGFyZ2V0KTtcbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5cblxuLyogc2hpbXMgUlRDQ29ubmVjdGlvblN0YXRlIGJ5IHByZXRlbmRpbmcgaXQgaXMgdGhlIHNhbWUgYXMgaWNlQ29ubmVjdGlvblN0YXRlLlxuICogU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD02MTQ1I2MxMlxuICogZm9yIHdoeSB0aGlzIGlzIGEgdmFsaWQgaGFjayBpbiBDaHJvbWUuIEluIEZpcmVmb3ggaXQgaXMgc2xpZ2h0bHkgaW5jb3JyZWN0XG4gKiBzaW5jZSBEVExTIGZhaWx1cmVzIHdvdWxkIGJlIGhpZGRlbi4gU2VlXG4gKiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjY1ODI3XG4gKiBmb3IgdGhlIEZpcmVmb3ggdHJhY2tpbmcgYnVnLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgICdjb25uZWN0aW9uU3RhdGUnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvdG8gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdjb25uZWN0aW9uU3RhdGUnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGxldGVkOiAnY29ubmVjdGVkJyxcbiAgICAgICAgY2hlY2tpbmc6ICdjb25uZWN0aW5nJ1xuICAgICAgfVt0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZV0gfHwgdGhpcy5pY2VDb25uZWN0aW9uU3RhdGU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlIHx8IG51bGw7XG4gICAgfSxcbiAgICBzZXQoY2IpIHtcbiAgICAgIGlmICh0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsXG4gICAgICAgICAgICB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsXG4gICAgICAgICAgICB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbiddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgIGNvbnN0IG9yaWdNZXRob2QgPSBwcm90b1ttZXRob2RdO1xuICAgIHByb3RvW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5ID0gZSA9PiB7XG4gICAgICAgICAgY29uc3QgcGMgPSBlLnRhcmdldDtcbiAgICAgICAgICBpZiAocGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgIT09IHBjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgcGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgPSBwYy5jb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBFdmVudCgnY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZSk7XG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJyxcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgLyogcmVtb3ZlIGE9ZXh0bWFwLWFsbG93LW1peGVkIGZvciB3ZWJydGMub3JnIDwgTTcxICovXG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDcxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnc2FmYXJpJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDYwNSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYXRpdmVTUkQgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oZGVzYykge1xuICAgIGlmIChkZXNjICYmIGRlc2Muc2RwICYmIGRlc2Muc2RwLmluZGV4T2YoJ1xcbmE9ZXh0bWFwLWFsbG93LW1peGVkJykgIT09IC0xKSB7XG4gICAgICBjb25zdCBzZHAgPSBkZXNjLnNkcC5zcGxpdCgnXFxuJykuZmlsdGVyKChsaW5lKSA9PiB7XG4gICAgICAgIHJldHVybiBsaW5lLnRyaW0oKSAhPT0gJ2E9ZXh0bWFwLWFsbG93LW1peGVkJztcbiAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgLy8gU2FmYXJpIGVuZm9yY2VzIHJlYWQtb25seS1uZXNzIG9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBmaWVsZHMuXG4gICAgICBpZiAod2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiAmJlxuICAgICAgICAgIGRlc2MgaW5zdGFuY2VvZiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICB0eXBlOiBkZXNjLnR5cGUsXG4gICAgICAgICAgc2RwLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc2Muc2RwID0gc2RwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlU1JELmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICAvLyBTdXBwb3J0IGZvciBhZGRJY2VDYW5kaWRhdGUobnVsbCBvciB1bmRlZmluZWQpXG4gIC8vIGFzIHdlbGwgYXMgYWRkSWNlQ2FuZGlkYXRlKHtjYW5kaWRhdGU6IFwiXCIsIC4uLn0pXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk3ODU4MlxuICAvLyBOb3RlOiBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb3RoZXIgcG9seWZpbGxzIHdoaWNoIGNoYW5nZSB0aGUgc2lnbmF0dXJlLlxuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlID1cbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuICBpZiAoIW5hdGl2ZUFkZEljZUNhbmRpZGF0ZSB8fCBuYXRpdmVBZGRJY2VDYW5kaWRhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID1cbiAgICBmdW5jdGlvbiBhZGRJY2VDYW5kaWRhdGUoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzWzFdKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzFdLmFwcGx5KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIC8vIEZpcmVmb3ggNjgrIGVtaXRzIGFuZCBwcm9jZXNzZXMge2NhbmRpZGF0ZTogXCJcIiwgLi4ufSwgaWdub3JlXG4gICAgICAvLyBpbiBvbGRlciB2ZXJzaW9ucy5cbiAgICAgIC8vIE5hdGl2ZSBzdXBwb3J0IGZvciBpZ25vcmluZyBleGlzdHMgZm9yIENocm9tZSBNNzcrLlxuICAgICAgLy8gU2FmYXJpIGlnbm9yZXMgYXMgd2VsbCwgZXhhY3QgdmVyc2lvbiB1bmtub3duIGJ1dCB3b3JrcyBpbiB0aGUgc2FtZVxuICAgICAgLy8gdmVyc2lvbiB0aGF0IGFsc28gaWdub3JlcyBhZGRJY2VDYW5kaWRhdGUobnVsbCkuXG4gICAgICBpZiAoKChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNzgpXG4gICAgICAgICAgIHx8IChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCdcbiAgICAgICAgICAgICAgICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2OClcbiAgICAgICAgICAgfHwgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdzYWZhcmknKSlcbiAgICAgICAgICAmJiBhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzBdLmNhbmRpZGF0ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8vIE5vdGU6IE1ha2Ugc3VyZSB0byBjYWxsIHRoaXMgYWhlYWQgb2YgQVBJcyB0aGF0IG1vZGlmeVxuLy8gc2V0TG9jYWxEZXNjcmlwdGlvbi5sZW5ndGhcbmV4cG9ydCBmdW5jdGlvbiBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbiA9XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIGlmICghbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbiB8fCBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPVxuICAgIGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgICBsZXQgZGVzYyA9IGFyZ3VtZW50c1swXSB8fCB7fTtcbiAgICAgIGlmICh0eXBlb2YgZGVzYyAhPT0gJ29iamVjdCcgfHwgKGRlc2MudHlwZSAmJiBkZXNjLnNkcCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZW1haW5pbmcgc3RlcHMgc2hvdWxkIHRlY2huaWNhbGx5IGhhcHBlbiB3aGVuIFNMRCBjb21lcyBvZmYgdGhlXG4gICAgICAvLyBSVENQZWVyQ29ubmVjdGlvbidzIG9wZXJhdGlvbnMgY2hhaW4gKG5vdCBhaGVhZCBvZiBnb2luZyBvbiBpdCksIGJ1dFxuICAgICAgLy8gdGhpcyBpcyB0b28gZGlmZmljdWx0IHRvIHNoaW0uIEluc3RlYWQsIHRoaXMgc2hpbSBvbmx5IGNvdmVycyB0aGVcbiAgICAgIC8vIGNvbW1vbiBjYXNlIHdoZXJlIHRoZSBvcGVyYXRpb25zIGNoYWluIGlzIGVtcHR5LiBUaGlzIGlzIGltcGVyZmVjdCwgYnV0XG4gICAgICAvLyBzaG91bGQgY292ZXIgbWFueSBjYXNlcy4gUmF0aW9uYWxlOiBFdmVuIGlmIHdlIGNhbid0IHJlZHVjZSB0aGUgZ2xhcmVcbiAgICAgIC8vIHdpbmRvdyB0byB6ZXJvIG9uIGltcGVyZmVjdCBpbXBsZW1lbnRhdGlvbnMsIHRoZXJlJ3MgdmFsdWUgaW4gdGFwcGluZ1xuICAgICAgLy8gaW50byB0aGUgcGVyZmVjdCBuZWdvdGlhdGlvbiBwYXR0ZXJuIHRoYXQgc2V2ZXJhbCBicm93c2VycyBzdXBwb3J0LlxuICAgICAgZGVzYyA9IHt0eXBlOiBkZXNjLnR5cGUsIHNkcDogZGVzYy5zZHB9O1xuICAgICAgaWYgKCFkZXNjLnR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNpZ25hbGluZ1N0YXRlKSB7XG4gICAgICAgICAgY2FzZSAnc3RhYmxlJzpcbiAgICAgICAgICBjYXNlICdoYXZlLWxvY2FsLW9mZmVyJzpcbiAgICAgICAgICBjYXNlICdoYXZlLXJlbW90ZS1wcmFuc3dlcic6XG4gICAgICAgICAgICBkZXNjLnR5cGUgPSAnb2ZmZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGRlc2MudHlwZSA9ICdhbnN3ZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZXNjLnNkcCB8fCAoZGVzYy50eXBlICE9PSAnb2ZmZXInICYmIGRlc2MudHlwZSAhPT0gJ2Fuc3dlcicpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmdW5jID0gZGVzYy50eXBlID09PSAnb2ZmZXInID8gdGhpcy5jcmVhdGVPZmZlciA6IHRoaXMuY3JlYXRlQW5zd2VyO1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcylcbiAgICAgICAgLnRoZW4oZCA9PiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkXSkpO1xuICAgIH07XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG5leHBvcnQge3NoaW1HZXRVc2VyTWVkaWF9IGZyb20gJy4vZ2V0dXNlcm1lZGlhJztcbmV4cG9ydCB7c2hpbUdldERpc3BsYXlNZWRpYX0gZnJvbSAnLi9nZXRkaXNwbGF5bWVkaWEnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbU9uVHJhY2sod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJlxuICAgICAgKCdyZWNlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSAmJlxuICAgICAgISgndHJhbnNjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7cmVjZWl2ZXI6IHRoaXMucmVjZWl2ZXJ9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUGVlckNvbm5lY3Rpb24od2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47IC8vIHByb2JhYmx5IG1lZGlhLnBlZXJjb25uZWN0aW9uLmVuYWJsZWQ9ZmFsc2UgaW4gYWJvdXQ6Y29uZmlnXG4gIH1cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uO1xuICB9XG5cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xuICAgIC8vIHNoaW0gYXdheSBuZWVkIGZvciBvYnNvbGV0ZSBSVENJY2VDYW5kaWRhdGUvUlRDU2Vzc2lvbkRlc2NyaXB0aW9uLlxuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICBjb25zdCBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICAgICAgY29uc3QgbWV0aG9kT2JqID0ge1ttZXRob2RdKCkge1xuICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3ICgobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJykgP1xuICAgICAgICAgICAgICAgIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgOlxuICAgICAgICAgICAgICAgIHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfX07XG4gICAgICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gICAgICAgIH0pO1xuICB9XG5cbiAgY29uc3QgbW9kZXJuU3RhdHNUeXBlcyA9IHtcbiAgICBpbmJvdW5kcnRwOiAnaW5ib3VuZC1ydHAnLFxuICAgIG91dGJvdW5kcnRwOiAnb3V0Ym91bmQtcnRwJyxcbiAgICBjYW5kaWRhdGVwYWlyOiAnY2FuZGlkYXRlLXBhaXInLFxuICAgIGxvY2FsY2FuZGlkYXRlOiAnbG9jYWwtY2FuZGlkYXRlJyxcbiAgICByZW1vdGVjYW5kaWRhdGU6ICdyZW1vdGUtY2FuZGlkYXRlJ1xuICB9O1xuXG4gIGNvbnN0IG5hdGl2ZUdldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGNvbnN0IFtzZWxlY3Rvciwgb25TdWNjLCBvbkVycl0gPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5hdGl2ZUdldFN0YXRzLmFwcGx5KHRoaXMsIFtzZWxlY3RvciB8fCBudWxsXSlcbiAgICAgIC50aGVuKHN0YXRzID0+IHtcbiAgICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1MyAmJiAhb25TdWNjKSB7XG4gICAgICAgICAgLy8gU2hpbSBvbmx5IHByb21pc2UgZ2V0U3RhdHMgd2l0aCBzcGVjLWh5cGhlbnMgaW4gdHlwZSBuYW1lc1xuICAgICAgICAgIC8vIExlYXZlIGNhbGxiYWNrIHZlcnNpb24gYWxvbmU7IG1pc2Mgb2xkIHVzZXMgb2YgZm9yRWFjaCBiZWZvcmUgTWFwXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgICAgICAgIHN0YXQudHlwZSA9IG1vZGVyblN0YXRzVHlwZXNbc3RhdC50eXBlXSB8fCBzdGF0LnR5cGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5uYW1lICE9PSAnVHlwZUVycm9yJykge1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXZvaWQgVHlwZUVycm9yOiBcInR5cGVcIiBpcyByZWFkLW9ubHksIGluIG9sZCB2ZXJzaW9ucy4gMzQtNDNpc2hcbiAgICAgICAgICAgIHN0YXRzLmZvckVhY2goKHN0YXQsIGkpID0+IHtcbiAgICAgICAgICAgICAgc3RhdHMuc2V0KGksIE9iamVjdC5hc3NpZ24oe30sIHN0YXQsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHM7XG4gICAgICB9KVxuICAgICAgLnRoZW4ob25TdWNjLCBvbkVycik7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltU2VuZGVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJlxuICAgICAgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgaWYgKG9yaWdHZXRTZW5kZXJzKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcbiAgICAgIHJldHVybiBzZW5kZXJzO1xuICAgIH07XG4gIH1cblxuICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICBpZiAob3JpZ0FkZFRyYWNrKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBzZW5kZXIuX3BjID0gdGhpcztcbiAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgfTtcbiAgfVxuICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrID8gdGhpcy5fcGMuZ2V0U3RhdHModGhpcy50cmFjaykgOlxuICAgICAgICBQcm9taXNlLnJlc29sdmUobmV3IE1hcCgpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1SZWNlaXZlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiZcbiAgICAgIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3aW5kb3cuUlRDUnRwU2VuZGVyICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnR2V0UmVjZWl2ZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnM7XG4gIGlmIChvcmlnR2V0UmVjZWl2ZXJzKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMgPSBmdW5jdGlvbiBnZXRSZWNlaXZlcnMoKSB7XG4gICAgICBjb25zdCByZWNlaXZlcnMgPSBvcmlnR2V0UmVjZWl2ZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHJlY2VpdmVycy5mb3JFYWNoKHJlY2VpdmVyID0+IHJlY2VpdmVyLl9wYyA9IHRoaXMpO1xuICAgICAgcmV0dXJuIHJlY2VpdmVycztcbiAgICB9O1xuICB9XG4gIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XG4gICAgZS5yZWNlaXZlci5fcGMgPSBlLnNyY0VsZW1lbnQ7XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xuICB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKHRoaXMudHJhY2spO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVJlbW92ZVN0cmVhbSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgICdyZW1vdmVTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPVxuICAgIGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHV0aWxzLmRlcHJlY2F0ZWQoJ3JlbW92ZVN0cmVhbScsICdyZW1vdmVUcmFjaycpO1xuICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzZW5kZXIgPT4ge1xuICAgICAgICBpZiAoc2VuZGVyLnRyYWNrICYmIHN0cmVhbS5nZXRUcmFja3MoKS5pbmNsdWRlcyhzZW5kZXIudHJhY2spKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVJUQ0RhdGFDaGFubmVsKHdpbmRvdykge1xuICAvLyByZW5hbWUgRGF0YUNoYW5uZWwgdG8gUlRDRGF0YUNoYW5uZWwgKG5hdGl2ZSBmaXggaW4gRkY2MCk6XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExNzM4NTFcbiAgaWYgKHdpbmRvdy5EYXRhQ2hhbm5lbCAmJiAhd2luZG93LlJUQ0RhdGFDaGFubmVsKSB7XG4gICAgd2luZG93LlJUQ0RhdGFDaGFubmVsID0gd2luZG93LkRhdGFDaGFubmVsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQWRkVHJhbnNjZWl2ZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0FkZFRyYW5zY2VpdmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFuc2NlaXZlcjtcbiAgaWYgKG9yaWdBZGRUcmFuc2NlaXZlcikge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhbnNjZWl2ZXIgPVxuICAgICAgZnVuY3Rpb24gYWRkVHJhbnNjZWl2ZXIoKSB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XG4gICAgICAgIGNvbnN0IGluaXRQYXJhbWV0ZXJzID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBjb25zdCBzaG91bGRQZXJmb3JtQ2hlY2sgPSBpbml0UGFyYW1ldGVycyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZW5kRW5jb2RpbmdzJyBpbiBpbml0UGFyYW1ldGVycztcbiAgICAgICAgaWYgKHNob3VsZFBlcmZvcm1DaGVjaykge1xuICAgICAgICAgIC8vIElmIHNlbmRFbmNvZGluZ3MgcGFyYW1zIGFyZSBwcm92aWRlZCwgdmFsaWRhdGUgZ3JhbW1hclxuICAgICAgICAgIGluaXRQYXJhbWV0ZXJzLnNlbmRFbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmdQYXJhbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCdyaWQnIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgICAgY29uc3QgcmlkUmVnZXggPSAvXlthLXowLTldezAsMTZ9JC9pO1xuICAgICAgICAgICAgICBpZiAoIXJpZFJlZ2V4LnRlc3QoZW5jb2RpbmdQYXJhbS5yaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBSSUQgdmFsdWUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnc2NhbGVSZXNvbHV0aW9uRG93bkJ5JyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICAgIGlmICghKHBhcnNlRmxvYXQoZW5jb2RpbmdQYXJhbS5zY2FsZVJlc29sdXRpb25Eb3duQnkpID49IDEuMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2NhbGVfcmVzb2x1dGlvbl9kb3duX2J5IG11c3QgYmUgPj0gMS4wJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnbWF4RnJhbWVyYXRlJyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICAgIGlmICghKHBhcnNlRmxvYXQoZW5jb2RpbmdQYXJhbS5tYXhGcmFtZXJhdGUpID49IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21heF9mcmFtZXJhdGUgbXVzdCBiZSA+PSAwLjAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gb3JpZ0FkZFRyYW5zY2VpdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChzaG91bGRQZXJmb3JtQ2hlY2spIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW5pdCBvcHRpb25zIHdlcmUgYXBwbGllZC4gSWYgbm90IHdlIGRvIHRoaXMgaW4gYW5cbiAgICAgICAgICAvLyBhc3luY2hyb25vdXMgd2F5IGFuZCBzYXZlIHRoZSBwcm9taXNlIHJlZmVyZW5jZSBpbiBhIGdsb2JhbCBvYmplY3QuXG4gICAgICAgICAgLy8gVGhpcyBpcyBhbiB1Z2x5IGhhY2ssIGJ1dCBhdCB0aGUgc2FtZSB0aW1lIGlzIHdheSBtb3JlIHJvYnVzdCB0aGFuXG4gICAgICAgICAgLy8gY2hlY2tpbmcgdGhlIHNlbmRlciBwYXJhbWV0ZXJzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGNyZWF0ZU9mZmVyXG4gICAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgYWZ0ZXIgdGhlIGNyZWF0ZW9mZmVyIHdlIGFyZSBub3QgMTAwJSBzdXJlIHRoYXRcbiAgICAgICAgICAvLyB0aGUgcGFyYW1zIHdlcmUgYXN5bmNocm9ub3VzbHkgYXBwbGllZCBzbyB3ZSBtaWdodCBtaXNzIHRoZVxuICAgICAgICAgIC8vIG9wcG9ydHVuaXR5IHRvIHJlY3JlYXRlIG9mZmVyLlxuICAgICAgICAgIGNvbnN0IHtzZW5kZXJ9ID0gdHJhbnNjZWl2ZXI7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgICBpZiAoISgnZW5jb2RpbmdzJyBpbiBwYXJhbXMpIHx8XG4gICAgICAgICAgICAgIC8vIEF2b2lkIGJlaW5nIGZvb2xlZCBieSBwYXRjaGVkIGdldFBhcmFtZXRlcnMoKSBiZWxvdy5cbiAgICAgICAgICAgICAgKHBhcmFtcy5lbmNvZGluZ3MubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMuZW5jb2RpbmdzWzBdKS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gaW5pdFBhcmFtZXRlcnMuc2VuZEVuY29kaW5ncztcbiAgICAgICAgICAgIHNlbmRlci5zZW5kRW5jb2RpbmdzID0gaW5pdFBhcmFtZXRlcnMuc2VuZEVuY29kaW5ncztcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLnB1c2goc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKVxuICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbmRlci5zZW5kRW5jb2RpbmdzO1xuICAgICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbmRlci5zZW5kRW5jb2RpbmdzO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyO1xuICAgICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUdldFBhcmFtZXRlcnMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdHZXRQYXJhbWV0ZXJzID0gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0UGFyYW1ldGVycztcbiAgaWYgKG9yaWdHZXRQYXJhbWV0ZXJzKSB7XG4gICAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0UGFyYW1ldGVycyA9XG4gICAgICBmdW5jdGlvbiBnZXRQYXJhbWV0ZXJzKCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBvcmlnR2V0UGFyYW1ldGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoISgnZW5jb2RpbmdzJyBpbiBwYXJhbXMpKSB7XG4gICAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IFtdLmNvbmNhdCh0aGlzLnNlbmRFbmNvZGluZ3MgfHwgW3t9XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1DcmVhdGVPZmZlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlT2ZmZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIoKSB7XG4gICAgaWYgKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzICYmIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KVxuICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1DcmVhdGVBbnN3ZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0NyZWF0ZUFuc3dlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uIGNyZWF0ZUFuc3dlcigpIHtcbiAgICBpZiAodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgJiYgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KVxuICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxOCBUaGUgYWRhcHRlci5qcyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXREaXNwbGF5TWVkaWEod2luZG93LCBwcmVmZXJyZWRNZWRpYVNvdXJjZSkge1xuICBpZiAod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMgJiZcbiAgICAnZ2V0RGlzcGxheU1lZGlhJyBpbiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhID1cbiAgICBmdW5jdGlvbiBnZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpIHtcbiAgICAgIGlmICghKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvKSkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRE9NRXhjZXB0aW9uKCdnZXREaXNwbGF5TWVkaWEgd2l0aG91dCB2aWRlbyAnICtcbiAgICAgICAgICAgICdjb25zdHJhaW50cyBpcyB1bmRlZmluZWQnKTtcbiAgICAgICAgZXJyLm5hbWUgPSAnTm90Rm91bmRFcnJvcic7XG4gICAgICAgIC8vIGZyb20gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLURPTUV4Y2VwdGlvbi1lcnJvci1uYW1lc1xuICAgICAgICBlcnIuY29kZSA9IDg7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnN0cmFpbnRzLnZpZGVvID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0ge21lZGlhU291cmNlOiBwcmVmZXJyZWRNZWRpYVNvdXJjZX07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdHJhaW50cy52aWRlby5tZWRpYVNvdXJjZSA9IHByZWZlcnJlZE1lZGlhU291cmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgfTtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcbiAgY29uc3QgTWVkaWFTdHJlYW1UcmFjayA9IHdpbmRvdyAmJiB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaztcblxuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIC8vIFJlcGxhY2UgRmlyZWZveCA0NCsncyBkZXByZWNhdGlvbiB3YXJuaW5nIHdpdGggdW5wcmVmaXhlZCB2ZXJzaW9uLlxuICAgIHV0aWxzLmRlcHJlY2F0ZWQoJ25hdmlnYXRvci5nZXRVc2VyTWVkaWEnLFxuICAgICAgICAnbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEnKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICB9O1xuXG4gIGlmICghKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPiA1NSAmJlxuICAgICAgJ2F1dG9HYWluQ29udHJvbCcgaW4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cygpKSkge1xuICAgIGNvbnN0IHJlbWFwID0gZnVuY3Rpb24ob2JqLCBhLCBiKSB7XG4gICAgICBpZiAoYSBpbiBvYmogJiYgIShiIGluIG9iaikpIHtcbiAgICAgICAgb2JqW2JdID0gb2JqW2FdO1xuICAgICAgICBkZWxldGUgb2JqW2FdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBuYXRpdmVHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5cbiAgICAgICAgYmluZChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIGlmICh0eXBlb2YgYyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdtb3pBdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUdldFVzZXJNZWRpYShjKTtcbiAgICB9O1xuXG4gICAgaWYgKE1lZGlhU3RyZWFtVHJhY2sgJiYgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUdldFNldHRpbmdzID0gTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3M7XG4gICAgICBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBvYmogPSBuYXRpdmVHZXRTZXR0aW5ncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZW1hcChvYmosICdtb3pBdXRvR2FpbkNvbnRyb2wnLCAnYXV0b0dhaW5Db250cm9sJyk7XG4gICAgICAgIHJlbWFwKG9iaiwgJ21vek5vaXNlU3VwcHJlc3Npb24nLCAnbm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoTWVkaWFTdHJlYW1UcmFjayAmJiBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzKSB7XG4gICAgICBjb25zdCBuYXRpdmVBcHBseUNvbnN0cmFpbnRzID1cbiAgICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cztcbiAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHMgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICdhdWRpbycgJiYgdHlwZW9mIGMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgYyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpO1xuICAgICAgICAgIHJlbWFwKGMsICdhdXRvR2FpbkNvbnRyb2wnLCAnbW96QXV0b0dhaW5Db250cm9sJyk7XG4gICAgICAgICAgcmVtYXAoYywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYXRpdmVBcHBseUNvbnN0cmFpbnRzLmFwcGx5KHRoaXMsIFtjXSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltTG9jYWxTdHJlYW1zQVBJKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnZ2V0TG9jYWxTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID1cbiAgICAgIGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdHJlYW1zO1xuICAgICAgfTtcbiAgfVxuICBpZiAoISgnYWRkU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IF9hZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIC8vIFRyeSB0byBlbXVsYXRlIENocm9tZSdzIGJlaGF2aW91ciBvZiBhZGRpbmcgaW4gYXVkaW8tdmlkZW8gb3JkZXIuXG4gICAgICAvLyBTYWZhcmkgb3JkZXJzIGJ5IHRyYWNrIGlkLlxuICAgICAgc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiBfYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayxcbiAgICAgICAgc3RyZWFtKSk7XG4gICAgICBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IF9hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrLFxuICAgICAgICBzdHJlYW0pKTtcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9XG4gICAgICBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgLi4uc3RyZWFtcykge1xuICAgICAgICBpZiAoc3RyZWFtcykge1xuICAgICAgICAgIHN0cmVhbXMuZm9yRWFjaCgoc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbc3RyZWFtXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9hZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfVxuICBpZiAoISgncmVtb3ZlU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID1cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xvY2FsU3RyZWFtcy5pbmRleE9mKHN0cmVhbSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbS5nZXRUcmFja3MoKTtcbiAgICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzZW5kZXIgPT4ge1xuICAgICAgICAgIGlmICh0cmFja3MuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUmVtb3RlU3RyZWFtc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoJ2dldFJlbW90ZVN0cmVhbXMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZW1vdGVTdHJlYW1zID1cbiAgICAgIGZ1bmN0aW9uIGdldFJlbW90ZVN0cmVhbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVTdHJlYW1zID8gdGhpcy5fcmVtb3RlU3RyZWFtcyA6IFtdO1xuICAgICAgfTtcbiAgfVxuICBpZiAoISgnb25hZGRzdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbmFkZHN0cmVhbScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uYWRkc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHNldChmKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbmFkZHN0cmVhbSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0pO1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0gPSBmKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSA9IChlKSA9PiB7XG4gICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVtb3RlU3RyZWFtcykge1xuICAgICAgICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVtb3RlU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHN0cmVhbScpO1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9XG4gICAgICBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgICAgICAgY29uc3QgcGMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX29uYWRkc3RyZWFtcG9seSkge1xuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnN0cmVhbXMuZm9yRWFjaChzdHJlYW0gPT4ge1xuICAgICAgICAgICAgICBpZiAoIXBjLl9yZW1vdGVTdHJlYW1zKSB7XG4gICAgICAgICAgICAgICAgcGMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocGMuX3JlbW90ZVN0cmVhbXMuaW5kZXhPZihzdHJlYW0pID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGMuX3JlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XG4gICAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgcGMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHBjLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvdG90eXBlID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gcHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICBjb25zdCBvcmlnQ3JlYXRlQW5zd2VyID0gcHJvdG90eXBlLmNyZWF0ZUFuc3dlcjtcbiAgY29uc3Qgc2V0TG9jYWxEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICBjb25zdCBzZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgY29uc3QgYWRkSWNlQ2FuZGlkYXRlID0gcHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcblxuICBwcm90b3R5cGUuY3JlYXRlT2ZmZXIgPVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gKGFyZ3VtZW50cy5sZW5ndGggPj0gMikgPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbMF07XG4gICAgICBjb25zdCBwcm9taXNlID0gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcblxuICBwcm90b3R5cGUuY3JlYXRlQW5zd2VyID1cbiAgICBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIoc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1swXTtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcblxuICBsZXQgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSB3aXRoQ2FsbGJhY2s7XG5cbiAgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHNldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbl0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpdGhDYWxsYmFjaztcblxuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbihjYW5kaWRhdGUsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IGFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBbY2FuZGlkYXRlXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IHdpdGhDYWxsYmFjaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEod2luZG93KSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuXG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgLy8gc2hpbSBub3QgbmVlZGVkIGluIFNhZmFyaSAxMi4xXG4gICAgY29uc3QgbWVkaWFEZXZpY2VzID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcztcbiAgICBjb25zdCBfZ2V0VXNlck1lZGlhID0gbWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSAoY29uc3RyYWludHMpID0+IHtcbiAgICAgIHJldHVybiBfZ2V0VXNlck1lZGlhKHNoaW1Db25zdHJhaW50cyhjb25zdHJhaW50cykpO1xuICAgIH07XG4gIH1cblxuICBpZiAoIW5hdmlnYXRvci5nZXRVc2VyTWVkaWEgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJlxuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50cywgY2IsIGVycmNiKSB7XG4gICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgICAgIC50aGVuKGNiLCBlcnJjYik7XG4gICAgfS5iaW5kKG5hdmlnYXRvcik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1Db25zdHJhaW50cyhjb25zdHJhaW50cykge1xuICBpZiAoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMudmlkZW8gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgY29uc3RyYWludHMsXG4gICAgICB7dmlkZW86IHV0aWxzLmNvbXBhY3RPYmplY3QoY29uc3RyYWludHMudmlkZW8pfVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gY29uc3RyYWludHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUlRDSWNlU2VydmVyVXJscyh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gbWlncmF0ZSBmcm9tIG5vbi1zcGVjIFJUQ0ljZVNlcnZlci51cmwgdG8gUlRDSWNlU2VydmVyLnVybHNcbiAgY29uc3QgT3JpZ1BlZXJDb25uZWN0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPVxuICAgIGZ1bmN0aW9uIFJUQ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKSB7XG4gICAgICBpZiAocGNDb25maWcgJiYgcGNDb25maWcuaWNlU2VydmVycykge1xuICAgICAgICBjb25zdCBuZXdJY2VTZXJ2ZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGNDb25maWcuaWNlU2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBzZXJ2ZXIgPSBwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldO1xuICAgICAgICAgIGlmICghc2VydmVyLmhhc093blByb3BlcnR5KCd1cmxzJykgJiZcbiAgICAgICAgICAgICAgc2VydmVyLmhhc093blByb3BlcnR5KCd1cmwnKSkge1xuICAgICAgICAgICAgdXRpbHMuZGVwcmVjYXRlZCgnUlRDSWNlU2VydmVyLnVybCcsICdSVENJY2VTZXJ2ZXIudXJscycpO1xuICAgICAgICAgICAgc2VydmVyID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzZXJ2ZXIpKTtcbiAgICAgICAgICAgIHNlcnZlci51cmxzID0gc2VydmVyLnVybDtcbiAgICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXIudXJsO1xuICAgICAgICAgICAgbmV3SWNlU2VydmVycy5wdXNoKHNlcnZlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGNDb25maWcuaWNlU2VydmVycyA9IG5ld0ljZVNlcnZlcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IE9yaWdQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cyk7XG4gICAgfTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSA9IE9yaWdQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIC8vIHdyYXAgc3RhdGljIG1ldGhvZHMuIEN1cnJlbnRseSBqdXN0IGdlbmVyYXRlQ2VydGlmaWNhdGUuXG4gIGlmICgnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScgaW4gT3JpZ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiwgJ2dlbmVyYXRlQ2VydGlmaWNhdGUnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBPcmlnUGVlckNvbm5lY3Rpb24uZ2VuZXJhdGVDZXJ0aWZpY2F0ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcih3aW5kb3cpIHtcbiAgLy8gQWRkIGV2ZW50LnRyYW5zY2VpdmVyIG1lbWJlciBvdmVyIGRlcHJlY2F0ZWQgZXZlbnQucmVjZWl2ZXJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENUcmFja0V2ZW50ICYmXG4gICAgICAncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSAmJlxuICAgICAgISgndHJhbnNjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7cmVjZWl2ZXI6IHRoaXMucmVjZWl2ZXJ9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXJMZWdhY3kod2luZG93KSB7XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKG9mZmVyT3B0aW9ucykge1xuICAgICAgaWYgKG9mZmVyT3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIHN1cHBvcnQgYml0IHZhbHVlc1xuICAgICAgICAgIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID1cbiAgICAgICAgICAgICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXVkaW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZCh0cmFuc2NlaXZlciA9PlxuICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpO1xuICAgICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPT09IGZhbHNlICYmIGF1ZGlvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicpIHtcbiAgICAgICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignc2VuZG9ubHknKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAncmVjdm9ubHknKSB7XG4gICAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ2luYWN0aXZlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID09PSB0cnVlICYmXG4gICAgICAgICAgICAhYXVkaW9UcmFuc2NlaXZlcikge1xuICAgICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJywge2RpcmVjdGlvbjogJ3JlY3Zvbmx5J30pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcbiAgICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9XG4gICAgICAgICAgICAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZGVvVHJhbnNjZWl2ZXIgPSB0aGlzLmdldFRyYW5zY2VpdmVycygpLmZpbmQodHJhbnNjZWl2ZXIgPT5cbiAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAndmlkZW8nKTtcbiAgICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID09PSBmYWxzZSAmJiB2aWRlb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnKSB7XG4gICAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5Jykge1xuICAgICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgIXZpZGVvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCd2aWRlbycsIHtkaXJlY3Rpb246ICdyZWN2b25seSd9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQXVkaW9Db250ZXh0KHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgd2luZG93LkF1ZGlvQ29udGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcbn1cblxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4gLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbmxldCBsb2dEaXNhYmxlZF8gPSB0cnVlO1xubGV0IGRlcHJlY2F0aW9uV2FybmluZ3NfID0gdHJ1ZTtcblxuLyoqXG4gKiBFeHRyYWN0IGJyb3dzZXIgdmVyc2lvbiBvdXQgb2YgdGhlIHByb3ZpZGVkIHVzZXIgYWdlbnQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gdWFzdHJpbmcgdXNlckFnZW50IHN0cmluZy5cbiAqIEBwYXJhbSB7IXN0cmluZ30gZXhwciBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCBhcyBtYXRjaCBjcml0ZXJpYS5cbiAqIEBwYXJhbSB7IW51bWJlcn0gcG9zIHBvc2l0aW9uIGluIHRoZSB2ZXJzaW9uIHN0cmluZyB0byBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IGJyb3dzZXIgdmVyc2lvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RWZXJzaW9uKHVhc3RyaW5nLCBleHByLCBwb3MpIHtcbiAgY29uc3QgbWF0Y2ggPSB1YXN0cmluZy5tYXRjaChleHByKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSBwb3MgJiYgcGFyc2VJbnQobWF0Y2hbcG9zXSwgMTApO1xufVxuXG4vLyBXcmFwcyB0aGUgcGVlcmNvbm5lY3Rpb24gZXZlbnQgZXZlbnROYW1lVG9XcmFwIGluIGEgZnVuY3Rpb25cbi8vIHdoaWNoIHJldHVybnMgdGhlIG1vZGlmaWVkIGV2ZW50IG9iamVjdCAob3IgZmFsc2UgdG8gcHJldmVudFxuLy8gdGhlIGV2ZW50KS5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csIGV2ZW50TmFtZVRvV3JhcCwgd3JhcHBlcikge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm90byA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIGNvbnN0IG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIgPSBwcm90by5hZGRFdmVudExpc3RlbmVyO1xuICBwcm90by5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24obmF0aXZlRXZlbnROYW1lLCBjYikge1xuICAgIGlmIChuYXRpdmVFdmVudE5hbWUgIT09IGV2ZW50TmFtZVRvV3JhcCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IG1vZGlmaWVkRXZlbnQgPSB3cmFwcGVyKGUpO1xuICAgICAgaWYgKG1vZGlmaWVkRXZlbnQpIHtcbiAgICAgICAgaWYgKGNiLmhhbmRsZUV2ZW50KSB7XG4gICAgICAgICAgY2IuaGFuZGxlRXZlbnQobW9kaWZpZWRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobW9kaWZpZWRFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2V2ZW50TWFwID0gdGhpcy5fZXZlbnRNYXAgfHwge307XG4gICAgaWYgKCF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLnNldChjYiwgd3JhcHBlZENhbGxiYWNrKTtcbiAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLFxuICAgICAgd3JhcHBlZENhbGxiYWNrXSk7XG4gIH07XG5cbiAgY29uc3QgbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIHByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihuYXRpdmVFdmVudE5hbWUsIGNiKSB7XG4gICAgaWYgKG5hdGl2ZUV2ZW50TmFtZSAhPT0gZXZlbnROYW1lVG9XcmFwIHx8ICF0aGlzLl9ldmVudE1hcFxuICAgICAgICB8fCAhdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmhhcyhjYikpIHtcbiAgICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNvbnN0IHVud3JhcHBlZENiID0gdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5nZXQoY2IpO1xuICAgIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uZGVsZXRlKGNiKTtcbiAgICBpZiAodGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5zaXplID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX2V2ZW50TWFwKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcDtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgW25hdGl2ZUV2ZW50TmFtZSxcbiAgICAgIHVud3JhcHBlZENiXSk7XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnb24nICsgZXZlbnROYW1lVG9XcmFwLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdO1xuICAgIH0sXG4gICAgc2V0KGNiKSB7XG4gICAgICBpZiAodGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZVRvV3JhcCxcbiAgICAgICAgICAgIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdO1xuICAgICAgfVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWVUb1dyYXAsXG4gICAgICAgICAgICB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUxvZyhib29sKSB7XG4gIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignQXJndW1lbnQgdHlwZTogJyArIHR5cGVvZiBib29sICtcbiAgICAgICAgJy4gUGxlYXNlIHVzZSBhIGJvb2xlYW4uJyk7XG4gIH1cbiAgbG9nRGlzYWJsZWRfID0gYm9vbDtcbiAgcmV0dXJuIChib29sKSA/ICdhZGFwdGVyLmpzIGxvZ2dpbmcgZGlzYWJsZWQnIDpcbiAgICAgICdhZGFwdGVyLmpzIGxvZ2dpbmcgZW5hYmxlZCc7XG59XG5cbi8qKlxuICogRGlzYWJsZSBvciBlbmFibGUgZGVwcmVjYXRpb24gd2FybmluZ3NcbiAqIEBwYXJhbSB7IWJvb2xlYW59IGJvb2wgc2V0IHRvIHRydWUgdG8gZGlzYWJsZSB3YXJuaW5ncy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVXYXJuaW5ncyhib29sKSB7XG4gIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignQXJndW1lbnQgdHlwZTogJyArIHR5cGVvZiBib29sICtcbiAgICAgICAgJy4gUGxlYXNlIHVzZSBhIGJvb2xlYW4uJyk7XG4gIH1cbiAgZGVwcmVjYXRpb25XYXJuaW5nc18gPSAhYm9vbDtcbiAgcmV0dXJuICdhZGFwdGVyLmpzIGRlcHJlY2F0aW9uIHdhcm5pbmdzICcgKyAoYm9vbCA/ICdkaXNhYmxlZCcgOiAnZW5hYmxlZCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAobG9nRGlzYWJsZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNob3dzIGEgZGVwcmVjYXRpb24gd2FybmluZyBzdWdnZXN0aW5nIHRoZSBtb2Rlcm4gYW5kIHNwZWMtY29tcGF0aWJsZSBBUEkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGVkKG9sZE1ldGhvZCwgbmV3TWV0aG9kKSB7XG4gIGlmICghZGVwcmVjYXRpb25XYXJuaW5nc18pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS53YXJuKG9sZE1ldGhvZCArICcgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSAnICsgbmV3TWV0aG9kICtcbiAgICAgICcgaW5zdGVhZC4nKTtcbn1cblxuLyoqXG4gKiBCcm93c2VyIGRldGVjdG9yLlxuICpcbiAqIEByZXR1cm4ge29iamVjdH0gcmVzdWx0IGNvbnRhaW5pbmcgYnJvd3NlciBhbmQgdmVyc2lvblxuICogICAgIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RCcm93c2VyKHdpbmRvdykge1xuICAvLyBSZXR1cm5lZCByZXN1bHQgb2JqZWN0LlxuICBjb25zdCByZXN1bHQgPSB7YnJvd3NlcjogbnVsbCwgdmVyc2lvbjogbnVsbH07XG5cbiAgLy8gRmFpbCBlYXJseSBpZiBpdCdzIG5vdCBhIGJyb3dzZXJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cubmF2aWdhdG9yKSB7XG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgYnJvd3Nlci4nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBjb25zdCB7bmF2aWdhdG9yfSA9IHdpbmRvdztcblxuICBpZiAobmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkgeyAvLyBGaXJlZm94LlxuICAgIHJlc3VsdC5icm93c2VyID0gJ2ZpcmVmb3gnO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgL0ZpcmVmb3hcXC8oXFxkKylcXC4vLCAxKTtcbiAgfSBlbHNlIGlmIChuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8XG4gICAgICAod2luZG93LmlzU2VjdXJlQ29udGV4dCA9PT0gZmFsc2UgJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICAgIXdpbmRvdy5SVENJY2VHYXRoZXJlcikpIHtcbiAgICAvLyBDaHJvbWUsIENocm9taXVtLCBXZWJ2aWV3LCBPcGVyYS5cbiAgICAvLyBWZXJzaW9uIG1hdGNoZXMgQ2hyb21lL1dlYlJUQyB2ZXJzaW9uLlxuICAgIC8vIENocm9tZSA3NCByZW1vdmVkIHdlYmtpdEdldFVzZXJNZWRpYSBvbiBodHRwIGFzIHdlbGwgc28gd2UgbmVlZCB0aGVcbiAgICAvLyBtb3JlIGNvbXBsaWNhdGVkIGZhbGxiYWNrIHRvIHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ2Nocm9tZSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICAvQ2hyb20oZXxpdW0pXFwvKFxcZCspXFwuLywgMik7XG4gIH0gZWxzZSBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pKSB7IC8vIFNhZmFyaS5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdzYWZhcmknO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLywgMSk7XG4gICAgcmVzdWx0LnN1cHBvcnRzVW5pZmllZFBsYW4gPSB3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXIgJiZcbiAgICAgICAgJ2N1cnJlbnREaXJlY3Rpb24nIGluIHdpbmRvdy5SVENSdHBUcmFuc2NlaXZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7IC8vIERlZmF1bHQgZmFsbHRocm91Z2g6IG5vdCBzdXBwb3J0ZWQuXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgc3VwcG9ydGVkIGJyb3dzZXIuJztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgc29tZXRoaW5nIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgc29tZXRoaW5nIHlvdSB3YW50IHRvIGNoZWNrLlxuICogQHJldHVybiB0cnVlIGlmIHZhbCBpcyBhbiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBlbXB0eSBvYmplY3RzIGFuZCB1bmRlZmluZWQgdmFsdWVzXG4gKiBmcm9tIGEgbmVzdGVkIG9iamVjdCAtLSBhbiBlbmhhbmNlZCBhbmQgdmFuaWxsYSB2ZXJzaW9uXG4gKiBvZiBMb2Rhc2gncyBgY29tcGFjdGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYWN0T2JqZWN0KGRhdGEpIHtcbiAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRhdGEpLnJlZHVjZShmdW5jdGlvbihhY2N1bXVsYXRvciwga2V5KSB7XG4gICAgY29uc3QgaXNPYmogPSBpc09iamVjdChkYXRhW2tleV0pO1xuICAgIGNvbnN0IHZhbHVlID0gaXNPYmogPyBjb21wYWN0T2JqZWN0KGRhdGFba2V5XSkgOiBkYXRhW2tleV07XG4gICAgY29uc3QgaXNFbXB0eU9iamVjdCA9IGlzT2JqICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzRW1wdHlPYmplY3QpIHtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjdW11bGF0b3IsIHtba2V5XTogdmFsdWV9KTtcbiAgfSwge30pO1xufVxuXG4vKiBpdGVyYXRlcyB0aGUgc3RhdHMgZ3JhcGggcmVjdXJzaXZlbHkuICovXG5leHBvcnQgZnVuY3Rpb24gd2Fsa1N0YXRzKHN0YXRzLCBiYXNlLCByZXN1bHRTZXQpIHtcbiAgaWYgKCFiYXNlIHx8IHJlc3VsdFNldC5oYXMoYmFzZS5pZCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVzdWx0U2V0LnNldChiYXNlLmlkLCBiYXNlKTtcbiAgT2JqZWN0LmtleXMoYmFzZSkuZm9yRWFjaChuYW1lID0+IHtcbiAgICBpZiAobmFtZS5lbmRzV2l0aCgnSWQnKSkge1xuICAgICAgd2Fsa1N0YXRzKHN0YXRzLCBzdGF0cy5nZXQoYmFzZVtuYW1lXSksIHJlc3VsdFNldCk7XG4gICAgfSBlbHNlIGlmIChuYW1lLmVuZHNXaXRoKCdJZHMnKSkge1xuICAgICAgYmFzZVtuYW1lXS5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgd2Fsa1N0YXRzKHN0YXRzLCBzdGF0cy5nZXQoaWQpLCByZXN1bHRTZXQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyogZmlsdGVyIGdldFN0YXRzIGZvciBhIHNlbmRlci9yZWNlaXZlciB0cmFjay4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJTdGF0cyhyZXN1bHQsIHRyYWNrLCBvdXRib3VuZCkge1xuICBjb25zdCBzdHJlYW1TdGF0c1R5cGUgPSBvdXRib3VuZCA/ICdvdXRib3VuZC1ydHAnIDogJ2luYm91bmQtcnRwJztcbiAgY29uc3QgZmlsdGVyZWRSZXN1bHQgPSBuZXcgTWFwKCk7XG4gIGlmICh0cmFjayA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmaWx0ZXJlZFJlc3VsdDtcbiAgfVxuICBjb25zdCB0cmFja1N0YXRzID0gW107XG4gIHJlc3VsdC5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ3RyYWNrJyAmJlxuICAgICAgICB2YWx1ZS50cmFja0lkZW50aWZpZXIgPT09IHRyYWNrLmlkKSB7XG4gICAgICB0cmFja1N0YXRzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHRyYWNrU3RhdHMuZm9yRWFjaCh0cmFja1N0YXQgPT4ge1xuICAgIHJlc3VsdC5mb3JFYWNoKHN0YXRzID0+IHtcbiAgICAgIGlmIChzdGF0cy50eXBlID09PSBzdHJlYW1TdGF0c1R5cGUgJiYgc3RhdHMudHJhY2tJZCA9PT0gdHJhY2tTdGF0LmlkKSB7XG4gICAgICAgIHdhbGtTdGF0cyhyZXN1bHQsIHN0YXRzLCBmaWx0ZXJlZFJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyZWRSZXN1bHQ7XG59XG5cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgZGVmaW5pdGlvbikge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7IH0iLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3QvaW5kZXguanNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=